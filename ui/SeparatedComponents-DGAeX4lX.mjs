var oI = Object.defineProperty;
var Qp = (t) => {
  throw TypeError(t);
};
var aI = (t, e, n) => e in t ? oI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Ui = (t, e, n) => aI(t, typeof e != "symbol" ? e + "" : e, n), Jp = (t, e, n) => e.has(t) || Qp("Cannot " + n);
var Zp = (t, e, n) => (Jp(t, e, "read from private field"), n ? n.call(t) : e.get(t)), em = (t, e, n) => e.has(t) ? Qp("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), tm = (t, e, n, r) => (Jp(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n);
import * as Fr from "react";
import Me, { useContext as cI, useRef as lI, useCallback as Bo, useDebugValue as uI, useEffect as vt, StrictMode as dI, useState as fI, useDeferredValue as hI, useMemo as ct, forwardRef as pI } from "react";
import { G as Lf, H as Ni, z as Nb, I as ur, J as il, d as Id, f as wc, F as Uf, S as Ob, v as mI, m as Ff, l as Pb, q as xb, D as qs, K as Mb, e as ai, t as Yt, a as gI, c as Db } from "./index-BKGVs8aB.mjs";
import yI, { unstable_batchedUpdates as _I } from "react-dom";
function Lb(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Ba = { exports: {} }, Io = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nm;
function bI() {
  if (nm) return Io;
  nm = 1;
  var t = Me, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, l, u) {
    var d, f = {}, p = null, g = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (d in l) r.call(l, d) && !s.hasOwnProperty(d) && (f[d] = l[d]);
    if (a && a.defaultProps) for (d in l = a.defaultProps, l) f[d] === void 0 && (f[d] = l[d]);
    return { $$typeof: e, type: a, key: p, ref: g, props: f, _owner: i.current };
  }
  return Io.Fragment = n, Io.jsx = o, Io.jsxs = o, Io;
}
var So = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rm;
function vI() {
  return rm || (rm = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Me, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), _ = Symbol.iterator, b = "@@iterator";
    function m(O) {
      if (O === null || typeof O != "object")
        return null;
      var z = _ && O[_] || O[b];
      return typeof z == "function" ? z : null;
    }
    var v = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function C(O) {
      {
        for (var z = arguments.length, te = new Array(z > 1 ? z - 1 : 0), Ae = 1; Ae < z; Ae++)
          te[Ae - 1] = arguments[Ae];
        x("error", O, te);
      }
    }
    function x(O, z, te) {
      {
        var Ae = v.ReactDebugCurrentFrame, $e = Ae.getStackAddendum();
        $e !== "" && (z += "%s", te = te.concat([$e]));
        var Ge = te.map(function(ke) {
          return String(ke);
        });
        Ge.unshift("Warning: " + z), Function.prototype.apply.call(console[O], console, Ge);
      }
    }
    var P = !1, k = !1, U = !1, I = !1, E = !1, T;
    T = Symbol.for("react.module.reference");
    function A(O) {
      return !!(typeof O == "string" || typeof O == "function" || O === r || O === s || E || O === i || O === u || O === d || I || O === g || P || k || U || typeof O == "object" && O !== null && (O.$$typeof === p || O.$$typeof === f || O.$$typeof === o || O.$$typeof === a || O.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      O.$$typeof === T || O.getModuleId !== void 0));
    }
    function R(O, z, te) {
      var Ae = O.displayName;
      if (Ae)
        return Ae;
      var $e = z.displayName || z.name || "";
      return $e !== "" ? te + "(" + $e + ")" : te;
    }
    function M(O) {
      return O.displayName || "Context";
    }
    function S(O) {
      if (O == null)
        return null;
      if (typeof O.tag == "number" && C("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof O == "function")
        return O.displayName || O.name || null;
      if (typeof O == "string")
        return O;
      switch (O) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof O == "object")
        switch (O.$$typeof) {
          case a:
            var z = O;
            return M(z) + ".Consumer";
          case o:
            var te = O;
            return M(te._context) + ".Provider";
          case l:
            return R(O, O.render, "ForwardRef");
          case f:
            var Ae = O.displayName || null;
            return Ae !== null ? Ae : S(O.type) || "Memo";
          case p: {
            var $e = O, Ge = $e._payload, ke = $e._init;
            try {
              return S(ke(Ge));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var D = Object.assign, V = 0, X, ge, Te, Ie, B, q, se;
    function re() {
    }
    re.__reactDisabledLog = !0;
    function ae() {
      {
        if (V === 0) {
          X = console.log, ge = console.info, Te = console.warn, Ie = console.error, B = console.group, q = console.groupCollapsed, se = console.groupEnd;
          var O = {
            configurable: !0,
            enumerable: !0,
            value: re,
            writable: !0
          };
          Object.defineProperties(console, {
            info: O,
            log: O,
            warn: O,
            error: O,
            group: O,
            groupCollapsed: O,
            groupEnd: O
          });
        }
        V++;
      }
    }
    function ce() {
      {
        if (V--, V === 0) {
          var O = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: D({}, O, {
              value: X
            }),
            info: D({}, O, {
              value: ge
            }),
            warn: D({}, O, {
              value: Te
            }),
            error: D({}, O, {
              value: Ie
            }),
            group: D({}, O, {
              value: B
            }),
            groupCollapsed: D({}, O, {
              value: q
            }),
            groupEnd: D({}, O, {
              value: se
            })
          });
        }
        V < 0 && C("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var pe = v.ReactCurrentDispatcher, ie;
    function le(O, z, te) {
      {
        if (ie === void 0)
          try {
            throw Error();
          } catch ($e) {
            var Ae = $e.stack.trim().match(/\n( *(at )?)/);
            ie = Ae && Ae[1] || "";
          }
        return `
` + ie + O;
      }
    }
    var Se = !1, de;
    {
      var Le = typeof WeakMap == "function" ? WeakMap : Map;
      de = new Le();
    }
    function K(O, z) {
      if (!O || Se)
        return "";
      {
        var te = de.get(O);
        if (te !== void 0)
          return te;
      }
      var Ae;
      Se = !0;
      var $e = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ge;
      Ge = pe.current, pe.current = null, ae();
      try {
        if (z) {
          var ke = function() {
            throw Error();
          };
          if (Object.defineProperty(ke.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ke, []);
            } catch (Nt) {
              Ae = Nt;
            }
            Reflect.construct(O, [], ke);
          } else {
            try {
              ke.call();
            } catch (Nt) {
              Ae = Nt;
            }
            O.call(ke.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Nt) {
            Ae = Nt;
          }
          O();
        }
      } catch (Nt) {
        if (Nt && Ae && typeof Nt.stack == "string") {
          for (var Oe = Nt.stack.split(`
`), xt = Ae.stack.split(`
`), lt = Oe.length - 1, ht = xt.length - 1; lt >= 1 && ht >= 0 && Oe[lt] !== xt[ht]; )
            ht--;
          for (; lt >= 1 && ht >= 0; lt--, ht--)
            if (Oe[lt] !== xt[ht]) {
              if (lt !== 1 || ht !== 1)
                do
                  if (lt--, ht--, ht < 0 || Oe[lt] !== xt[ht]) {
                    var bt = `
` + Oe[lt].replace(" at new ", " at ");
                    return O.displayName && bt.includes("<anonymous>") && (bt = bt.replace("<anonymous>", O.displayName)), typeof O == "function" && de.set(O, bt), bt;
                  }
                while (lt >= 1 && ht >= 0);
              break;
            }
        }
      } finally {
        Se = !1, pe.current = Ge, ce(), Error.prepareStackTrace = $e;
      }
      var Pn = O ? O.displayName || O.name : "", xn = Pn ? le(Pn) : "";
      return typeof O == "function" && de.set(O, xn), xn;
    }
    function Qe(O, z, te) {
      return K(O, !1);
    }
    function ue(O) {
      var z = O.prototype;
      return !!(z && z.isReactComponent);
    }
    function Ut(O, z, te) {
      if (O == null)
        return "";
      if (typeof O == "function")
        return K(O, ue(O));
      if (typeof O == "string")
        return le(O);
      switch (O) {
        case u:
          return le("Suspense");
        case d:
          return le("SuspenseList");
      }
      if (typeof O == "object")
        switch (O.$$typeof) {
          case l:
            return Qe(O.render);
          case f:
            return Ut(O.type, z, te);
          case p: {
            var Ae = O, $e = Ae._payload, Ge = Ae._init;
            try {
              return Ut(Ge($e), z, te);
            } catch {
            }
          }
        }
      return "";
    }
    var Ft = Object.prototype.hasOwnProperty, kn = {}, Ir = v.ReactDebugCurrentFrame;
    function zn(O) {
      if (O) {
        var z = O._owner, te = Ut(O.type, O._source, z ? z.type : null);
        Ir.setExtraStackFrame(te);
      } else
        Ir.setExtraStackFrame(null);
    }
    function sr(O, z, te, Ae, $e) {
      {
        var Ge = Function.call.bind(Ft);
        for (var ke in O)
          if (Ge(O, ke)) {
            var Oe = void 0;
            try {
              if (typeof O[ke] != "function") {
                var xt = Error((Ae || "React class") + ": " + te + " type `" + ke + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof O[ke] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw xt.name = "Invariant Violation", xt;
              }
              Oe = O[ke](z, ke, Ae, te, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (lt) {
              Oe = lt;
            }
            Oe && !(Oe instanceof Error) && (zn($e), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ae || "React class", te, ke, typeof Oe), zn(null)), Oe instanceof Error && !(Oe.message in kn) && (kn[Oe.message] = !0, zn($e), C("Failed %s type: %s", te, Oe.message), zn(null));
          }
      }
    }
    var or = Array.isArray;
    function Sr(O) {
      return or(O);
    }
    function ar(O) {
      {
        var z = typeof Symbol == "function" && Symbol.toStringTag, te = z && O[Symbol.toStringTag] || O.constructor.name || "Object";
        return te;
      }
    }
    function un(O) {
      try {
        return En(O), !1;
      } catch {
        return !0;
      }
    }
    function En(O) {
      return "" + O;
    }
    function We(O) {
      if (un(O))
        return C("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ar(O)), En(O);
    }
    var gt = v.ReactCurrentOwner, Wn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, cr, Gn;
    function Oi(O) {
      if (Ft.call(O, "ref")) {
        var z = Object.getOwnPropertyDescriptor(O, "ref").get;
        if (z && z.isReactWarning)
          return !1;
      }
      return O.ref !== void 0;
    }
    function Nn(O) {
      if (Ft.call(O, "key")) {
        var z = Object.getOwnPropertyDescriptor(O, "key").get;
        if (z && z.isReactWarning)
          return !1;
      }
      return O.key !== void 0;
    }
    function ti(O, z) {
      typeof O.ref == "string" && gt.current;
    }
    function Ar(O, z) {
      {
        var te = function() {
          cr || (cr = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", z));
        };
        te.isReactWarning = !0, Object.defineProperty(O, "key", {
          get: te,
          configurable: !0
        });
      }
    }
    function Rr(O, z) {
      {
        var te = function() {
          Gn || (Gn = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", z));
        };
        te.isReactWarning = !0, Object.defineProperty(O, "ref", {
          get: te,
          configurable: !0
        });
      }
    }
    var Pi = function(O, z, te, Ae, $e, Ge, ke) {
      var Oe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: O,
        key: z,
        ref: te,
        props: ke,
        // Record the component responsible for creating this element.
        _owner: Ge
      };
      return Oe._store = {}, Object.defineProperty(Oe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Oe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ae
      }), Object.defineProperty(Oe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: $e
      }), Object.freeze && (Object.freeze(Oe.props), Object.freeze(Oe)), Oe;
    };
    function xi(O, z, te, Ae, $e) {
      {
        var Ge, ke = {}, Oe = null, xt = null;
        te !== void 0 && (We(te), Oe = "" + te), Nn(z) && (We(z.key), Oe = "" + z.key), Oi(z) && (xt = z.ref, ti(z, $e));
        for (Ge in z)
          Ft.call(z, Ge) && !Wn.hasOwnProperty(Ge) && (ke[Ge] = z[Ge]);
        if (O && O.defaultProps) {
          var lt = O.defaultProps;
          for (Ge in lt)
            ke[Ge] === void 0 && (ke[Ge] = lt[Ge]);
        }
        if (Oe || xt) {
          var ht = typeof O == "function" ? O.displayName || O.name || "Unknown" : O;
          Oe && Ar(ke, ht), xt && Rr(ke, ht);
        }
        return Pi(O, Oe, xt, $e, Ae, gt.current, ke);
      }
    }
    var wn = v.ReactCurrentOwner, lr = v.ReactDebugCurrentFrame;
    function Ue(O) {
      if (O) {
        var z = O._owner, te = Ut(O.type, O._source, z ? z.type : null);
        lr.setExtraStackFrame(te);
      } else
        lr.setExtraStackFrame(null);
    }
    var Zt;
    Zt = !1;
    function en(O) {
      return typeof O == "object" && O !== null && O.$$typeof === e;
    }
    function dn() {
      {
        if (wn.current) {
          var O = S(wn.current.type);
          if (O)
            return `

Check the render method of \`` + O + "`.";
        }
        return "";
      }
    }
    function N(O) {
      return "";
    }
    var $ = {};
    function Q(O) {
      {
        var z = dn();
        if (!z) {
          var te = typeof O == "string" ? O : O.displayName || O.name;
          te && (z = `

Check the top-level render call using <` + te + ">.");
        }
        return z;
      }
    }
    function Re(O, z) {
      {
        if (!O._store || O._store.validated || O.key != null)
          return;
        O._store.validated = !0;
        var te = Q(z);
        if ($[te])
          return;
        $[te] = !0;
        var Ae = "";
        O && O._owner && O._owner !== wn.current && (Ae = " It was passed a child from " + S(O._owner.type) + "."), Ue(O), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', te, Ae), Ue(null);
      }
    }
    function Je(O, z) {
      {
        if (typeof O != "object")
          return;
        if (Sr(O))
          for (var te = 0; te < O.length; te++) {
            var Ae = O[te];
            en(Ae) && Re(Ae, z);
          }
        else if (en(O))
          O._store && (O._store.validated = !0);
        else if (O) {
          var $e = m(O);
          if (typeof $e == "function" && $e !== O.entries)
            for (var Ge = $e.call(O), ke; !(ke = Ge.next()).done; )
              en(ke.value) && Re(ke.value, z);
        }
      }
    }
    function dt(O) {
      {
        var z = O.type;
        if (z == null || typeof z == "string")
          return;
        var te;
        if (typeof z == "function")
          te = z.propTypes;
        else if (typeof z == "object" && (z.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        z.$$typeof === f))
          te = z.propTypes;
        else
          return;
        if (te) {
          var Ae = S(z);
          sr(te, O.props, "prop", Ae, O);
        } else if (z.PropTypes !== void 0 && !Zt) {
          Zt = !0;
          var $e = S(z);
          C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", $e || "Unknown");
        }
        typeof z.getDefaultProps == "function" && !z.getDefaultProps.isReactClassApproved && C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ee(O) {
      {
        for (var z = Object.keys(O.props), te = 0; te < z.length; te++) {
          var Ae = z[te];
          if (Ae !== "children" && Ae !== "key") {
            Ue(O), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ae), Ue(null);
            break;
          }
        }
        O.ref !== null && (Ue(O), C("Invalid attribute `ref` supplied to `React.Fragment`."), Ue(null));
      }
    }
    var oe = {};
    function Ee(O, z, te, Ae, $e, Ge) {
      {
        var ke = A(O);
        if (!ke) {
          var Oe = "";
          (O === void 0 || typeof O == "object" && O !== null && Object.keys(O).length === 0) && (Oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var xt = N();
          xt ? Oe += xt : Oe += dn();
          var lt;
          O === null ? lt = "null" : Sr(O) ? lt = "array" : O !== void 0 && O.$$typeof === e ? (lt = "<" + (S(O.type) || "Unknown") + " />", Oe = " Did you accidentally export a JSX literal instead of a component?") : lt = typeof O, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", lt, Oe);
        }
        var ht = xi(O, z, te, $e, Ge);
        if (ht == null)
          return ht;
        if (ke) {
          var bt = z.children;
          if (bt !== void 0)
            if (Ae)
              if (Sr(bt)) {
                for (var Pn = 0; Pn < bt.length; Pn++)
                  Je(bt[Pn], O);
                Object.freeze && Object.freeze(bt);
              } else
                C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Je(bt, O);
        }
        if (Ft.call(z, "key")) {
          var xn = S(O), Nt = Object.keys(z).filter(function(Mn) {
            return Mn !== "key";
          }), ni = Nt.length > 0 ? "{key: someKey, " + Nt.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!oe[xn + ni]) {
            var Mi = Nt.length > 0 ? "{" + Nt.join(": ..., ") + ": ...}" : "{}";
            C(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ni, xn, Mi, xn), oe[xn + ni] = !0;
          }
        }
        return O === r ? ee(ht) : dt(ht), ht;
      }
    }
    function ft(O, z, te) {
      return Ee(O, z, te, !0);
    }
    function _t(O, z, te) {
      return Ee(O, z, te, !1);
    }
    var Cr = _t, On = ft;
    So.Fragment = r, So.jsx = Cr, So.jsxs = On;
  }()), So;
}
var im;
function EI() {
  return im || (im = 1, process.env.NODE_ENV === "production" ? Ba.exports = bI() : Ba.exports = vI()), Ba.exports;
}
var Vf = EI();
const wI = Vf.Fragment, he = Vf.jsx, bn = Vf.jsxs;
function qt(t) {
  return `Minified Redux error #${t}; visit https://redux.js.org/Errors?code=${t} for the full message or use the non-minified dev environment for full errors. `;
}
var TI = typeof Symbol == "function" && Symbol.observable || "@@observable", sm = TI, eu = () => Math.random().toString(36).substring(7).split("").join("."), II = {
  INIT: `@@redux/INIT${/* @__PURE__ */ eu()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ eu()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${eu()}`
}, Hi = II;
function da(t) {
  if (typeof t != "object" || t === null)
    return !1;
  let e = t;
  for (; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e || Object.getPrototypeOf(t) === null;
}
function SI(t) {
  if (t === void 0)
    return "undefined";
  if (t === null)
    return "null";
  const e = typeof t;
  switch (e) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return e;
  }
  if (Array.isArray(t))
    return "array";
  if (CI(t))
    return "date";
  if (RI(t))
    return "error";
  const n = AI(t);
  switch (n) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return n;
  }
  return Object.prototype.toString.call(t).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function AI(t) {
  return typeof t.constructor == "function" ? t.constructor.name : null;
}
function RI(t) {
  return t instanceof Error || typeof t.message == "string" && t.constructor && typeof t.constructor.stackTraceLimit == "number";
}
function CI(t) {
  return t instanceof Date ? !0 : typeof t.toDateString == "function" && typeof t.getDate == "function" && typeof t.setDate == "function";
}
function oi(t) {
  let e = typeof t;
  return process.env.NODE_ENV !== "production" && (e = SI(t)), e;
}
function Ub(t, e, n) {
  if (typeof t != "function")
    throw new Error(process.env.NODE_ENV === "production" ? qt(2) : `Expected the root reducer to be a function. Instead, received: '${oi(t)}'`);
  if (typeof e == "function" && typeof n == "function" || typeof n == "function" && typeof arguments[3] == "function")
    throw new Error(process.env.NODE_ENV === "production" ? qt(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof e == "function" && typeof n > "u" && (n = e, e = void 0), typeof n < "u") {
    if (typeof n != "function")
      throw new Error(process.env.NODE_ENV === "production" ? qt(1) : `Expected the enhancer to be a function. Instead, received: '${oi(n)}'`);
    return n(Ub)(t, e);
  }
  let r = t, i = e, s = /* @__PURE__ */ new Map(), o = s, a = 0, l = !1;
  function u() {
    o === s && (o = /* @__PURE__ */ new Map(), s.forEach((m, v) => {
      o.set(v, m);
    }));
  }
  function d() {
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? qt(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return i;
  }
  function f(m) {
    if (typeof m != "function")
      throw new Error(process.env.NODE_ENV === "production" ? qt(4) : `Expected the listener to be a function. Instead, received: '${oi(m)}'`);
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? qt(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    let v = !0;
    u();
    const C = a++;
    return o.set(C, m), function() {
      if (v) {
        if (l)
          throw new Error(process.env.NODE_ENV === "production" ? qt(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        v = !1, u(), o.delete(C), s = null;
      }
    };
  }
  function p(m) {
    if (!da(m))
      throw new Error(process.env.NODE_ENV === "production" ? qt(7) : `Actions must be plain objects. Instead, the actual type was: '${oi(m)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    if (typeof m.type > "u")
      throw new Error(process.env.NODE_ENV === "production" ? qt(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (typeof m.type != "string")
      throw new Error(process.env.NODE_ENV === "production" ? qt(17) : `Action "type" property must be a string. Instead, the actual type was: '${oi(m.type)}'. Value was: '${m.type}' (stringified)`);
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? qt(9) : "Reducers may not dispatch actions.");
    try {
      l = !0, i = r(i, m);
    } finally {
      l = !1;
    }
    return (s = o).forEach((C) => {
      C();
    }), m;
  }
  function g(m) {
    if (typeof m != "function")
      throw new Error(process.env.NODE_ENV === "production" ? qt(10) : `Expected the nextReducer to be a function. Instead, received: '${oi(m)}`);
    r = m, p({
      type: Hi.REPLACE
    });
  }
  function _() {
    const m = f;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(v) {
        if (typeof v != "object" || v === null)
          throw new Error(process.env.NODE_ENV === "production" ? qt(11) : `Expected the observer to be an object. Instead, received: '${oi(v)}'`);
        function C() {
          const P = v;
          P.next && P.next(d());
        }
        return C(), {
          unsubscribe: m(C)
        };
      },
      [sm]() {
        return this;
      }
    };
  }
  return p({
    type: Hi.INIT
  }), {
    dispatch: p,
    subscribe: f,
    getState: d,
    replaceReducer: g,
    [sm]: _
  };
}
function om(t) {
  typeof console < "u" && typeof console.error == "function" && console.error(t);
  try {
    throw new Error(t);
  } catch {
  }
}
function kI(t, e, n, r) {
  const i = Object.keys(e), s = n && n.type === Hi.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (i.length === 0)
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  if (!da(t))
    return `The ${s} has unexpected type of "${oi(t)}". Expected argument to be an object with the following keys: "${i.join('", "')}"`;
  const o = Object.keys(t).filter((a) => !e.hasOwnProperty(a) && !r[a]);
  if (o.forEach((a) => {
    r[a] = !0;
  }), !(n && n.type === Hi.REPLACE) && o.length > 0)
    return `Unexpected ${o.length > 1 ? "keys" : "key"} "${o.join('", "')}" found in ${s}. Expected to find one of the known reducer keys instead: "${i.join('", "')}". Unexpected keys will be ignored.`;
}
function NI(t) {
  Object.keys(t).forEach((e) => {
    const n = t[e];
    if (typeof n(void 0, {
      type: Hi.INIT
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? qt(12) : `The slice reducer for key "${e}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    if (typeof n(void 0, {
      type: Hi.PROBE_UNKNOWN_ACTION()
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? qt(13) : `The slice reducer for key "${e}" returned undefined when probed with a random type. Don't try to handle '${Hi.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
  });
}
function OI(t) {
  const e = Object.keys(t), n = {};
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    process.env.NODE_ENV !== "production" && typeof t[a] > "u" && om(`No reducer provided for key "${a}"`), typeof t[a] == "function" && (n[a] = t[a]);
  }
  const r = Object.keys(n);
  let i;
  process.env.NODE_ENV !== "production" && (i = {});
  let s;
  try {
    NI(n);
  } catch (o) {
    s = o;
  }
  return function(a = {}, l) {
    if (s)
      throw s;
    if (process.env.NODE_ENV !== "production") {
      const f = kI(a, n, l, i);
      f && om(f);
    }
    let u = !1;
    const d = {};
    for (let f = 0; f < r.length; f++) {
      const p = r[f], g = n[p], _ = a[p], b = g(_, l);
      if (typeof b > "u") {
        const m = l && l.type;
        throw new Error(process.env.NODE_ENV === "production" ? qt(14) : `When called with an action of type ${m ? `"${String(m)}"` : "(unknown type)"}, the slice reducer for key "${p}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      d[p] = b, u = u || b !== _;
    }
    return u = u || r.length !== Object.keys(a).length, u ? d : a;
  };
}
function Tc(...t) {
  return t.length === 0 ? (e) => e : t.length === 1 ? t[0] : t.reduce((e, n) => (...r) => e(n(...r)));
}
function PI(...t) {
  return (e) => (n, r) => {
    const i = e(n, r);
    let s = () => {
      throw new Error(process.env.NODE_ENV === "production" ? qt(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const o = {
      getState: i.getState,
      dispatch: (l, ...u) => s(l, ...u)
    }, a = t.map((l) => l(o));
    return s = Tc(...a)(i.dispatch), {
      ...i,
      dispatch: s
    };
  };
}
function Bf(t) {
  return da(t) && "type" in t && typeof t.type == "string";
}
var Fb = Symbol.for("immer-nothing"), am = Symbol.for("immer-draftable"), In = Symbol.for("immer-state"), xI = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(t) {
    return `The plugin for '${t}' has not been loaded into Immer. To enable the plugin, import and call \`enable${t}()\` when initializing your application.`;
  },
  function(t) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${t}'`;
  },
  "This object has been frozen and should not be mutated",
  function(t) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + t;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(t) {
    return `'current' expects a draft, got: ${t}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(t) {
    return `'original' expects a draft, got: ${t}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function _n(t, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const n = xI[t], r = typeof n == "function" ? n.apply(null, e) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var zs = Object.getPrototypeOf;
function vr(t) {
  return !!t && !!t[In];
}
function qr(t) {
  var e;
  return t ? Vb(t) || Array.isArray(t) || !!t[am] || !!((e = t.constructor) != null && e[am]) || ol(t) || al(t) : !1;
}
var MI = Object.prototype.constructor.toString();
function Vb(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = zs(t);
  if (e === null)
    return !0;
  const n = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === MI;
}
function Ic(t, e) {
  sl(t) === 0 ? Reflect.ownKeys(t).forEach((n) => {
    e(n, t[n], t);
  }) : t.forEach((n, r) => e(r, n, t));
}
function sl(t) {
  const e = t[In];
  return e ? e.type_ : Array.isArray(t) ? 1 : ol(t) ? 2 : al(t) ? 3 : 0;
}
function Sd(t, e) {
  return sl(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function Bb(t, e, n) {
  const r = sl(t);
  r === 2 ? t.set(e, n) : r === 3 ? t.add(n) : t[e] = n;
}
function DI(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function ol(t) {
  return t instanceof Map;
}
function al(t) {
  return t instanceof Set;
}
function Bi(t) {
  return t.copy_ || t.base_;
}
function Ad(t, e) {
  if (ol(t))
    return new Map(t);
  if (al(t))
    return new Set(t);
  if (Array.isArray(t))
    return Array.prototype.slice.call(t);
  const n = Vb(t);
  if (e === !0 || e === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(t);
    delete r[In];
    let i = Reflect.ownKeys(r);
    for (let s = 0; s < i.length; s++) {
      const o = i[s], a = r[o];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[o] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: t[o]
      });
    }
    return Object.create(zs(t), r);
  } else {
    const r = zs(t);
    if (r !== null && n)
      return { ...t };
    const i = Object.create(r);
    return Object.assign(i, t);
  }
}
function $f(t, e = !1) {
  return cl(t) || vr(t) || !qr(t) || (sl(t) > 1 && (t.set = t.add = t.clear = t.delete = LI), Object.freeze(t), e && Object.entries(t).forEach(([n, r]) => $f(r, !0))), t;
}
function LI() {
  _n(2);
}
function cl(t) {
  return Object.isFrozen(t);
}
var UI = {};
function Ji(t) {
  const e = UI[t];
  return e || _n(0, t), e;
}
var Yo;
function $b() {
  return Yo;
}
function FI(t, e) {
  return {
    drafts_: [],
    parent_: t,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function cm(t, e) {
  e && (Ji("Patches"), t.patches_ = [], t.inversePatches_ = [], t.patchListener_ = e);
}
function Rd(t) {
  Cd(t), t.drafts_.forEach(VI), t.drafts_ = null;
}
function Cd(t) {
  t === Yo && (Yo = t.parent_);
}
function lm(t) {
  return Yo = FI(Yo, t);
}
function VI(t) {
  const e = t[In];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function um(t, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const n = e.drafts_[0];
  return t !== void 0 && t !== n ? (n[In].modified_ && (Rd(e), _n(4)), qr(t) && (t = Sc(e, t), e.parent_ || Ac(e, t)), e.patches_ && Ji("Patches").generateReplacementPatches_(
    n[In].base_,
    t,
    e.patches_,
    e.inversePatches_
  )) : t = Sc(e, n, []), Rd(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), t !== Fb ? t : void 0;
}
function Sc(t, e, n) {
  if (cl(e))
    return e;
  const r = e[In];
  if (!r)
    return Ic(
      e,
      (i, s) => dm(t, r, e, i, s, n)
    ), e;
  if (r.scope_ !== t)
    return e;
  if (!r.modified_)
    return Ac(t, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let s = i, o = !1;
    r.type_ === 3 && (s = new Set(i), i.clear(), o = !0), Ic(
      s,
      (a, l) => dm(t, r, i, a, l, n, o)
    ), Ac(t, i, !1), n && t.patches_ && Ji("Patches").generatePatches_(
      r,
      n,
      t.patches_,
      t.inversePatches_
    );
  }
  return r.copy_;
}
function dm(t, e, n, r, i, s, o) {
  if (process.env.NODE_ENV !== "production" && i === n && _n(5), vr(i)) {
    const a = s && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Sd(e.assigned_, r) ? s.concat(r) : void 0, l = Sc(t, i, a);
    if (Bb(n, r, l), vr(l))
      t.canAutoFreeze_ = !1;
    else
      return;
  } else o && n.add(i);
  if (qr(i) && !cl(i)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1)
      return;
    Sc(t, i), (!e || !e.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Ac(t, i);
  }
}
function Ac(t, e, n = !1) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && $f(e, n);
}
function BI(t, e) {
  const n = Array.isArray(t), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : $b(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: t,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = r, s = jf;
  n && (i = [r], s = Xo);
  const { revoke: o, proxy: a } = Proxy.revocable(i, s);
  return r.draft_ = a, r.revoke_ = o, a;
}
var jf = {
  get(t, e) {
    if (e === In)
      return t;
    const n = Bi(t);
    if (!Sd(n, e))
      return $I(t, n, e);
    const r = n[e];
    return t.finalized_ || !qr(r) ? r : r === tu(t.base_, e) ? (nu(t), t.copy_[e] = Nd(r, t)) : r;
  },
  has(t, e) {
    return e in Bi(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(Bi(t));
  },
  set(t, e, n) {
    const r = jb(Bi(t), e);
    if (r != null && r.set)
      return r.set.call(t.draft_, n), !0;
    if (!t.modified_) {
      const i = tu(Bi(t), e), s = i == null ? void 0 : i[In];
      if (s && s.base_ === n)
        return t.copy_[e] = n, t.assigned_[e] = !1, !0;
      if (DI(n, i) && (n !== void 0 || Sd(t.base_, e)))
        return !0;
      nu(t), kd(t);
    }
    return t.copy_[e] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || e in t.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(t.copy_[e]) || (t.copy_[e] = n, t.assigned_[e] = !0), !0;
  },
  deleteProperty(t, e) {
    return tu(t.base_, e) !== void 0 || e in t.base_ ? (t.assigned_[e] = !1, nu(t), kd(t)) : delete t.assigned_[e], t.copy_ && delete t.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(t, e) {
    const n = Bi(t), r = Reflect.getOwnPropertyDescriptor(n, e);
    return r && {
      writable: !0,
      configurable: t.type_ !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: n[e]
    };
  },
  defineProperty() {
    _n(11);
  },
  getPrototypeOf(t) {
    return zs(t.base_);
  },
  setPrototypeOf() {
    _n(12);
  }
}, Xo = {};
Ic(jf, (t, e) => {
  Xo[t] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
Xo.deleteProperty = function(t, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && _n(13), Xo.set.call(this, t, e, void 0);
};
Xo.set = function(t, e, n) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && _n(14), jf.set.call(this, t[0], e, n, t[0]);
};
function tu(t, e) {
  const n = t[In];
  return (n ? Bi(n) : t)[e];
}
function $I(t, e, n) {
  var i;
  const r = jb(e, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = r.get) == null ? void 0 : i.call(t.draft_)
  ) : void 0;
}
function jb(t, e) {
  if (!(e in t))
    return;
  let n = zs(t);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, e);
    if (r)
      return r;
    n = zs(n);
  }
}
function kd(t) {
  t.modified_ || (t.modified_ = !0, t.parent_ && kd(t.parent_));
}
function nu(t) {
  t.copy_ || (t.copy_ = Ad(
    t.base_,
    t.scope_.immer_.useStrictShallowCopy_
  ));
}
var jI = class {
  constructor(t) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, n, r) => {
      if (typeof e == "function" && typeof n != "function") {
        const s = n;
        n = e;
        const o = this;
        return function(l = s, ...u) {
          return o.produce(l, (d) => n.call(this, d, ...u));
        };
      }
      typeof n != "function" && _n(6), r !== void 0 && typeof r != "function" && _n(7);
      let i;
      if (qr(e)) {
        const s = lm(this), o = Nd(e, void 0);
        let a = !0;
        try {
          i = n(o), a = !1;
        } finally {
          a ? Rd(s) : Cd(s);
        }
        return cm(s, r), um(i, s);
      } else if (!e || typeof e != "object") {
        if (i = n(e), i === void 0 && (i = e), i === Fb && (i = void 0), this.autoFreeze_ && $f(i, !0), r) {
          const s = [], o = [];
          Ji("Patches").generateReplacementPatches_(e, i, s, o), r(s, o);
        }
        return i;
      } else
        _n(1, e);
    }, this.produceWithPatches = (e, n) => {
      if (typeof e == "function")
        return (o, ...a) => this.produceWithPatches(o, (l) => e(l, ...a));
      let r, i;
      return [this.produce(e, n, (o, a) => {
        r = o, i = a;
      }), r, i];
    }, typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze), typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    qr(t) || _n(8), vr(t) && (t = qf(t));
    const e = lm(this), n = Nd(t, void 0);
    return n[In].isManual_ = !0, Cd(e), n;
  }
  finishDraft(t, e) {
    const n = t && t[In];
    (!n || !n.isManual_) && _n(9);
    const { scope_: r } = n;
    return cm(r, e), um(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, e) {
    let n;
    for (n = e.length - 1; n >= 0; n--) {
      const i = e[n];
      if (i.path.length === 0 && i.op === "replace") {
        t = i.value;
        break;
      }
    }
    n > -1 && (e = e.slice(n + 1));
    const r = Ji("Patches").applyPatches_;
    return vr(t) ? r(t, e) : this.produce(
      t,
      (i) => r(i, e)
    );
  }
};
function Nd(t, e) {
  const n = ol(t) ? Ji("MapSet").proxyMap_(t, e) : al(t) ? Ji("MapSet").proxySet_(t, e) : BI(t, e);
  return (e ? e.scope_ : $b()).drafts_.push(n), n;
}
function qf(t) {
  return vr(t) || _n(10, t), qb(t);
}
function qb(t) {
  if (!qr(t) || cl(t))
    return t;
  const e = t[In];
  let n;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, n = Ad(t, e.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Ad(t, !0);
  return Ic(n, (r, i) => {
    Bb(n, r, qb(i));
  }), e && (e.finalized_ = !1), n;
}
var Sn = new jI(), zf = Sn.produce;
Sn.produceWithPatches.bind(
  Sn
);
Sn.setAutoFreeze.bind(Sn);
Sn.setUseStrictShallowCopy.bind(Sn);
Sn.applyPatches.bind(Sn);
Sn.createDraft.bind(Sn);
Sn.finishDraft.bind(Sn);
var qI = (t, e, n) => {
  if (e.length === 1 && e[0] === n) {
    let r = !1;
    try {
      const i = {};
      t(i) === i && (r = !0);
    } catch {
    }
    if (r) {
      let i;
      try {
        throw new Error();
      } catch (s) {
        ({ stack: i } = s);
      }
      console.warn(
        `The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,
        { stack: i }
      );
    }
  }
}, zI = (t, e, n) => {
  const { memoize: r, memoizeOptions: i } = e, { inputSelectorResults: s, inputSelectorResultsCopy: o } = t, a = r(() => ({}), ...i);
  if (!(a.apply(null, s) === a.apply(null, o))) {
    let u;
    try {
      throw new Error();
    } catch (d) {
      ({ stack: u } = d);
    }
    console.warn(
      `An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,
      {
        arguments: n,
        firstInputs: s,
        secondInputs: o,
        stack: u
      }
    );
  }
}, WI = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
function GI(t, e = `expected a function, instead received ${typeof t}`) {
  if (typeof t != "function")
    throw new TypeError(e);
}
function HI(t, e = `expected an object, instead received ${typeof t}`) {
  if (typeof t != "object")
    throw new TypeError(e);
}
function KI(t, e = "expected all items to be functions, instead received the following types: ") {
  if (!t.every((n) => typeof n == "function")) {
    const n = t.map(
      (r) => typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r
    ).join(", ");
    throw new TypeError(`${e}[${n}]`);
  }
}
var fm = (t) => Array.isArray(t) ? t : [t];
function YI(t) {
  const e = Array.isArray(t[0]) ? t[0] : t;
  return KI(
    e,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), e;
}
function hm(t, e) {
  const n = [], { length: r } = t;
  for (let i = 0; i < r; i++)
    n.push(t[i].apply(null, e));
  return n;
}
var XI = (t, e) => {
  const { identityFunctionCheck: n, inputStabilityCheck: r } = {
    ...WI,
    ...e
  };
  return {
    identityFunctionCheck: {
      shouldRun: n === "always" || n === "once" && t,
      run: qI
    },
    inputStabilityCheck: {
      shouldRun: r === "always" || r === "once" && t,
      run: zI
    }
  };
}, QI = class {
  constructor(t) {
    this.value = t;
  }
  deref() {
    return this.value;
  }
}, JI = typeof WeakRef < "u" ? WeakRef : QI, ZI = 0, pm = 1;
function $a() {
  return {
    s: ZI,
    v: void 0,
    o: null,
    p: null
  };
}
function Wf(t, e = {}) {
  let n = $a();
  const { resultEqualityCheck: r } = e;
  let i, s = 0;
  function o() {
    var f;
    let a = n;
    const { length: l } = arguments;
    for (let p = 0, g = l; p < g; p++) {
      const _ = arguments[p];
      if (typeof _ == "function" || typeof _ == "object" && _ !== null) {
        let b = a.o;
        b === null && (a.o = b = /* @__PURE__ */ new WeakMap());
        const m = b.get(_);
        m === void 0 ? (a = $a(), b.set(_, a)) : a = m;
      } else {
        let b = a.p;
        b === null && (a.p = b = /* @__PURE__ */ new Map());
        const m = b.get(_);
        m === void 0 ? (a = $a(), b.set(_, a)) : a = m;
      }
    }
    const u = a;
    let d;
    if (a.s === pm)
      d = a.v;
    else if (d = t.apply(null, arguments), s++, r) {
      const p = ((f = i == null ? void 0 : i.deref) == null ? void 0 : f.call(i)) ?? i;
      p != null && r(p, d) && (d = p, s !== 0 && s--), i = typeof d == "object" && d !== null || typeof d == "function" ? new JI(d) : d;
    }
    return u.s = pm, u.v = d, d;
  }
  return o.clearCache = () => {
    n = $a(), o.resetResultsCount();
  }, o.resultsCount = () => s, o.resetResultsCount = () => {
    s = 0;
  }, o;
}
function zb(t, ...e) {
  const n = typeof t == "function" ? {
    memoize: t,
    memoizeOptions: e
  } : t, r = (...i) => {
    let s = 0, o = 0, a, l = {}, u = i.pop();
    typeof u == "object" && (l = u, u = i.pop()), GI(
      u,
      `createSelector expects an output function after the inputs, but received: [${typeof u}]`
    );
    const d = {
      ...n,
      ...l
    }, {
      memoize: f,
      memoizeOptions: p = [],
      argsMemoize: g = Wf,
      argsMemoizeOptions: _ = [],
      devModeChecks: b = {}
    } = d, m = fm(p), v = fm(_), C = YI(i), x = f(function() {
      return s++, u.apply(
        null,
        arguments
      );
    }, ...m);
    let P = !0;
    const k = g(function() {
      o++;
      const I = hm(
        C,
        arguments
      );
      if (a = x.apply(null, I), process.env.NODE_ENV !== "production") {
        const { identityFunctionCheck: E, inputStabilityCheck: T } = XI(P, b);
        if (E.shouldRun && E.run(
          u,
          I,
          a
        ), T.shouldRun) {
          const A = hm(
            C,
            arguments
          );
          T.run(
            { inputSelectorResults: I, inputSelectorResultsCopy: A },
            { memoize: f, memoizeOptions: m },
            arguments
          );
        }
        P && (P = !1);
      }
      return a;
    }, ...v);
    return Object.assign(k, {
      resultFunc: u,
      memoizedResultFunc: x,
      dependencies: C,
      dependencyRecomputations: () => o,
      resetDependencyRecomputations: () => {
        o = 0;
      },
      lastResult: () => a,
      recomputations: () => s,
      resetRecomputations: () => {
        s = 0;
      },
      memoize: f,
      argsMemoize: g
    });
  };
  return Object.assign(r, {
    withTypes: () => r
  }), r;
}
var e0 = /* @__PURE__ */ zb(Wf), t0 = Object.assign(
  (t, e = e0) => {
    HI(
      t,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof t}`
    );
    const n = Object.keys(t), r = n.map(
      (s) => t[s]
    );
    return e(
      r,
      (...s) => s.reduce((o, a, l) => (o[n[l]] = a, o), {})
    );
  },
  { withTypes: () => t0 }
);
function Wb(t) {
  return ({ dispatch: n, getState: r }) => (i) => (s) => typeof s == "function" ? s(n, r, t) : i(s);
}
var n0 = Wb(), r0 = Wb, i0 = (...t) => {
  const e = zb(...t), n = Object.assign((...r) => {
    const i = e(...r), s = (o, ...a) => i(vr(o) ? qf(o) : o, ...a);
    return Object.assign(s, i), s;
  }, {
    withTypes: () => n
  });
  return n;
}, s0 = /* @__PURE__ */ i0(Wf), o0 = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length !== 0)
    return typeof arguments[0] == "object" ? Tc : Tc.apply(null, arguments);
}, a0 = (t) => t && typeof t.match == "function";
function mm(t, e) {
  function n(...r) {
    if (e) {
      let i = e(...r);
      if (!i)
        throw new Error(process.env.NODE_ENV === "production" ? pt(0) : "prepareAction did not return an object");
      return {
        type: t,
        payload: i.payload,
        ..."meta" in i && {
          meta: i.meta
        },
        ..."error" in i && {
          error: i.error
        }
      };
    }
    return {
      type: t,
      payload: r[0]
    };
  }
  return n.toString = () => `${t}`, n.type = t, n.match = (r) => Bf(r) && r.type === t, n;
}
function c0(t) {
  return typeof t == "function" && "type" in t && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  a0(t);
}
function l0(t) {
  return Bf(t) && Object.keys(t).every(u0);
}
function u0(t) {
  return ["type", "payload", "error", "meta"].indexOf(t) > -1;
}
function d0(t) {
  const e = t ? `${t}`.split("/") : [], n = e[e.length - 1] || "actionCreator";
  return `Detected an action creator with type "${t || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${n}())\` instead of \`dispatch(${n})\`. This is necessary even if the action has no payload.`;
}
function f0(t = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (n) => (r) => n(r);
  const {
    isActionCreator: e = c0
  } = t;
  return () => (n) => (r) => (e(r) && console.warn(d0(r.type)), n(r));
}
function Gb(t, e) {
  let n = 0;
  return {
    measureTime(r) {
      const i = Date.now();
      try {
        return r();
      } finally {
        const s = Date.now();
        n += s - i;
      }
    },
    warnIfExceeded() {
      n > t && console.warn(`${e} took ${n}ms, which is more than the warning threshold of ${t}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
    }
  };
}
var Hb = class ko extends Array {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, ko.prototype);
  }
  static get [Symbol.species]() {
    return ko;
  }
  concat(...e) {
    return super.concat.apply(this, e);
  }
  prepend(...e) {
    return e.length === 1 && Array.isArray(e[0]) ? new ko(...e[0].concat(this)) : new ko(...e.concat(this));
  }
};
function gm(t) {
  return qr(t) ? zf(t, () => {
  }) : t;
}
function ja(t, e, n) {
  return t.has(e) ? t.get(e) : t.set(e, n(e)).get(e);
}
function h0(t) {
  return typeof t != "object" || t == null || Object.isFrozen(t);
}
function p0(t, e, n) {
  const r = Kb(t, e, n);
  return {
    detectMutations() {
      return Yb(t, e, r, n);
    }
  };
}
function Kb(t, e = [], n, r = "", i = /* @__PURE__ */ new Set()) {
  const s = {
    value: n
  };
  if (!t(n) && !i.has(n)) {
    i.add(n), s.children = {};
    for (const o in n) {
      const a = r ? r + "." + o : o;
      e.length && e.indexOf(a) !== -1 || (s.children[o] = Kb(t, e, n[o], a));
    }
  }
  return s;
}
function Yb(t, e = [], n, r, i = !1, s = "") {
  const o = n ? n.value : void 0, a = o === r;
  if (i && !a && !Number.isNaN(r))
    return {
      wasMutated: !0,
      path: s
    };
  if (t(o) || t(r))
    return {
      wasMutated: !1
    };
  const l = {};
  for (let d in n.children)
    l[d] = !0;
  for (let d in r)
    l[d] = !0;
  const u = e.length > 0;
  for (let d in l) {
    const f = s ? s + "." + d : d;
    if (u && e.some((_) => _ instanceof RegExp ? _.test(f) : f === _))
      continue;
    const p = Yb(t, e, n.children[d], r[d], a, f);
    if (p.wasMutated)
      return p;
  }
  return {
    wasMutated: !1
  };
}
function m0(t = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (e) => (n) => e(n);
  {
    let e = function(a, l, u, d) {
      return JSON.stringify(a, n(l, d), u);
    }, n = function(a, l) {
      let u = [], d = [];
      return l || (l = function(f, p) {
        return u[0] === p ? "[Circular ~]" : "[Circular ~." + d.slice(0, u.indexOf(p)).join(".") + "]";
      }), function(f, p) {
        if (u.length > 0) {
          var g = u.indexOf(this);
          ~g ? u.splice(g + 1) : u.push(this), ~g ? d.splice(g, 1 / 0, f) : d.push(f), ~u.indexOf(p) && (p = l.call(this, f, p));
        } else u.push(p);
        return a == null ? p : a.call(this, f, p);
      };
    }, {
      isImmutable: r = h0,
      ignoredPaths: i,
      warnAfter: s = 32
    } = t;
    const o = p0.bind(null, r, i);
    return ({
      getState: a
    }) => {
      let l = a(), u = o(l), d;
      return (f) => (p) => {
        const g = Gb(s, "ImmutableStateInvariantMiddleware");
        g.measureTime(() => {
          if (l = a(), d = u.detectMutations(), u = o(l), d.wasMutated)
            throw new Error(process.env.NODE_ENV === "production" ? pt(19) : `A state mutation was detected between dispatches, in the path '${d.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
        });
        const _ = f(p);
        return g.measureTime(() => {
          if (l = a(), d = u.detectMutations(), u = o(l), d.wasMutated)
            throw new Error(process.env.NODE_ENV === "production" ? pt(20) : `A state mutation was detected inside a dispatch, in the path: ${d.path || ""}. Take a look at the reducer(s) handling the action ${e(p)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
        }), g.warnIfExceeded(), _;
      };
    };
  }
}
function Xb(t) {
  const e = typeof t;
  return t == null || e === "string" || e === "boolean" || e === "number" || Array.isArray(t) || da(t);
}
function Od(t, e = "", n = Xb, r, i = [], s) {
  let o;
  if (!n(t))
    return {
      keyPath: e || "<root>",
      value: t
    };
  if (typeof t != "object" || t === null || s != null && s.has(t)) return !1;
  const a = r != null ? r(t) : Object.entries(t), l = i.length > 0;
  for (const [u, d] of a) {
    const f = e ? e + "." + u : u;
    if (!(l && i.some((g) => g instanceof RegExp ? g.test(f) : f === g))) {
      if (!n(d))
        return {
          keyPath: f,
          value: d
        };
      if (typeof d == "object" && (o = Od(d, f, n, r, i, s), o))
        return o;
    }
  }
  return s && Qb(t) && s.add(t), !1;
}
function Qb(t) {
  if (!Object.isFrozen(t)) return !1;
  for (const e of Object.values(t))
    if (!(typeof e != "object" || e === null) && !Qb(e))
      return !1;
  return !0;
}
function g0(t = {}) {
  if (process.env.NODE_ENV === "production")
    return () => (e) => (n) => e(n);
  {
    const {
      isSerializable: e = Xb,
      getEntries: n,
      ignoredActions: r = [],
      ignoredActionPaths: i = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths: s = [],
      warnAfter: o = 32,
      ignoreState: a = !1,
      ignoreActions: l = !1,
      disableCache: u = !1
    } = t, d = !u && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (f) => (p) => (g) => {
      if (!Bf(g))
        return p(g);
      const _ = p(g), b = Gb(o, "SerializableStateInvariantMiddleware");
      return !l && !(r.length && r.indexOf(g.type) !== -1) && b.measureTime(() => {
        const m = Od(g, "", e, n, i, d);
        if (m) {
          const {
            keyPath: v,
            value: C
          } = m;
          console.error(`A non-serializable value was detected in an action, in the path: \`${v}\`. Value:`, C, `
Take a look at the logic that dispatched this action: `, g, `
(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)`, `
(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)`);
        }
      }), a || (b.measureTime(() => {
        const m = f.getState(), v = Od(m, "", e, n, s, d);
        if (v) {
          const {
            keyPath: C,
            value: x
          } = v;
          console.error(`A non-serializable value was detected in the state, in the path: \`${C}\`. Value:`, x, `
Take a look at the reducer(s) handling this action type: ${g.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
        }
      }), b.warnIfExceeded()), _;
    };
  }
}
function qa(t) {
  return typeof t == "boolean";
}
var y0 = () => function(e) {
  const {
    thunk: n = !0,
    immutableCheck: r = !0,
    serializableCheck: i = !0,
    actionCreatorCheck: s = !0
  } = e ?? {};
  let o = new Hb();
  if (n && (qa(n) ? o.push(n0) : o.push(r0(n.extraArgument))), process.env.NODE_ENV !== "production") {
    if (r) {
      let a = {};
      qa(r) || (a = r), o.unshift(m0(a));
    }
    if (i) {
      let a = {};
      qa(i) || (a = i), o.push(g0(a));
    }
    if (s) {
      let a = {};
      qa(s) || (a = s), o.unshift(f0(a));
    }
  }
  return o;
}, _0 = "RTK_autoBatch", ym = (t) => (e) => {
  setTimeout(e, t);
}, b0 = (t = {
  type: "raf"
}) => (e) => (...n) => {
  const r = e(...n);
  let i = !0, s = !1, o = !1;
  const a = /* @__PURE__ */ new Set(), l = t.type === "tick" ? queueMicrotask : t.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame : ym(10)
  ) : t.type === "callback" ? t.queueNotification : ym(t.timeout), u = () => {
    o = !1, s && (s = !1, a.forEach((d) => d()));
  };
  return Object.assign({}, r, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(d) {
      const f = () => i && d(), p = r.subscribe(f);
      return a.add(d), () => {
        p(), a.delete(d);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(d) {
      var f;
      try {
        return i = !((f = d == null ? void 0 : d.meta) != null && f[_0]), s = !i, s && (o || (o = !0, l(u))), r.dispatch(d);
      } finally {
        i = !0;
      }
    }
  });
}, v0 = (t) => function(n) {
  const {
    autoBatch: r = !0
  } = n ?? {};
  let i = new Hb(t);
  return r && i.push(b0(typeof r == "object" ? r : void 0)), i;
};
function E0(t) {
  const e = y0(), {
    reducer: n = void 0,
    middleware: r,
    devTools: i = !0,
    duplicateMiddlewareCheck: s = !0,
    preloadedState: o = void 0,
    enhancers: a = void 0
  } = t || {};
  let l;
  if (typeof n == "function")
    l = n;
  else if (da(n))
    l = OI(n);
  else
    throw new Error(process.env.NODE_ENV === "production" ? pt(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  if (process.env.NODE_ENV !== "production" && r && typeof r != "function")
    throw new Error(process.env.NODE_ENV === "production" ? pt(2) : "`middleware` field must be a callback");
  let u;
  if (typeof r == "function") {
    if (u = r(e), process.env.NODE_ENV !== "production" && !Array.isArray(u))
      throw new Error(process.env.NODE_ENV === "production" ? pt(3) : "when using a middleware builder function, an array of middleware must be returned");
  } else
    u = e();
  if (process.env.NODE_ENV !== "production" && u.some((b) => typeof b != "function"))
    throw new Error(process.env.NODE_ENV === "production" ? pt(4) : "each middleware provided to configureStore must be a function");
  if (process.env.NODE_ENV !== "production" && s) {
    let b = /* @__PURE__ */ new Set();
    u.forEach((m) => {
      if (b.has(m))
        throw new Error(process.env.NODE_ENV === "production" ? pt(42) : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
      b.add(m);
    });
  }
  let d = Tc;
  i && (d = o0({
    // Enable capture of stack traces for dispatched Redux actions
    trace: process.env.NODE_ENV !== "production",
    ...typeof i == "object" && i
  }));
  const f = PI(...u), p = v0(f);
  if (process.env.NODE_ENV !== "production" && a && typeof a != "function")
    throw new Error(process.env.NODE_ENV === "production" ? pt(5) : "`enhancers` field must be a callback");
  let g = typeof a == "function" ? a(p) : p();
  if (process.env.NODE_ENV !== "production" && !Array.isArray(g))
    throw new Error(process.env.NODE_ENV === "production" ? pt(6) : "`enhancers` callback must return an array");
  if (process.env.NODE_ENV !== "production" && g.some((b) => typeof b != "function"))
    throw new Error(process.env.NODE_ENV === "production" ? pt(7) : "each enhancer provided to configureStore must be a function");
  process.env.NODE_ENV !== "production" && u.length && !g.includes(f) && console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  const _ = d(...g);
  return Ub(l, o, _);
}
function Jb(t) {
  const e = {}, n = [];
  let r;
  const i = {
    addCase(s, o) {
      if (process.env.NODE_ENV !== "production") {
        if (n.length > 0)
          throw new Error(process.env.NODE_ENV === "production" ? pt(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        if (r)
          throw new Error(process.env.NODE_ENV === "production" ? pt(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
      }
      const a = typeof s == "string" ? s : s.type;
      if (!a)
        throw new Error(process.env.NODE_ENV === "production" ? pt(28) : "`builder.addCase` cannot be called with an empty action type");
      if (a in e)
        throw new Error(process.env.NODE_ENV === "production" ? pt(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${a}'`);
      return e[a] = o, i;
    },
    addMatcher(s, o) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? pt(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
      return n.push({
        matcher: s,
        reducer: o
      }), i;
    },
    addDefaultCase(s) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? pt(31) : "`builder.addDefaultCase` can only be called once");
      return r = s, i;
    }
  };
  return t(i), [e, n, r];
}
function w0(t) {
  return typeof t == "function";
}
function T0(t, e) {
  if (process.env.NODE_ENV !== "production" && typeof e == "object")
    throw new Error(process.env.NODE_ENV === "production" ? pt(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
  let [n, r, i] = Jb(e), s;
  if (w0(t))
    s = () => gm(t());
  else {
    const a = gm(t);
    s = () => a;
  }
  function o(a = s(), l) {
    let u = [n[l.type], ...r.filter(({
      matcher: d
    }) => d(l)).map(({
      reducer: d
    }) => d)];
    return u.filter((d) => !!d).length === 0 && (u = [i]), u.reduce((d, f) => {
      if (f)
        if (vr(d)) {
          const g = f(d, l);
          return g === void 0 ? d : g;
        } else {
          if (qr(d))
            return zf(d, (p) => f(p, l));
          {
            const p = f(d, l);
            if (p === void 0) {
              if (d === null)
                return d;
              throw Error("A case reducer on a non-draftable value must not return undefined");
            }
            return p;
          }
        }
      return d;
    }, a);
  }
  return o.getInitialState = s, o;
}
var I0 = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", $t = (t = 21) => {
  let e = "", n = t;
  for (; n--; )
    e += I0[Math.random() * 64 | 0];
  return e;
}, S0 = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function A0(t, e) {
  return `${t}/${e}`;
}
function R0({
  creators: t
} = {}) {
  var n;
  const e = (n = t == null ? void 0 : t.asyncThunk) == null ? void 0 : n[S0];
  return function(i) {
    const {
      name: s,
      reducerPath: o = s
    } = i;
    if (!s)
      throw new Error(process.env.NODE_ENV === "production" ? pt(11) : "`name` is a required option for createSlice");
    typeof process < "u" && process.env.NODE_ENV === "development" && i.initialState === void 0 && console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    const a = (typeof i.reducers == "function" ? i.reducers(k0()) : i.reducers) || {}, l = Object.keys(a), u = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    }, d = {
      addCase(P, k) {
        const U = typeof P == "string" ? P : P.type;
        if (!U)
          throw new Error(process.env.NODE_ENV === "production" ? pt(12) : "`context.addCase` cannot be called with an empty action type");
        if (U in u.sliceCaseReducersByType)
          throw new Error(process.env.NODE_ENV === "production" ? pt(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + U);
        return u.sliceCaseReducersByType[U] = k, d;
      },
      addMatcher(P, k) {
        return u.sliceMatchers.push({
          matcher: P,
          reducer: k
        }), d;
      },
      exposeAction(P, k) {
        return u.actionCreators[P] = k, d;
      },
      exposeCaseReducer(P, k) {
        return u.sliceCaseReducersByName[P] = k, d;
      }
    };
    l.forEach((P) => {
      const k = a[P], U = {
        reducerName: P,
        type: A0(s, P),
        createNotation: typeof i.reducers == "function"
      };
      O0(k) ? x0(U, k, d, e) : N0(U, k, d);
    });
    function f() {
      if (process.env.NODE_ENV !== "production" && typeof i.extraReducers == "object")
        throw new Error(process.env.NODE_ENV === "production" ? pt(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
      const [P = {}, k = [], U = void 0] = typeof i.extraReducers == "function" ? Jb(i.extraReducers) : [i.extraReducers], I = {
        ...P,
        ...u.sliceCaseReducersByType
      };
      return T0(i.initialState, (E) => {
        for (let T in I)
          E.addCase(T, I[T]);
        for (let T of u.sliceMatchers)
          E.addMatcher(T.matcher, T.reducer);
        for (let T of k)
          E.addMatcher(T.matcher, T.reducer);
        U && E.addDefaultCase(U);
      });
    }
    const p = (P) => P, g = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new WeakMap();
    let b;
    function m(P, k) {
      return b || (b = f()), b(P, k);
    }
    function v() {
      return b || (b = f()), b.getInitialState();
    }
    function C(P, k = !1) {
      function U(E) {
        let T = E[P];
        if (typeof T > "u") {
          if (k)
            T = ja(_, U, v);
          else if (process.env.NODE_ENV !== "production")
            throw new Error(process.env.NODE_ENV === "production" ? pt(15) : "selectSlice returned undefined for an uninjected slice reducer");
        }
        return T;
      }
      function I(E = p) {
        const T = ja(g, k, () => /* @__PURE__ */ new WeakMap());
        return ja(T, E, () => {
          const A = {};
          for (const [R, M] of Object.entries(i.selectors ?? {}))
            A[R] = C0(M, E, () => ja(_, E, v), k);
          return A;
        });
      }
      return {
        reducerPath: P,
        getSelectors: I,
        get selectors() {
          return I(U);
        },
        selectSlice: U
      };
    }
    const x = {
      name: s,
      reducer: m,
      actions: u.actionCreators,
      caseReducers: u.sliceCaseReducersByName,
      getInitialState: v,
      ...C(o),
      injectInto(P, {
        reducerPath: k,
        ...U
      } = {}) {
        const I = k ?? o;
        return P.inject({
          reducerPath: I,
          reducer: m
        }, U), {
          ...x,
          ...C(I, !0)
        };
      }
    };
    return x;
  };
}
function C0(t, e, n, r) {
  function i(s, ...o) {
    let a = e(s);
    if (typeof a > "u") {
      if (r)
        a = n();
      else if (process.env.NODE_ENV !== "production")
        throw new Error(process.env.NODE_ENV === "production" ? pt(16) : "selectState returned undefined for an uninjected slice reducer");
    }
    return t(a, ...o);
  }
  return i.unwrapped = t, i;
}
var ll = /* @__PURE__ */ R0();
function k0() {
  function t(e, n) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator: e,
      ...n
    };
  }
  return t.withTypes = () => t, {
    reducer(e) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [e.name](...n) {
          return e(...n);
        }
      }[e.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(e, n) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare: e,
        reducer: n
      };
    },
    asyncThunk: t
  };
}
function N0({
  type: t,
  reducerName: e,
  createNotation: n
}, r, i) {
  let s, o;
  if ("reducer" in r) {
    if (n && !P0(r))
      throw new Error(process.env.NODE_ENV === "production" ? pt(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    s = r.reducer, o = r.prepare;
  } else
    s = r;
  i.addCase(t, s).exposeCaseReducer(e, s).exposeAction(e, o ? mm(t, o) : mm(t));
}
function O0(t) {
  return t._reducerDefinitionType === "asyncThunk";
}
function P0(t) {
  return t._reducerDefinitionType === "reducerWithPrepare";
}
function x0({
  type: t,
  reducerName: e
}, n, r, i) {
  if (!i)
    throw new Error(process.env.NODE_ENV === "production" ? pt(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  const {
    payloadCreator: s,
    fulfilled: o,
    pending: a,
    rejected: l,
    settled: u,
    options: d
  } = n, f = i(t, s, d);
  r.exposeAction(e, f), o && r.addCase(f.fulfilled, o), a && r.addCase(f.pending, a), l && r.addCase(f.rejected, l), u && r.addMatcher(f.settled, u), r.exposeCaseReducer(e, {
    fulfilled: o || za,
    pending: a || za,
    rejected: l || za,
    settled: u || za
  });
}
function za() {
}
function M0() {
  return {
    ids: [],
    entities: {}
  };
}
function D0(t) {
  function e(n = {}, r) {
    const i = Object.assign(M0(), n);
    return r ? t.setAll(i, r) : i;
  }
  return {
    getInitialState: e
  };
}
function L0() {
  function t(e, n = {}) {
    const {
      createSelector: r = s0
    } = n, i = (f) => f.ids, s = (f) => f.entities, o = r(i, s, (f, p) => f.map((g) => p[g])), a = (f, p) => p, l = (f, p) => f[p], u = r(i, (f) => f.length);
    if (!e)
      return {
        selectIds: i,
        selectEntities: s,
        selectAll: o,
        selectTotal: u,
        selectById: r(s, a, l)
      };
    const d = r(e, s);
    return {
      selectIds: r(e, i),
      selectEntities: d,
      selectAll: r(e, o),
      selectTotal: r(e, u),
      selectById: r(d, a, l)
    };
  }
  return {
    getSelectors: t
  };
}
var U0 = vr;
function F0(t) {
  const e = Ot((n, r) => t(r));
  return function(r) {
    return e(r, void 0);
  };
}
function Ot(t) {
  return function(n, r) {
    function i(o) {
      return l0(o);
    }
    const s = (o) => {
      i(r) ? t(r.payload, o) : t(r, o);
    };
    return U0(n) ? (s(n), n) : zf(n, s);
  };
}
function As(t, e) {
  const n = e(t);
  return process.env.NODE_ENV !== "production" && n === void 0 && console.warn("The entity passed to the `selectId` implementation returned undefined.", "You should probably provide your own `selectId` implementation.", "The entity that was passed:", t, "The `selectId` implementation:", e.toString()), n;
}
function Ki(t) {
  return Array.isArray(t) || (t = Object.values(t)), t;
}
function cc(t) {
  return vr(t) ? qf(t) : t;
}
function Zb(t, e, n) {
  t = Ki(t);
  const r = cc(n.ids), i = new Set(r), s = [], o = /* @__PURE__ */ new Set([]), a = [];
  for (const l of t) {
    const u = As(l, e);
    i.has(u) || o.has(u) ? a.push({
      id: u,
      changes: l
    }) : (o.add(u), s.push(l));
  }
  return [s, a, r];
}
function ev(t) {
  function e(_, b) {
    const m = As(_, t);
    m in b.entities || (b.ids.push(m), b.entities[m] = _);
  }
  function n(_, b) {
    _ = Ki(_);
    for (const m of _)
      e(m, b);
  }
  function r(_, b) {
    const m = As(_, t);
    m in b.entities || b.ids.push(m), b.entities[m] = _;
  }
  function i(_, b) {
    _ = Ki(_);
    for (const m of _)
      r(m, b);
  }
  function s(_, b) {
    _ = Ki(_), b.ids = [], b.entities = {}, n(_, b);
  }
  function o(_, b) {
    return a([_], b);
  }
  function a(_, b) {
    let m = !1;
    _.forEach((v) => {
      v in b.entities && (delete b.entities[v], m = !0);
    }), m && (b.ids = b.ids.filter((v) => v in b.entities));
  }
  function l(_) {
    Object.assign(_, {
      ids: [],
      entities: {}
    });
  }
  function u(_, b, m) {
    const v = m.entities[b.id];
    if (v === void 0)
      return !1;
    const C = Object.assign({}, v, b.changes), x = As(C, t), P = x !== b.id;
    return P && (_[b.id] = x, delete m.entities[b.id]), m.entities[x] = C, P;
  }
  function d(_, b) {
    return f([_], b);
  }
  function f(_, b) {
    const m = {}, v = {};
    _.forEach((x) => {
      var P;
      x.id in b.entities && (v[x.id] = {
        id: x.id,
        // Spreads ignore falsy values, so this works even if there isn't
        // an existing update already at this key
        changes: {
          ...(P = v[x.id]) == null ? void 0 : P.changes,
          ...x.changes
        }
      });
    }), _ = Object.values(v), _.length > 0 && _.filter((P) => u(m, P, b)).length > 0 && (b.ids = Object.values(b.entities).map((P) => As(P, t)));
  }
  function p(_, b) {
    return g([_], b);
  }
  function g(_, b) {
    const [m, v] = Zb(_, t, b);
    n(m, b), f(v, b);
  }
  return {
    removeAll: F0(l),
    addOne: Ot(e),
    addMany: Ot(n),
    setOne: Ot(r),
    setMany: Ot(i),
    setAll: Ot(s),
    updateOne: Ot(d),
    updateMany: Ot(f),
    upsertOne: Ot(p),
    upsertMany: Ot(g),
    removeOne: Ot(o),
    removeMany: Ot(a)
  };
}
function V0(t, e, n) {
  let r = 0, i = t.length;
  for (; r < i; ) {
    let s = r + i >>> 1;
    const o = t[s];
    n(e, o) >= 0 ? r = s + 1 : i = s;
  }
  return r;
}
function B0(t, e, n) {
  const r = V0(t, e, n);
  return t.splice(r, 0, e), t;
}
function $0(t, e) {
  const {
    removeOne: n,
    removeMany: r,
    removeAll: i
  } = ev(t);
  function s(m, v) {
    return o([m], v);
  }
  function o(m, v, C) {
    m = Ki(m);
    const x = new Set(C ?? cc(v.ids)), P = m.filter((k) => !x.has(As(k, t)));
    P.length !== 0 && b(v, P);
  }
  function a(m, v) {
    return l([m], v);
  }
  function l(m, v) {
    if (m = Ki(m), m.length !== 0) {
      for (const C of m)
        delete v.entities[t(C)];
      b(v, m);
    }
  }
  function u(m, v) {
    m = Ki(m), v.entities = {}, v.ids = [], o(m, v, []);
  }
  function d(m, v) {
    return f([m], v);
  }
  function f(m, v) {
    let C = !1, x = !1;
    for (let P of m) {
      const k = v.entities[P.id];
      if (!k)
        continue;
      C = !0, Object.assign(k, P.changes);
      const U = t(k);
      if (P.id !== U) {
        x = !0, delete v.entities[P.id];
        const I = v.ids.indexOf(P.id);
        v.ids[I] = U, v.entities[U] = k;
      }
    }
    C && b(v, [], C, x);
  }
  function p(m, v) {
    return g([m], v);
  }
  function g(m, v) {
    const [C, x, P] = Zb(m, t, v);
    C.length && o(C, v, P), x.length && f(x, v);
  }
  function _(m, v) {
    if (m.length !== v.length)
      return !1;
    for (let C = 0; C < m.length; C++)
      if (m[C] !== v[C])
        return !1;
    return !0;
  }
  const b = (m, v, C, x) => {
    const P = cc(m.entities), k = cc(m.ids), U = m.entities;
    let I = k;
    x && (I = new Set(k));
    let E = [];
    for (const R of I) {
      const M = P[R];
      M && E.push(M);
    }
    const T = E.length === 0;
    for (const R of v)
      U[t(R)] = R, T || B0(E, R, e);
    T ? E = v.slice().sort(e) : C && E.sort(e);
    const A = E.map(t);
    _(k, A) || (m.ids = A);
  };
  return {
    removeOne: n,
    removeMany: r,
    removeAll: i,
    addOne: Ot(s),
    updateOne: Ot(d),
    upsertOne: Ot(p),
    setOne: Ot(a),
    setMany: Ot(l),
    setAll: Ot(u),
    addMany: Ot(o),
    updateMany: Ot(f),
    upsertMany: Ot(g)
  };
}
function j0(t = {}) {
  const {
    selectId: e,
    sortComparer: n
  } = {
    sortComparer: !1,
    selectId: (o) => o.id,
    ...t
  }, r = n ? $0(e, n) : ev(e), i = D0(r), s = L0();
  return {
    selectId: e,
    sortComparer: n,
    ...i,
    ...s,
    ...r
  };
}
function pt(t) {
  return `Minified Redux Toolkit error #${t}; visit https://redux-toolkit.js.org/Errors?code=${t} for the full message or use the non-minified dev environment for full errors. `;
}
var Wa = { exports: {} }, ru = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _m;
function q0() {
  if (_m) return ru;
  _m = 1;
  var t = Me;
  function e(f, p) {
    return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, i = t.useEffect, s = t.useLayoutEffect, o = t.useDebugValue;
  function a(f, p) {
    var g = p(), _ = r({ inst: { value: g, getSnapshot: p } }), b = _[0].inst, m = _[1];
    return s(
      function() {
        b.value = g, b.getSnapshot = p, l(b) && m({ inst: b });
      },
      [f, g, p]
    ), i(
      function() {
        return l(b) && m({ inst: b }), f(function() {
          l(b) && m({ inst: b });
        });
      },
      [f]
    ), o(g), g;
  }
  function l(f) {
    var p = f.getSnapshot;
    f = f.value;
    try {
      var g = p();
      return !n(f, g);
    } catch {
      return !0;
    }
  }
  function u(f, p) {
    return p();
  }
  var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : a;
  return ru.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : d, ru;
}
var iu = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bm;
function z0() {
  return bm || (bm = 1, process.env.NODE_ENV !== "production" && function() {
    function t(g, _) {
      return g === _ && (g !== 0 || 1 / g === 1 / _) || g !== g && _ !== _;
    }
    function e(g, _) {
      d || i.startTransition === void 0 || (d = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var b = _();
      if (!f) {
        var m = _();
        s(b, m) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), f = !0);
      }
      m = o({
        inst: { value: b, getSnapshot: _ }
      });
      var v = m[0].inst, C = m[1];
      return l(
        function() {
          v.value = b, v.getSnapshot = _, n(v) && C({ inst: v });
        },
        [g, b, _]
      ), a(
        function() {
          return n(v) && C({ inst: v }), g(function() {
            n(v) && C({ inst: v });
          });
        },
        [g]
      ), u(b), b;
    }
    function n(g) {
      var _ = g.getSnapshot;
      g = g.value;
      try {
        var b = _();
        return !s(g, b);
      } catch {
        return !0;
      }
    }
    function r(g, _) {
      return _();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var i = Me, s = typeof Object.is == "function" ? Object.is : t, o = i.useState, a = i.useEffect, l = i.useLayoutEffect, u = i.useDebugValue, d = !1, f = !1, p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : e;
    iu.useSyncExternalStore = i.useSyncExternalStore !== void 0 ? i.useSyncExternalStore : p, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), iu;
}
var vm;
function Gf() {
  return vm || (vm = 1, process.env.NODE_ENV === "production" ? Wa.exports = q0() : Wa.exports = z0()), Wa.exports;
}
Gf();
var Ga = { exports: {} }, su = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Em;
function W0() {
  if (Em) return su;
  Em = 1;
  var t = Me, e = Gf();
  function n(u, d) {
    return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = e.useSyncExternalStore, s = t.useRef, o = t.useEffect, a = t.useMemo, l = t.useDebugValue;
  return su.useSyncExternalStoreWithSelector = function(u, d, f, p, g) {
    var _ = s(null);
    if (_.current === null) {
      var b = { hasValue: !1, value: null };
      _.current = b;
    } else b = _.current;
    _ = a(
      function() {
        function v(U) {
          if (!C) {
            if (C = !0, x = U, U = p(U), g !== void 0 && b.hasValue) {
              var I = b.value;
              if (g(I, U))
                return P = I;
            }
            return P = U;
          }
          if (I = P, r(x, U)) return I;
          var E = p(U);
          return g !== void 0 && g(I, E) ? (x = U, I) : (x = U, P = E);
        }
        var C = !1, x, P, k = f === void 0 ? null : f;
        return [
          function() {
            return v(d());
          },
          k === null ? void 0 : function() {
            return v(k());
          }
        ];
      },
      [d, f, p, g]
    );
    var m = i(u, _[0], _[1]);
    return o(
      function() {
        b.hasValue = !0, b.value = m;
      },
      [m]
    ), l(m), m;
  }, su;
}
var ou = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wm;
function G0() {
  return wm || (wm = 1, process.env.NODE_ENV !== "production" && function() {
    function t(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var e = Me, n = Gf(), r = typeof Object.is == "function" ? Object.is : t, i = n.useSyncExternalStore, s = e.useRef, o = e.useEffect, a = e.useMemo, l = e.useDebugValue;
    ou.useSyncExternalStoreWithSelector = function(u, d, f, p, g) {
      var _ = s(null);
      if (_.current === null) {
        var b = { hasValue: !1, value: null };
        _.current = b;
      } else b = _.current;
      _ = a(
        function() {
          function v(U) {
            if (!C) {
              if (C = !0, x = U, U = p(U), g !== void 0 && b.hasValue) {
                var I = b.value;
                if (g(I, U))
                  return P = I;
              }
              return P = U;
            }
            if (I = P, r(x, U))
              return I;
            var E = p(U);
            return g !== void 0 && g(I, E) ? (x = U, I) : (x = U, P = E);
          }
          var C = !1, x, P, k = f === void 0 ? null : f;
          return [
            function() {
              return v(d());
            },
            k === null ? void 0 : function() {
              return v(k());
            }
          ];
        },
        [d, f, p, g]
      );
      var m = i(u, _[0], _[1]);
      return o(
        function() {
          b.hasValue = !0, b.value = m;
        },
        [m]
      ), l(m), m;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), ou;
}
var Tm;
function H0() {
  return Tm || (Tm = 1, process.env.NODE_ENV === "production" ? Ga.exports = W0() : Ga.exports = G0()), Ga.exports;
}
var K0 = H0();
function Y0(t) {
  t();
}
let tv = Y0;
const X0 = (t) => tv = t, Q0 = () => tv, Im = Symbol.for("react-redux-context"), Sm = typeof globalThis < "u" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function J0() {
  var t;
  if (!Fr.createContext) return {};
  const e = (t = Sm[Im]) != null ? t : Sm[Im] = /* @__PURE__ */ new Map();
  let n = e.get(Fr.createContext);
  return n || (n = Fr.createContext(null), process.env.NODE_ENV !== "production" && (n.displayName = "ReactRedux"), e.set(Fr.createContext, n)), n;
}
const Rc = /* @__PURE__ */ J0();
function nv(t = Rc) {
  return function() {
    const n = cI(t);
    if (process.env.NODE_ENV !== "production" && !n)
      throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");
    return n;
  };
}
const Z0 = /* @__PURE__ */ nv(), eS = () => {
  throw new Error("uSES not initialized!");
};
let rv = eS;
const tS = (t) => {
  rv = t;
}, nS = (t, e) => t === e;
function rS(t = Rc) {
  const e = t === Rc ? Z0 : nv(t);
  return function(r, i = {}) {
    const {
      equalityFn: s = nS,
      stabilityCheck: o = void 0,
      noopCheck: a = void 0
    } = typeof i == "function" ? {
      equalityFn: i
    } : i;
    if (process.env.NODE_ENV !== "production") {
      if (!r)
        throw new Error("You must pass a selector to useSelector");
      if (typeof r != "function")
        throw new Error("You must pass a function as a selector to useSelector");
      if (typeof s != "function")
        throw new Error("You must pass a function as an equality function to useSelector");
    }
    const {
      store: l,
      subscription: u,
      getServerState: d,
      stabilityCheck: f,
      noopCheck: p
    } = e(), g = lI(!0), _ = Bo({
      [r.name](m) {
        const v = r(m);
        if (process.env.NODE_ENV !== "production") {
          const C = typeof o > "u" ? f : o;
          if (C === "always" || C === "once" && g.current) {
            const P = r(m);
            if (!s(v, P)) {
              let k;
              try {
                throw new Error();
              } catch (U) {
                ({
                  stack: k
                } = U);
              }
              console.warn("Selector " + (r.name || "unknown") + ` returned a different result when called with the same parameters. This can lead to unnecessary rerenders.
Selectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization`, {
                state: m,
                selected: v,
                selected2: P,
                stack: k
              });
            }
          }
          const x = typeof a > "u" ? p : a;
          if ((x === "always" || x === "once" && g.current) && v === m) {
            let P;
            try {
              throw new Error();
            } catch (k) {
              ({
                stack: P
              } = k);
            }
            console.warn("Selector " + (r.name || "unknown") + ` returned the root state when called. This can lead to unnecessary rerenders.
Selectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.`, {
              stack: P
            });
          }
          g.current && (g.current = !1);
        }
        return v;
      }
    }[r.name], [r, f, o]), b = rv(u.addNestedSub, l.getState, d || l.getState, _, s);
    return uI(b), b;
  };
}
const At = /* @__PURE__ */ rS();
var Ha = { exports: {} }, Ze = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Am;
function iS() {
  if (Am) return Ze;
  Am = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, i = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, o = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, l = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, d = t ? Symbol.for("react.forward_ref") : 60112, f = t ? Symbol.for("react.suspense") : 60113, p = t ? Symbol.for("react.suspense_list") : 60120, g = t ? Symbol.for("react.memo") : 60115, _ = t ? Symbol.for("react.lazy") : 60116, b = t ? Symbol.for("react.block") : 60121, m = t ? Symbol.for("react.fundamental") : 60117, v = t ? Symbol.for("react.responder") : 60118, C = t ? Symbol.for("react.scope") : 60119;
  function x(k) {
    if (typeof k == "object" && k !== null) {
      var U = k.$$typeof;
      switch (U) {
        case e:
          switch (k = k.type, k) {
            case l:
            case u:
            case r:
            case s:
            case i:
            case f:
              return k;
            default:
              switch (k = k && k.$$typeof, k) {
                case a:
                case d:
                case _:
                case g:
                case o:
                  return k;
                default:
                  return U;
              }
          }
        case n:
          return U;
      }
    }
  }
  function P(k) {
    return x(k) === u;
  }
  return Ze.AsyncMode = l, Ze.ConcurrentMode = u, Ze.ContextConsumer = a, Ze.ContextProvider = o, Ze.Element = e, Ze.ForwardRef = d, Ze.Fragment = r, Ze.Lazy = _, Ze.Memo = g, Ze.Portal = n, Ze.Profiler = s, Ze.StrictMode = i, Ze.Suspense = f, Ze.isAsyncMode = function(k) {
    return P(k) || x(k) === l;
  }, Ze.isConcurrentMode = P, Ze.isContextConsumer = function(k) {
    return x(k) === a;
  }, Ze.isContextProvider = function(k) {
    return x(k) === o;
  }, Ze.isElement = function(k) {
    return typeof k == "object" && k !== null && k.$$typeof === e;
  }, Ze.isForwardRef = function(k) {
    return x(k) === d;
  }, Ze.isFragment = function(k) {
    return x(k) === r;
  }, Ze.isLazy = function(k) {
    return x(k) === _;
  }, Ze.isMemo = function(k) {
    return x(k) === g;
  }, Ze.isPortal = function(k) {
    return x(k) === n;
  }, Ze.isProfiler = function(k) {
    return x(k) === s;
  }, Ze.isStrictMode = function(k) {
    return x(k) === i;
  }, Ze.isSuspense = function(k) {
    return x(k) === f;
  }, Ze.isValidElementType = function(k) {
    return typeof k == "string" || typeof k == "function" || k === r || k === u || k === s || k === i || k === f || k === p || typeof k == "object" && k !== null && (k.$$typeof === _ || k.$$typeof === g || k.$$typeof === o || k.$$typeof === a || k.$$typeof === d || k.$$typeof === m || k.$$typeof === v || k.$$typeof === C || k.$$typeof === b);
  }, Ze.typeOf = x, Ze;
}
var et = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rm;
function sS() {
  return Rm || (Rm = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, i = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, o = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, l = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, d = t ? Symbol.for("react.forward_ref") : 60112, f = t ? Symbol.for("react.suspense") : 60113, p = t ? Symbol.for("react.suspense_list") : 60120, g = t ? Symbol.for("react.memo") : 60115, _ = t ? Symbol.for("react.lazy") : 60116, b = t ? Symbol.for("react.block") : 60121, m = t ? Symbol.for("react.fundamental") : 60117, v = t ? Symbol.for("react.responder") : 60118, C = t ? Symbol.for("react.scope") : 60119;
    function x(K) {
      return typeof K == "string" || typeof K == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      K === r || K === u || K === s || K === i || K === f || K === p || typeof K == "object" && K !== null && (K.$$typeof === _ || K.$$typeof === g || K.$$typeof === o || K.$$typeof === a || K.$$typeof === d || K.$$typeof === m || K.$$typeof === v || K.$$typeof === C || K.$$typeof === b);
    }
    function P(K) {
      if (typeof K == "object" && K !== null) {
        var Qe = K.$$typeof;
        switch (Qe) {
          case e:
            var ue = K.type;
            switch (ue) {
              case l:
              case u:
              case r:
              case s:
              case i:
              case f:
                return ue;
              default:
                var Ut = ue && ue.$$typeof;
                switch (Ut) {
                  case a:
                  case d:
                  case _:
                  case g:
                  case o:
                    return Ut;
                  default:
                    return Qe;
                }
            }
          case n:
            return Qe;
        }
      }
    }
    var k = l, U = u, I = a, E = o, T = e, A = d, R = r, M = _, S = g, D = n, V = s, X = i, ge = f, Te = !1;
    function Ie(K) {
      return Te || (Te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), B(K) || P(K) === l;
    }
    function B(K) {
      return P(K) === u;
    }
    function q(K) {
      return P(K) === a;
    }
    function se(K) {
      return P(K) === o;
    }
    function re(K) {
      return typeof K == "object" && K !== null && K.$$typeof === e;
    }
    function ae(K) {
      return P(K) === d;
    }
    function ce(K) {
      return P(K) === r;
    }
    function pe(K) {
      return P(K) === _;
    }
    function ie(K) {
      return P(K) === g;
    }
    function le(K) {
      return P(K) === n;
    }
    function Se(K) {
      return P(K) === s;
    }
    function de(K) {
      return P(K) === i;
    }
    function Le(K) {
      return P(K) === f;
    }
    et.AsyncMode = k, et.ConcurrentMode = U, et.ContextConsumer = I, et.ContextProvider = E, et.Element = T, et.ForwardRef = A, et.Fragment = R, et.Lazy = M, et.Memo = S, et.Portal = D, et.Profiler = V, et.StrictMode = X, et.Suspense = ge, et.isAsyncMode = Ie, et.isConcurrentMode = B, et.isContextConsumer = q, et.isContextProvider = se, et.isElement = re, et.isForwardRef = ae, et.isFragment = ce, et.isLazy = pe, et.isMemo = ie, et.isPortal = le, et.isProfiler = Se, et.isStrictMode = de, et.isSuspense = Le, et.isValidElementType = x, et.typeOf = P;
  }()), et;
}
var Cm;
function Hf() {
  return Cm || (Cm = 1, process.env.NODE_ENV === "production" ? Ha.exports = iS() : Ha.exports = sS()), Ha.exports;
}
var au, km;
function oS() {
  if (km) return au;
  km = 1;
  var t = Hf(), e = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, i = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, s = {};
  s[t.ForwardRef] = r, s[t.Memo] = i;
  function o(_) {
    return t.isMemo(_) ? i : s[_.$$typeof] || e;
  }
  var a = Object.defineProperty, l = Object.getOwnPropertyNames, u = Object.getOwnPropertySymbols, d = Object.getOwnPropertyDescriptor, f = Object.getPrototypeOf, p = Object.prototype;
  function g(_, b, m) {
    if (typeof b != "string") {
      if (p) {
        var v = f(b);
        v && v !== p && g(_, v, m);
      }
      var C = l(b);
      u && (C = C.concat(u(b)));
      for (var x = o(_), P = o(b), k = 0; k < C.length; ++k) {
        var U = C[k];
        if (!n[U] && !(m && m[U]) && !(P && P[U]) && !(x && x[U])) {
          var I = d(b, U);
          try {
            a(_, U, I);
          } catch {
          }
        }
      }
    }
    return _;
  }
  return au = g, au;
}
oS();
var Ka = { exports: {} }, tt = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Nm;
function aS() {
  if (Nm) return tt;
  Nm = 1;
  var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), o = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), _;
  _ = Symbol.for("react.module.reference");
  function b(m) {
    if (typeof m == "object" && m !== null) {
      var v = m.$$typeof;
      switch (v) {
        case t:
          switch (m = m.type, m) {
            case n:
            case i:
            case r:
            case u:
            case d:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case a:
                case o:
                case l:
                case p:
                case f:
                case s:
                  return m;
                default:
                  return v;
              }
          }
        case e:
          return v;
      }
    }
  }
  return tt.ContextConsumer = o, tt.ContextProvider = s, tt.Element = t, tt.ForwardRef = l, tt.Fragment = n, tt.Lazy = p, tt.Memo = f, tt.Portal = e, tt.Profiler = i, tt.StrictMode = r, tt.Suspense = u, tt.SuspenseList = d, tt.isAsyncMode = function() {
    return !1;
  }, tt.isConcurrentMode = function() {
    return !1;
  }, tt.isContextConsumer = function(m) {
    return b(m) === o;
  }, tt.isContextProvider = function(m) {
    return b(m) === s;
  }, tt.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, tt.isForwardRef = function(m) {
    return b(m) === l;
  }, tt.isFragment = function(m) {
    return b(m) === n;
  }, tt.isLazy = function(m) {
    return b(m) === p;
  }, tt.isMemo = function(m) {
    return b(m) === f;
  }, tt.isPortal = function(m) {
    return b(m) === e;
  }, tt.isProfiler = function(m) {
    return b(m) === i;
  }, tt.isStrictMode = function(m) {
    return b(m) === r;
  }, tt.isSuspense = function(m) {
    return b(m) === u;
  }, tt.isSuspenseList = function(m) {
    return b(m) === d;
  }, tt.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === n || m === i || m === r || m === u || m === d || m === g || typeof m == "object" && m !== null && (m.$$typeof === p || m.$$typeof === f || m.$$typeof === s || m.$$typeof === o || m.$$typeof === l || m.$$typeof === _ || m.getModuleId !== void 0);
  }, tt.typeOf = b, tt;
}
var nt = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Om;
function cS() {
  return Om || (Om = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), o = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), _ = !1, b = !1, m = !1, v = !1, C = !1, x;
    x = Symbol.for("react.module.reference");
    function P(ue) {
      return !!(typeof ue == "string" || typeof ue == "function" || ue === n || ue === i || C || ue === r || ue === u || ue === d || v || ue === g || _ || b || m || typeof ue == "object" && ue !== null && (ue.$$typeof === p || ue.$$typeof === f || ue.$$typeof === s || ue.$$typeof === o || ue.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ue.$$typeof === x || ue.getModuleId !== void 0));
    }
    function k(ue) {
      if (typeof ue == "object" && ue !== null) {
        var Ut = ue.$$typeof;
        switch (Ut) {
          case t:
            var Ft = ue.type;
            switch (Ft) {
              case n:
              case i:
              case r:
              case u:
              case d:
                return Ft;
              default:
                var kn = Ft && Ft.$$typeof;
                switch (kn) {
                  case a:
                  case o:
                  case l:
                  case p:
                  case f:
                  case s:
                    return kn;
                  default:
                    return Ut;
                }
            }
          case e:
            return Ut;
        }
      }
    }
    var U = o, I = s, E = t, T = l, A = n, R = p, M = f, S = e, D = i, V = r, X = u, ge = d, Te = !1, Ie = !1;
    function B(ue) {
      return Te || (Te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function q(ue) {
      return Ie || (Ie = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function se(ue) {
      return k(ue) === o;
    }
    function re(ue) {
      return k(ue) === s;
    }
    function ae(ue) {
      return typeof ue == "object" && ue !== null && ue.$$typeof === t;
    }
    function ce(ue) {
      return k(ue) === l;
    }
    function pe(ue) {
      return k(ue) === n;
    }
    function ie(ue) {
      return k(ue) === p;
    }
    function le(ue) {
      return k(ue) === f;
    }
    function Se(ue) {
      return k(ue) === e;
    }
    function de(ue) {
      return k(ue) === i;
    }
    function Le(ue) {
      return k(ue) === r;
    }
    function K(ue) {
      return k(ue) === u;
    }
    function Qe(ue) {
      return k(ue) === d;
    }
    nt.ContextConsumer = U, nt.ContextProvider = I, nt.Element = E, nt.ForwardRef = T, nt.Fragment = A, nt.Lazy = R, nt.Memo = M, nt.Portal = S, nt.Profiler = D, nt.StrictMode = V, nt.Suspense = X, nt.SuspenseList = ge, nt.isAsyncMode = B, nt.isConcurrentMode = q, nt.isContextConsumer = se, nt.isContextProvider = re, nt.isElement = ae, nt.isForwardRef = ce, nt.isFragment = pe, nt.isLazy = ie, nt.isMemo = le, nt.isPortal = Se, nt.isProfiler = de, nt.isStrictMode = Le, nt.isSuspense = K, nt.isSuspenseList = Qe, nt.isValidElementType = P, nt.typeOf = k;
  }()), nt;
}
var Pm;
function lS() {
  return Pm || (Pm = 1, process.env.NODE_ENV === "production" ? Ka.exports = aS() : Ka.exports = cS()), Ka.exports;
}
lS();
function uS() {
  const t = Q0();
  let e = null, n = null;
  return {
    clear() {
      e = null, n = null;
    },
    notify() {
      t(() => {
        let r = e;
        for (; r; )
          r.callback(), r = r.next;
      });
    },
    get() {
      let r = [], i = e;
      for (; i; )
        r.push(i), i = i.next;
      return r;
    },
    subscribe(r) {
      let i = !0, s = n = {
        callback: r,
        next: null,
        prev: n
      };
      return s.prev ? s.prev.next = s : e = s, function() {
        !i || e === null || (i = !1, s.next ? s.next.prev = s.prev : n = s.prev, s.prev ? s.prev.next = s.next : e = s.next);
      };
    }
  };
}
const xm = {
  notify() {
  },
  get: () => []
};
function dS(t, e) {
  let n, r = xm, i = 0, s = !1;
  function o(b) {
    d();
    const m = r.subscribe(b);
    let v = !1;
    return () => {
      v || (v = !0, m(), f());
    };
  }
  function a() {
    r.notify();
  }
  function l() {
    _.onStateChange && _.onStateChange();
  }
  function u() {
    return s;
  }
  function d() {
    i++, n || (n = t.subscribe(l), r = uS());
  }
  function f() {
    i--, n && i === 0 && (n(), n = void 0, r.clear(), r = xm);
  }
  function p() {
    s || (s = !0, d());
  }
  function g() {
    s && (s = !1, f());
  }
  const _ = {
    addNestedSub: o,
    notifyNestedSubs: a,
    handleChangeWrapper: l,
    isSubscribed: u,
    trySubscribe: p,
    tryUnsubscribe: g,
    getListeners: () => r
  };
  return _;
}
const fS = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", hS = fS ? Fr.useLayoutEffect : Fr.useEffect;
function pS({
  store: t,
  context: e,
  children: n,
  serverState: r,
  stabilityCheck: i = "once",
  noopCheck: s = "once"
}) {
  const o = Fr.useMemo(() => {
    const u = dS(t);
    return {
      store: t,
      subscription: u,
      getServerState: r ? () => r : void 0,
      stabilityCheck: i,
      noopCheck: s
    };
  }, [t, r, i, s]), a = Fr.useMemo(() => t.getState(), [t]);
  hS(() => {
    const {
      subscription: u
    } = o;
    return u.onStateChange = u.notifyNestedSubs, u.trySubscribe(), a !== t.getState() && u.notifyNestedSubs(), () => {
      u.tryUnsubscribe(), u.onStateChange = void 0;
    };
  }, [o, a]);
  const l = e || Rc;
  return /* @__PURE__ */ Fr.createElement(l.Provider, {
    value: o
  }, n);
}
tS(K0.useSyncExternalStoreWithSelector);
X0(_I);
function yn(t) {
  const { name: e, default: n, id: r, actions: i, uniques: s = [], reduxStore: o } = t, a = () => (o == null ? void 0 : o()) || Fe, l = j0({
    selectId: (m) => m[r]
  }), u = l.getSelectors(), d = l.getInitialState({
    saved: !0,
    status: "idle",
    writeStatus: "ready",
    id: r,
    name: e,
    loadingTime: 600,
    changed: !1
  });
  function f(m, v) {
    const C = Object.values(v), x = Object.values(m).map((k) => {
      const U = typeof n == "function" ? n(v, k) : n;
      return Lf(k, U || {});
    });
    if (!s.length)
      return x;
    const P = [...C, ...x.filter(Boolean)];
    return x.filter((k, U) => !P.slice(0, U).find((T) => s.some((A) => Array.isArray(A) ? A.every((R) => (T == null ? void 0 : T[R]) == (k == null ? void 0 : k[R])) : (T == null ? void 0 : T[A]) == k[A])));
  }
  const p = ll({
    name: e,
    initialState: d,
    reducers: {
      set(m, { payload: v = [] }) {
        l.setAll(m, f(v, m));
      },
      add(m, { payload: v = [] }) {
        const C = f(v, m);
        l.addMany(m, C), C.length && (m.changed = !0);
      },
      remove(m, { payload: v = [] }) {
        v.some((x) => m.ids.includes(x)) && (m.changed = !0), l.removeMany(m, v);
      },
      update(m, { payload: v = [] }) {
        v.map(({ id: P }) => P).some((P) => m.ids.includes(P)) && (m.changed = !0), l.updateMany(m, v);
      },
      reset(m) {
        m.ids.length || (m.changed = !0), l.removeAll(m);
      },
      upsert(m, { payload: v = [] }) {
        l.upsertMany(m, v), m.changed = !0;
      },
      changeStatus(m, { payload: v }) {
        m.status = v;
      },
      setLoadingTime(m, { payload: v }) {
        m.loadingTime = v;
      },
      setChanged(m, { payload: v }) {
        m.changed = v;
      },
      changeWriteStatus(m, { payload: v }) {
        m.writeStatus = v;
      },
      ...i
    }
  }), g = {
    getFull() {
      return At((v) => v[e]);
    },
    getIds() {
      return At((v) => u.selectIds(v[e]));
    },
    getId() {
      return At((v) => v[e].id);
    },
    remove(m) {
      a().dispatch(p.actions.remove(m));
    },
    add(m) {
      a().dispatch(p.actions.add(m));
    },
    upsert(m) {
      a().dispatch(p.actions.upsert(m));
    },
    getOne(m) {
      return At((v) => {
        const C = u.selectById(v[e], m);
        return typeof C > "u" ? void 0 : C;
      });
    },
    setOne(m, v) {
      a().dispatch(
        p.actions.update([
          {
            id: m,
            changes: v
          }
        ])
      );
    },
    setWriteStatus(m = "ready") {
      a().dispatch(p.actions.changeWriteStatus(m));
    },
    useOne(m) {
      const v = g.getOne(m);
      return Uy(
        v,
        (C) => C !== void 0 && g.setOne(m, C),
        (C) => C ?? void 0
      );
    },
    getOneFeild(m, v) {
      return At((x) => {
        var k;
        const P = (k = u.selectById(x[e], m)) == null ? void 0 : k[v];
        return typeof P > "u" ? void 0 : P;
      });
    },
    setOneFeild(m, v, C) {
      a().dispatch(
        p.actions.update([
          {
            id: m,
            changes: {
              [v]: C
            }
          }
        ])
      );
    },
    useOneFeild(m, v) {
      const C = g.getOneFeild(m, v);
      return Uy(
        C,
        (P) => {
          P != null && g.setOneFeild(m, v, P);
        },
        (P) => P
      );
    },
    getOneFeilds(m, v) {
      return At((x) => {
        const P = u.selectById(x[e], m);
        if (!P)
          return;
        const k = {};
        return v.forEach((U) => {
          k[U] = P[U];
        }), k;
      });
    },
    getAll() {
      return At((v) => u.selectAll(v[e]));
    },
    setAll(m) {
      a().dispatch(p.actions.set(m));
    },
    useAll() {
      const m = g.getAll(), v = at(m);
      return Me.useEffect(() => {
        g.setAll(v.get);
      }, [v.get]), Me.useEffect(() => {
        v.set(m);
      }, [m]), v;
    },
    getWriteStatus() {
      return At((v) => v[e].writeStatus);
    },
    useWriteStatus() {
      const m = g.getWriteStatus(), v = at(m);
      return Me.useEffect(() => {
        g.setWriteStatus(v.get);
      }, [v.get]), Me.useEffect(() => {
        v.set(m);
      }, [m]), v;
    },
    getStatus() {
      return At((v) => v[e].status);
    },
    setStatus(m) {
      a().dispatch(p.actions.changeStatus(m));
    },
    useStatus() {
      const m = g.getStatus(), v = at(m);
      return Me.useEffect(() => {
        g.setStatus(v.get);
      }, [v.get]), Me.useEffect(() => {
        v.set(m);
      }, [m]), v;
    },
    getEntity() {
      return At((v) => u.selectEntities(v[e]));
    },
    getLoadingTime() {
      return At((v) => v[e].loadingTime);
    },
    setLoadingTime(m) {
      a().dispatch(p.actions.setLoadingTime(m));
    },
    useLoadingTime() {
      const m = g.getLoadingTime(), v = at(m);
      Me.useEffect(() => {
        g.setLoadingTime(v.get);
      }, [v.get]), Me.useEffect(() => {
        v.set(m);
      }, [m]);
    },
    getChanged() {
      return At((v) => v[e].changed);
    },
    setChanged(m) {
      a().dispatch(p.actions.setChanged(m));
    },
    useChanged() {
      const m = g.getChanged(), v = at(m);
      Me.useEffect(() => {
        g.setChanged(v.get);
      }, [v.get]), Me.useEffect(() => {
        v.set(m);
      }, [m]);
    }
  };
  function _() {
    const m = g.getStatus(), v = g.getId(), C = g.getWriteStatus(), x = g.getLoadingTime();
    return Me.useEffect(() => {
      const P = Object.entries(t.data || {}).map(([k, U]) => ({
        [v]: k,
        ...U
      }));
      g.setAll(P);
    }, []), { id: v, saved: C, status: m, timeLoading: x };
  }
  return {
    slice: p,
    entity: l,
    hooks: g,
    entitySelect: u,
    initialState: d,
    init: _,
    select: (m) => m[e]
  };
}
const mS = {
  data: {
    settings: {
      focused: "user",
      label: "settings controler",
      tabs: {
        user: {
          icon: {
            value: "faTools"
          }
        },
        keyboardShortcuts: {
          label: "keyboard",
          icon: {
            value: "faKeyboard"
          }
          // news: {
          //   value: "faKeyboard",
          // },
        },
        icons: {
          icon: { value: "faIcons" }
        },
        colors: {
          icon: {
            value: "faPenRuler",
            type: "solid"
          }
        }
      }
    },
    "settings.viewType": {
      focused: "list",
      label: "settings layout",
      tab: {
        list: {},
        tree: {}
      }
    }
  }
}, { data: gS } = mS, yS = {
  name: "views",
  id: "viewId",
  default(t, e) {
    const n = e.tabs || {};
    for (const r in n)
      n[r].label || (n[r].label = r);
    return {
      viewId: $t(),
      focused: null,
      tabs: n
    };
  },
  data: gS
}, { hooks: iv, slice: Mm, init: _S, select: yV } = yn(yS);
function _V(t) {
  const e = iv.getOne(t);
  return Me.useMemo(() => {
    var n;
    return typeof (e == null ? void 0 : e.focused) == "number" ? (n = e == null ? void 0 : e.tabs) == null ? void 0 : n[e.focused] : null;
  }, [e]);
}
const bS = {
  id: "treeId",
  name: "tree",
  default: {
    expanded: {},
    separator: "/"
  },
  actions: {
    next(t, { payload: e }) {
      t.entities[e];
    },
    back(t, { payload: e }) {
      t.entities[e];
    },
    toggleExpand(t, { payload: e }) {
      var r;
      const n = t.entities[e];
      n && n.focused && (n.expanded = {
        ...n.expanded || {},
        [n.focused]: !((r = n.expanded) != null && r[n.focused])
      });
    },
    expandMore(t, { payload: e }) {
      const n = t.entities[e];
      n && n.focused && (n.expanded = {
        ...n.expanded || {},
        [n.focused]: !0
      });
    },
    expandLess(t, { payload: e }) {
      const n = t.entities[e];
      n && n.focused && (n.expanded = {
        ...n.expanded || {},
        [n.focused]: !1
      });
    },
    focusParent(t, { payload: e }) {
      const n = t.entities[e];
      if (n && n.focused && n.separator) {
        const r = n.focused.split(n.separator).slice(0, -1).join(n.separator);
        n.focused = r || null;
      }
    },
    focusLeft(t, { payload: e }) {
      var r;
      const n = t.entities[e];
      if (n && n.focused && n.separator)
        if ((r = n.expanded) == null ? void 0 : r[n.focused])
          n.expanded = {
            ...n.expanded || {},
            [n.focused]: !1
          };
        else {
          const s = n.focused.split(n.separator).slice(0, -1).join(n.separator);
          n.focused = s || null;
        }
    },
    focusRight(t, { payload: e }) {
      var r;
      const n = t.entities[e];
      if (n && n.focused && n.separator)
        if (!((r = n.expanded) == null ? void 0 : r[n.focused]))
          n.expanded = {
            ...n.expanded || {},
            [n.focused]: !0
          };
        else {
          const s = [...n.focused.split(n.separator), "0"].join(n.separator);
          n.focused = s;
        }
    }
  },
  data: {}
}, { init: vS, hooks: Dm, slice: Lm } = yn(bS);
function bV(t) {
  const e = Dm.getOne(t);
  Me.useEffect(() => {
    e || Dm.add([
      {
        treeId: t,
        ends: []
      }
    ]);
  }, [e]);
}
const ES = {
  content: null,
  position: null,
  x: "left",
  y: "bottom"
}, Ws = ll({
  initialState: ES,
  name: "title",
  reducers: {
    // actions
    setContent(t, { payload: e }) {
      t.content = e;
    },
    setPosition(t, { payload: e }) {
      t.position = e;
    },
    setX(t, { payload: e }) {
      t.x = e;
    },
    setY(t, { payload: e }) {
      t.y = e;
    }
  }
});
function vV(t) {
  Fe.dispatch(Ws.actions.setContent(t));
}
function EV() {
  return At((e) => e.title.content, Ni);
}
function wV(t) {
  Fe.dispatch(Ws.actions.setPosition(t));
}
function TV() {
  return At((e) => e.title.position, Ni);
}
function IV(t = "left") {
  Fe.dispatch(Ws.actions.setX(t));
}
function SV() {
  return At((e) => e.title.x, Ni);
}
function AV(t = "bottom") {
  Fe.dispatch(Ws.actions.setY(t));
}
function RV() {
  return At((e) => e.title.y, Ni);
}
const wS = {
  id: "id",
  name: "toasts",
  default: () => ({
    id: $t(),
    type: "info"
  })
}, { hooks: TS, init: IS, select: CV, slice: Um, entity: kV } = yn(wS), cs = {
  id: "slotId",
  name: "slot",
  default: {
    slotId: $t(14),
    focused: null,
    submited: null,
    selected: {},
    skiped: {},
    length: 0,
    direction: null,
    redirect: !0
  },
  actions: {
    changeSelectIndexs(t, {
      payload: { name: e, items: n = {} }
    }) {
      const r = t.entities[e];
      r && (r.selected = { ...n });
    },
    removeSelection(t, { payload: e }) {
      t.entities[e] && SS.updateOne(t, {
        id: e,
        changes: {
          ...t.entities[e],
          selected: {}
        }
      });
    },
    next(t, { payload: e }) {
      var i;
      const n = t.entities[e];
      if (!n || !n.length) {
        n && (n.focused = null);
        return;
      }
      const { redirect: r = !0 } = n;
      n.direction = "forward", typeof n.focused != "number" && (n.focused = -1);
      do
        n.focused++, r ? n.focused = Math.abs(n.focused) % n.length : n.focused >= n.length && n.focused--;
      while ((i = n.skiped) != null && i[n.focused]);
    },
    back(t, { payload: e }) {
      var i;
      const n = t.entities[e];
      if (!n || !n.length) {
        n && (n.focused = null);
        return;
      }
      const { redirect: r = !0 } = n;
      n.direction = "backward", typeof n.focused != "number" && (n.focused = n.length);
      do
        n.focused--, n.focused < 0 && r ? n.focused = n.length - 1 : n.focused < 0 && (n.focused = 0);
      while ((i = n.skiped) != null && i[n.focused]);
    },
    submit(t, { payload: e }) {
      const n = t.entities[e];
      n && (n.submited = n.focused);
    },
    submitNext(t, { payload: e }) {
      var i;
      const n = t.entities[e];
      if (!n || !n.length) {
        n && (n.submited = null);
        return;
      }
      const { redirect: r = !0 } = n;
      n.direction = "forward", typeof n.submited != "number" && (n.submited = -1);
      do
        n.submited++, r && (n.submited = n.submited % n.length);
      while ((i = n.skiped) != null && i[n.submited]);
    },
    submitBack(t, { payload: e }) {
      var i;
      const n = t.entities[e];
      if (!n || !n.length) {
        n && (n.submited = null);
        return;
      }
      const { redirect: r = !0 } = n;
      n.direction = "backward", typeof n.submited != "number" && (n.submited = n.length);
      do
        n.submited--, r && (n.submited = n.submited % n.length), n.submited < 0 && (n.submited = n.length - 1);
      while ((i = n.skiped) != null && i[n.submited]);
    },
    submitForce(t, { payload: { name: e, index: n = null } }) {
      const r = t.entities[e];
      r && (r.focused = n, r.submited = n);
    },
    escape(t, { payload: e }) {
      const n = t.entities[e];
      n && (n.selected = {}, n.focused = null, n.direction = null, n.submited = null);
    },
    selectAll(t, { payload: e }) {
      const n = t.entities[e];
      if (!n)
        return;
      const r = {};
      Nb(0, Number(n.length) - 1, 1).forEach((i) => {
        r[i] = !0;
      }), n.selected = r, n.direction = null;
    }
  }
}, { hooks: mi, slice: Fm, entity: SS, init: AS } = yn(cs);
function NV(t) {
  Fe.dispatch({
    type: `${cs.name}/next`,
    payload: t
  });
}
function OV(t) {
  return Fe.dispatch({
    type: `${cs.name}/back`,
    payload: t
  });
}
function PV(t) {
  return Fe.dispatch({
    type: `${cs.name}/escape`,
    payload: t
  });
}
function xV(t) {
  Fe.dispatch({ type: `${cs.name}/submit`, payload: t });
}
function MV(t) {
  Fe.dispatch({ type: `${cs.name}/submitNext`, payload: t });
}
function DV(t) {
  Fe.dispatch({ type: `${cs.name}/submitBack`, payload: t });
}
function LV(t, e) {
  const n = mi.getOne(t);
  Me.useEffect(() => {
    n || mi.upsert([
      {
        slotId: t,
        length: e.length
      }
    ]);
  }, [n, e]), Me.useEffect(() => {
    mi.setOneFeild(t, "length", e.length);
  }, [e]);
}
function UV(t, e, n = "submited") {
  const r = mi.getOneFeild(e, n);
  return Me.useMemo(() => typeof r != "number" ? null : t[r] || null, [r, t]);
}
const sv = {
  data: {
    "preferences/animation.boolean": {
      def: !0,
      desc: "animation in the preferences",
      name: "animation in preferences",
      synced: !0
    },
    "preferences/fastScrollKey.enum": {
      config: {
        list: [
          {
            value: "alt"
          },
          {
            value: "control"
          },
          {
            value: "shift"
          }
        ]
      },
      def: "alt",
      desc: "is one between this keys ${state.settings.entities['preferences/fastScrollKey.enum']?.config.list.map(({ value })=> '**' + value + '**').join(' , ')} and when press one of them the scrolling gona be faster",
      name: "speed scrolling meta key"
    },
    "preferences/font.enum": {
      config: {
        list: [
          {
            content: "Outfit",
            value: "Outfit"
          },
          {
            value: "Playwrite AU SA",
            content: "Playwrite AU SA"
          },
          {
            content: "Karla",
            value: "Karla"
          },
          {
            content: "arial",
            value: "arial"
          },
          {
            content: "times new roman",
            value: "times new roman"
          },
          {
            content: "verdana",
            value: "verdana"
          },
          {
            content: "tahoma",
            value: "tahoma"
          },
          {
            content: "georgia",
            value: "georgia"
          },
          {
            content: "courier new",
            value: "courier new"
          },
          {
            content: "lucida console",
            value: "lucida console"
          },
          {
            content: "impact",
            value: "impact"
          },
          {
            content: "comic sans ms",
            value: "comic sans ms"
          },
          {
            content: "system ui",
            value: "system-ui"
          }
        ],
        search: !0
      },
      def: "Outfit",
      desc: "change one between this fonts ${state.settings.entities['preferences/font.enum']?.config.list.map(({ content })=> '`' + content + '`').join(' , ')}",
      name: "Font",
      synced: !0
    },
    "preferences/toastTime.number": {
      config: {
        max: 10,
        min: 1
      },
      def: 6,
      desc: "is in `second`",
      name: "time of toast done"
    },
    "settings/findBy.enum": {
      config: {
        list: [
          {
            content: "setting id",
            value: "settingId"
          },
          {
            value: "setting"
          },
          {
            value: "name"
          }
        ]
      },
      def: "name",
      desc: "the method of how to find \\`setting\\` using one of this:\n${state.settings.entities['settings/findBy.enum']?.config?.list?.map(({ content , value })=> '**' + (content || value)  + '**' ).join(' or ')}",
      name: "find settings using ?"
    },
    "toast/position.enum": {
      config: {
        list: [
          {
            content: "top",
            value: "top"
          },
          {
            content: "bottom",
            value: "bottom"
          }
        ]
      },
      def: "top",
      desc: "the position of the toast is one between ${state.settings.entities['toast/position.enum']?.config.list.map(({ content })=> '`' + content + '`').join(' , ')}",
      name: "toast position",
      synced: !0
    },
    "keyboard/full.boolean": {
      def: !1,
      desc: "full keyboard",
      name: "full keyboard",
      private: !0,
      synced: !0,
      config: {
        style: "checkbox"
      }
    },
    "visibility/configurations.boolean": {
      def: !1,
      desc: "hide or visible the configurations view",
      name: "visibility of configurations view",
      private: !0
    },
    "visibility/header.boolean": {
      def: !0,
      name: "header view visibility"
    },
    "visibility/headerNotifays.boolean": {
      def: !1,
      name: "header panel notifications visibility",
      private: !0
    },
    "visibility/leftSide.boolean": {
      def: !1,
      desc: "viibility of **left side**  component",
      name: "left side visibility"
    },
    "sides/viewPosition.boolean": {
      def: !1,
      desc: "position of left side and right side views (externel **true**) (internel **false**)",
      name: "sides extra position?"
    },
    "visibility/notifays.boolean": {
      def: !1,
      desc: "visibility of **notification** view",
      name: "notification visibility",
      private: !0
    },
    "visibility/notifays/nots.boolean": {
      def: !1,
      private: !0
    },
    "visibility/rightSide.boolean": {
      def: !1,
      desc: "visibility of **right side** component",
      name: "right side visibility"
    },
    "window/dark.boolean": {
      config: {
        style: "checkbox"
      },
      def: !1,
      desc: "switch between dark mode and light mode",
      name: "dark mode",
      synced: !0
    },
    "window/lang.enum": {
      config: {
        list: [
          {
            content: "arabic",
            value: "ar"
          },
          {
            content: "france",
            value: "fr"
          },
          {
            content: "englich",
            value: "en"
          },
          {
            content: "espaniche",
            value: "es"
          },
          {
            content: "india",
            value: "hi"
          },
          {
            content: "japanese",
            value: "ja"
          },
          {
            content: "russian",
            value: "ru"
          }
        ]
      },
      def: "en",
      desc: "choise one of langs: ${state.settings.entities['window/lang.enum']?.config.list.map(({ content })=> '`' + content + '`').join(' , ')}",
      name: "language",
      synced: !0
    },
    "preferences/scrollAnimation.boolean.boolean": {
      def: !1,
      desc: "scrolling with animation",
      name: "scroll animation"
    },
    "visibility/keyboard.boolean": {
      name: "Keyboard Visibility",
      desc: "The Visibility Of Keyboard Screen",
      def: !1
    },
    "notification/clearAllConfirmation.boolean": {
      name: "clear all notifications",
      desc: "ask before clearing all notifications",
      def: !0
    },
    "ui/native.boolean": {
      name: "native ui",
      desc: "use the native ui for `dialog`, `notification`, `menu`, `toast`",
      def: !0,
      when: "isDesktop"
    },
    "developer/seeComponent.boolean": {
      name: "See Elements Components",
      desc: "See Elements Components In Screen",
      def: !1
    },
    "developer/insertColor.color": {}
  }
}, { data: RS } = sv, CS = {
  name: "settings",
  id: "settingId",
  default(t, { def: e }) {
    return {
      private: !1,
      deperacted: !1,
      config: {},
      value: e
    };
  },
  actions: {
    toggle(t, { payload: e }) {
      const n = t.entities[e];
      n && (n.value = !n.value);
    }
  },
  data: RS
}, { hooks: An, slice: Vm, init: kS, entitySelect: Kf } = yn(CS), NS = {
  name: "positions",
  id: "positionId",
  default: {
    bottom: 0,
    left: 0,
    right: 0,
    top: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0
  }
}, { entity: FV, slice: Bm, hooks: fa, entitySelect: VV, init: OS } = yn(NS), PS = "object", xS = {
  data: {},
  settings: {
    saved: !0,
    status: "idle",
    reloaded: !0,
    watch: !0,
    ignoreAccess: []
  }
}, Zi = ll({
  initialState: xS,
  name: PS,
  reducers: {
    setValue(t, { payload: e }) {
      const n = t.settings.ignoreAccess.find(({ dir: o }) => e.direction == o);
      if (n && n.pass != e.pass) {
        ur.warn(`Cannot Access Direction ${e.direction}`);
        return;
      }
      const r = e.direction.split(".").filter(Boolean);
      if (!r.length) {
        t.data = e.value;
        return;
      }
      let i = t.data;
      r.slice(0, -1).forEach((o) => {
        let a = i[o];
        a == null && e.force && (i[o] = {}, a = i[o]), i = a;
      });
      const s = r.at(-1);
      i[s] = e.value;
    },
    save(t, { payload: e = !1 }) {
      t.settings.saved = e;
    },
    reload(t, { payload: e = !1 }) {
      t.settings.reloaded = e;
    },
    addIgnoreAccess(t, { payload: e }) {
      e.forEach(({ dir: n, pass: r }) => {
        t.settings.ignoreAccess.find((s) => s.dir == n && r == s.pass) || t.settings.ignoreAccess.push({
          dir: n,
          pass: r
        });
      });
    },
    removeIgnoreAccess(t, { payload: e }) {
      e.forEach(({ dir: n, pass: r }) => {
        const i = t.settings.ignoreAccess.findIndex((s) => s.dir == n && r == s.pass);
        i >= 0 && t.settings.ignoreAccess.splice(i, 1);
      });
    }
  }
}), BV = () => At((e) => e.object.settings.saved), $V = () => At((e) => e.object.settings.watch), jV = () => At((e) => e.object.settings.reloaded), qV = () => At((e) => e.object.settings.status), zV = () => {
  Fe.dispatch(Zi.actions.reload(!1));
}, WV = () => {
  Fe.dispatch(Zi.actions.reload(!0));
}, GV = () => {
  Fe.dispatch(Zi.actions.save(!1));
}, HV = () => {
  Fe.dispatch(Zi.actions.save(!0));
};
function Er(t) {
  return At((n) => {
    const { isValide: r, value: i } = il(n.object.data, t);
    return r ? i : null;
  }, Ni);
}
function Et(t, e) {
  Fe.dispatch(
    Zi.actions.setValue({
      value: e,
      direction: t,
      force: !0
    })
  );
}
function ov(t) {
  const e = Er(t), n = at(e);
  return Me.useEffect(() => {
    Et(t, n.get);
  }, [n.get]), Me.useEffect(() => {
    n.set(e);
  }, [e]), n;
}
function Yf(t, e) {
  const n = (e || Fe.getState()).object.data, { isValide: r, value: i } = il(n, t);
  return r ? i : null;
}
const MS = {
  id: "id",
  name: "notifications",
  default: () => ({
    id: $t(),
    desc: void 0,
    removable: !0,
    status: "idle",
    showDesc: !1,
    type: "info",
    buttons: []
  })
}, { hooks: Gs, init: DS, select: KV, slice: $m, entity: YV } = yn(MS);
function av() {
  An.setOneFeild("visibility/notifays.boolean", "value", !0), An.setOneFeild("visibility/notifays/nots.boolean", "value", !0);
}
function cv() {
  An.setOneFeild("visibility/notifays.boolean", "value", !1), An.setOneFeild("visibility/notifays/nots.boolean", "value", !1);
}
async function XV(t, e = {}) {
  const n = Lf(e, {
    open: !0,
    close: !0,
    time: 2e3
  });
  n != null && n.open && av();
  const r = {
    id: $t(),
    title: " - ",
    ...t
  };
  Gs.upsert([r]), await Id(n.time), Gs.remove([r.id]), n != null && n.close && cv();
}
async function QV(t, e) {
  const n = e();
  return n instanceof Promise ? new Promise(async (r, i) => {
    av(), Gs.upsert([t]), n.then(r).catch(i).finally(() => {
      Gs.remove([t.id]), cv();
    });
  }) : n;
}
const LS = {
  id: "logId",
  name: "logs",
  data: {},
  default: () => ({
    logId: $t(10),
    desc: "",
    type: "INFO",
    category: "window",
    showDesc: !1,
    createdAt: (/* @__PURE__ */ new Date()).toISOString()
  })
}, { entity: JV, slice: jm, init: US, hooks: ZV } = yn(LS), FS = {
  id: "word",
  name: "langs"
}, VS = () => Hs.setWriteStatus("idle"), { init: BS, hooks: Hs, entity: eB, slice: qm } = yn(FS), $S = {
  data: [
    {
      command: "dialog.goToNextButton",
      value: "arrowdown",
      when: "state.object.data.dialog.id"
    },
    {
      command: "dialog.goToNextButton",
      value: "arrowright",
      when: "state.object.data.dialog.id"
    },
    {
      command: "dialog.goToPreviousButton",
      value: "arrowleft",
      when: "state.object.data.dialog.id"
    },
    {
      command: "dialog.goToPreviousButton",
      value: "arrowup",
      when: "state.object.data.dialog.id"
    },
    {
      command: "dialog.escape",
      value: "escape",
      when: "state.object.data.dialog.id"
    },
    {
      command: "dialog.clickOnButton",
      value: "enter",
      when: "state.object.data.dialog.id"
    },
    {
      command: "dialog.clickOnButton",
      value: "space",
      when: "state.object.data.dialog.id"
    },
    {
      command: "settings.colors.show",
      value: "control+shift+c",
      when: "state.views.entities.settings.focused == 'colors'"
    },
    {
      command: "menu.next",
      when: "state.object.data.menu.id",
      value: "arrowdown"
    },
    {
      command: "menu.back",
      when: "state.object.data.menu.id",
      value: "arrowup"
    },
    {
      command: "menu.submit",
      when: "state.object.data.menu.id",
      value: "enter"
    },
    {
      command: "menu.escape",
      when: "state.object.data.menu.id",
      value: "escape"
    },
    {
      value: "tab",
      command: "input.completeWord",
      when: "state.object.data.input.focusedHasProposition",
      type: "up"
    },
    {
      value: "tab",
      command: "defaultCommand.ignore",
      when: "state.object.data.input.focusedHasProposition"
    },
    {
      value: "tab",
      command: "input.tab",
      when: "state.object.data.input.supportTab"
    },
    {
      value: "control+l",
      command: "input.selectLine",
      when: "focused"
    },
    {
      value: "shift+alt+arrowdown",
      command: "input.addLineBellow",
      when: "focused"
    },
    {
      command: "string.change",
      when: "focused && state.fields.ids.includes(focused + ':input')",
      value: "enter"
    },
    {
      command: "string.cancel",
      when: "focused && state.fields.ids.includes(focused + ':input')",
      value: "escape"
    },
    {
      command: "commands.next",
      when: "focused == 'cmds/list' || focused == 'findCommand'",
      value: "arrowdown"
    },
    {
      command: "commands.back",
      when: "focused == 'cmds/list' || focused == 'findCommand'",
      value: "arrowup"
    },
    {
      command: "commands.submit",
      when: "focused == 'cmds/list' || focused == 'findCommand'",
      value: "enter"
    },
    {
      command: "commands.open",
      when: "focused != 'findCommand' || !state.object.data.commandId",
      value: "control+shift+p"
    },
    {
      command: "commands.open",
      when: "focused != 'findCommand' || !state.object.data.commandId",
      value: "f1"
    },
    {
      repeation: !1,
      command: "notification.openAndExpandMoreAndFocus",
      when: "focused != 'notifications'",
      value: "shift+alt+n"
    },
    {
      command: "view.leftSide.toggle",
      value: "control+b",
      repeation: !1
    },
    {
      command: "view.rightSide.toggle",
      value: "control+alt+b",
      repeation: !1
    },
    {
      command: "view.settings.show",
      when: "focused != 'findConfigurations-local' || !state.settings.entities['visibility/configurations.boolean']?.value",
      value: "control+,"
    },
    {
      repeation: !1,
      command: "settings.keyboardShortcuts.show",
      when: "state.settings.entities['visibility/configurations.boolean']?.value",
      value: "control+k"
    },
    {
      repeation: !1,
      command: "settings.user.show",
      when: "state.settings.entities['visibility/configurations.boolean']?.value",
      value: "control+u"
    },
    {
      repeation: !1,
      command: "settings.icons.show",
      when: "state.settings.entities['visibility/configurations.boolean']?.value",
      value: "control+i"
    },
    {
      repeation: !1,
      command: "keyboardShortcuts.submitCurrentKeyPanding",
      value: "enter",
      when: "['findConfigurations-local','keyboardShortcuts'].includes(focused) && state.views.entities.settings.focused == 'keyboardShortcuts'"
    },
    {
      command: "keyboard/update",
      value: "f2",
      when: "['findConfigurations-local','keyboardShortcuts'].includes(focused) && state.views.entities.settings.focused == 'keyboardShortcuts'"
    },
    {
      command: "keyboardShortcuts.focusNextKeyPanding",
      value: "arrowdown",
      when: "['findConfigurations-local','keyboardShortcuts'].includes(focused) && state.views.entities.settings.focused == 'keyboardShortcuts'"
    },
    {
      command: "keyboardShortcuts.focusPreviousKeyPanding",
      value: "arrowup",
      when: "['findConfigurations-local','keyboardShortcuts'].includes(focused) && state.views.entities.settings.focused == 'keyboardShortcuts'"
    },
    {
      value: "arrowdown",
      command: "colors-list-next",
      when: "['findConfigurations-local','color-list'].includes(focused) && state.views.entities.settings.focused == 'colors'"
    },
    {
      value: "arrowup",
      command: "colors-list-back",
      when: "['findConfigurations-local','color-list'].includes(focused) && state.views.entities.settings.focused == 'colors'"
    },
    {
      value: "enter",
      command: "colors-list-submit",
      when: "['findConfigurations-local','color-list'].includes(focused) && state.views.entities.settings.focused == 'colors'"
    },
    {
      command: "configurations.next",
      value: "arrowdown",
      when: "focused == 'findConfigurations-local' && state.views.entities.settings.focused == 'user'"
    },
    {
      command: "configurations.back",
      value: "arrowup",
      when: "focused == 'findConfigurations-local' && state.views.entities.settings.focused == 'user'"
    },
    {
      repeation: !1,
      command: "configurations.submit",
      value: "enter",
      when: "focused == 'findConfigurations-local' && state.views.entities.settings.focused == 'user'"
    },
    {
      command: "notification.submitCurrent",
      when: "focused == 'notifications'",
      value: "enter"
    },
    {
      command: "notification.focusNext",
      when: "focused == 'notifications'",
      value: "arrowdown"
    },
    {
      command: "notification.focusPrevious",
      when: "focused == 'notifications'",
      value: "arrowup"
    },
    {
      command: "notification.deleteFocus",
      when: "focused == 'notifications'",
      value: "delete"
    },
    {
      command: "notifays.toggleExpandNotifay",
      when: "focused == 'notifications'",
      value: "space"
    },
    {
      command: "enum/next",
      value: "arrowdown",
      when: "state.object.data.enum.id"
    },
    {
      command: "enum/next",
      value: "arrowright",
      when: "state.object.data.enum.id"
    },
    {
      command: "enum/back",
      value: "arrowleft",
      when: "state.object.data.enum.id"
    },
    {
      command: "enum/back",
      value: "arrowup",
      when: "state.object.data.enum.id"
    },
    {
      repeation: !1,
      command: "enum/submit",
      value: "space",
      when: "!state.object.data.enum.isLoading && state.object.data.enum.id"
    },
    {
      repeation: !1,
      command: "enum/submit",
      value: "enter",
      when: "!state.object.data.enum.isLoading && state.object.data.enum.id"
    },
    {
      repeation: !1,
      command: "enum/escape",
      value: "escape",
      when: "state.object.data.enum.id"
    },
    {
      repeation: !1,
      command: "show.submit.setting",
      value: "f2",
      when: "focused == 'findConfigurations-local'"
    },
    {
      command: "commands.close",
      when: "state.object.data.commandId",
      value: "escape"
    },
    {
      command: "view.settings.update.hide",
      when: "state.object.data.view.settings",
      value: "escape"
    },
    {
      command: "view.settings.hide",
      when: "state.settings.entities['visibility/configurations.boolean']?.value",
      value: "escape"
    },
    {
      repeation: !1,
      command: "notification.closeAndExpandLess",
      when: "state.settings.entities['visibility/notifays.boolean']?.value",
      value: "escape"
    },
    {
      command: "configurations.settings.layouts.next",
      when: "focused == 'settings.layouts'",
      value: "arrowright"
    },
    {
      command: "configurations.settings.layouts.previous",
      when: "focused == 'settings.layouts'",
      value: "arrowleft"
    },
    {
      command: "configurations.settings.layout.submit",
      when: "focused == 'settings.layouts'",
      value: "enter"
    },
    {
      when: "focused == 'settings.tree.view'",
      value: "space",
      command: "settings.tree.toggleExpand"
    },
    {
      when: "focused == 'settings.tree.view'",
      value: "arrowright",
      command: "settings.tree.expandMore"
    },
    {
      when: "focused == 'settings.tree.view'",
      value: "arrowleft",
      command: "settings.tree.expandLess"
    },
    {
      command: "header.toggle",
      value: "control+h"
    },
    {
      command: "settings.icons.next",
      when: "['findConfigurations-local','icons-list'].includes(focused) && state.views.entities.settings.focused == 'icons'",
      value: "arrowdown"
    },
    {
      command: "settings.icons.back",
      when: "['findConfigurations-local','icons-list'].includes(focused) && state.views.entities.settings.focused == 'icons'",
      value: "arrowup"
    },
    {
      command: "settings.icons.submit",
      when: "['findConfigurations-local','icons-list'].includes(focused) && state.views.entities.settings.focused == 'icons'",
      value: "enter"
    },
    {
      command: "camera-take",
      value: "enter",
      when: "state.object.data?.camera?.id"
    },
    {
      command: "window.toggleMode",
      value: "control+d"
    },
    {
      command: "bottomSheet/escape",
      value: "escape",
      when: "state.object.data.view['bottomSheet']",
      repeation: !1
    },
    {
      command: "feedback/send",
      value: "enter",
      when: "focused == 'feedback-message'"
    },
    {
      command: "feedback/send",
      value: "control+enter",
      when: "focused == 'feedback-message'"
    }
  ]
}, jS = {
  data: {
    "camera-take": {
      commands: [
        {
          payload: ["camera-take"],
          type: "actions/exec"
        }
      ]
    },
    "colors-list-back": {
      commands: [
        {
          payload: "colors-list",
          type: "slot/back"
        }
      ]
    },
    "colors-list-next": {
      commands: [
        {
          payload: "colors-list",
          type: "slot/next"
        }
      ]
    },
    "colors-list-submit": {
      commands: [
        {
          payload: "colors-list",
          type: "slot/submit"
        }
      ]
    },
    "commands.back": {
      commands: [
        {
          payload: "cmds/list",
          type: "slot/back"
        }
      ],
      label: "commands : back"
    },
    "commands.close": {
      commands: [
        {
          payload: {
            direction: "commandId",
            force: !0,
            value: null
          },
          type: "object/setValue"
        }
      ],
      label: "view : close commands"
    },
    "commands.next": {
      commands: [
        {
          payload: "cmds/list",
          type: "slot/next"
        }
      ],
      label: "commands : next"
    },
    "commands.open": {
      commands: [
        {
          payload: {
            direction: "commandId",
            force: !0,
            value: "commands"
          },
          type: "object/setValue"
        }
      ],
      label: "view : open commands"
    },
    "commands.submit": {
      commands: [
        {
          payload: "cmds/list",
          type: "slot/submit"
        }
      ],
      label: "commands : run"
    },
    "configurations.back": {
      commands: [
        {
          payload: "configurations",
          type: "slot/back"
        }
      ],
      label: "settings : back"
    },
    "configurations.next": {
      commands: [
        {
          payload: "configurations",
          type: "slot/next"
        }
      ],
      label: "settings : next"
    },
    "configurations.settings.layout.submit": {
      commands: [
        {
          payload: "settings.layout.tools",
          type: "slot/submit"
        }
      ],
      label: "settings layout : change"
    },
    "configurations.settings.layouts.next": {
      commands: [
        {
          payload: "settings.layout.tools",
          type: "slot/next"
        }
      ],
      label: "settings layout : next"
    },
    "configurations.settings.layouts.previous": {
      commands: [
        {
          payload: "settings.layout.tools",
          type: "slot/back"
        }
      ],
      label: "settings layout : previous"
    },
    "configurations.submit": {
      commands: [
        {
          payload: "configurations",
          type: "slot/submit"
        }
      ],
      label: "settings : submit"
    },
    "defaultCommand.ignore": {
      commands: [],
      private: !0
    },
    "dialog.clickOnButton": {
      commands: [
        {
          payload: "dialog-list",
          type: "slot/submit"
        }
      ],
      label: "Dialog : Click And Submit"
    },
    "dialog.escape": {
      commands: [
        {
          payload: ["dialog.cancel"],
          type: "actions/exec"
        }
      ],
      label: "Dialog : Escape"
    },
    "dialog.goToNextButton": {
      commands: [
        {
          payload: "dialog-list",
          type: "slot/next"
        }
      ],
      label: "Dialog : Next Button"
    },
    "dialog.goToPreviousButton": {
      commands: [
        {
          payload: "dialog-list",
          type: "slot/back"
        }
      ],
      label: "Dialog : Previous Button"
    },
    "header.toggle": {
      commands: [
        {
          payload: "visibility/header.boolean",
          type: "settings/toggle"
        }
      ],
      label: "view : toggle header"
    },
    "headerNotifays.toggleExpand": {
      commands: [
        {
          payload: "visibility/headerNotifays.boolean",
          type: "settings/toggle"
        }
      ],
      label: "view : toggle header notifications"
    },
    "input.addLineBellow": {
      commands: [
        {
          payload: ["input.addLineBellow"],
          type: "actions/exec"
        }
      ],
      label: "input : add line bellow"
    },
    "input.completeWord": {
      commands: [
        {
          payload: ["input.completeWord"],
          type: "actions/exec"
        }
      ],
      label: "input : complete word"
    },
    "input.selectLine": {
      commands: [
        {
          payload: ["input.selectLine"],
          type: "actions/exec"
        }
      ],
      label: "input : select line"
    },
    "input.tab": {
      commands: [
        {
          payload: ["input.tab"],
          type: "actions/exec"
        }
      ],
      label: "input : tab space"
    },
    "keyboard/update": {
      commands: [
        {
          payload: ["keyboard/update"],
          type: "actions/exec"
        }
      ]
    },
    "keyboardShortcuts.focusNextKeyPanding": {
      commands: [
        {
          payload: "keyboardShortcuts",
          type: "slot/next"
        }
      ],
      label: "keyboard shortcuts : focus next"
    },
    "keyboardShortcuts.focusPreviousKeyPanding": {
      commands: [
        {
          payload: "keyboardShortcuts",
          type: "slot/back"
        }
      ],
      label: "keyboard shortcuts : focus previous"
    },
    "keyboardShortcuts.submitCurrentKeyPanding": {
      commands: [
        {
          payload: "keyboardShortcuts",
          type: "slot/submit"
        }
      ],
      label: "keyboard shortcuts : submit current"
    },
    "menu.back": {
      commands: [
        {
          payload: "menu-list",
          type: "slot/back"
        }
      ]
    },
    "menu.escape": {
      commands: [
        {
          payload: {
            direction: "menu.id",
            force: !0,
            value: null
          },
          type: "object/setValue"
        }
      ]
    },
    "menu.next": {
      commands: [
        {
          payload: "menu-list",
          type: "slot/next"
        }
      ]
    },
    "menu.submit": {
      commands: [
        {
          payload: "menu-list",
          type: "slot/submit"
        }
      ]
    },
    "notifays.toggleExpandNotifay": {
      commands: [
        {
          payload: ["toggleExpandNotifay", null],
          type: "actions/exec"
        }
      ],
      label: "notifications : toggle expand notifications"
    },
    "notification.close": {
      commands: [
        {
          payload: [
            {
              changes: {
                value: !1
              },
              id: "visibility/notifays.boolean"
            }
          ],
          type: "settings/update"
        }
      ],
      label: "view : close notifications"
    },
    "notification.closeAndExpandLess": {
      commands: [
        "notification.close",
        {
          payload: [
            {
              changes: {
                value: !1
              },
              id: "visibility/notifays/notes.boolean"
            }
          ],
          type: "settings/update"
        }
      ],
      label: "view : close notifications and expand less"
    },
    "notification.deleteFocus": {
      commands: [
        {
          payload: ["notification.deleteFocus"],
          type: "actions/exec"
        }
      ],
      label: "notifications : delete the focused notification"
    },
    "notification.focusNext": {
      commands: [
        {
          payload: "notification",
          type: "slot/next"
        }
      ],
      label: "notifications : go next"
    },
    "notification.focusPrevious": {
      commands: [
        {
          payload: "notification",
          type: "slot/back"
        }
      ],
      label: "notifications: go back"
    },
    "notification.open": {
      commands: [
        {
          payload: [
            {
              changes: {
                value: !0
              },
              id: "visibility/notifays.boolean"
            }
          ],
          type: "settings/update"
        }
      ],
      label: "notifications : open"
    },
    "notification.openAndExpandMoreAndFocus": {
      commands: [
        "notification.open",
        {
          payload: [
            {
              changes: {
                value: !0
              },
              id: "visibility/notifays/notes.boolean"
            }
          ],
          type: "settings/update"
        },
        {
          payload: ["focus", "notifications"],
          type: "actions/exec"
        }
      ],
      label: "notifications : open and expand more and focus"
    },
    "notification.submitCurrent": {
      commands: [
        {
          payload: "notification",
          type: "slot/submit"
        }
      ],
      label: "notifications : submit current"
    },
    "notification.toggle": {
      commands: [
        {
          payload: "visibility/notifays.boolean",
          type: "settings/toggle"
        }
      ],
      label: "view : toggle notifications"
    },
    "search.history.clear": {
      commands: [
        {
          payload: ["search.history.clear"],
          type: "actions/exec"
        }
      ],
      label: "search : clear history"
    },
    "settings.colors.show": {
      commands: [
        {
          payload: [
            {
              changes: {
                focused: "colors"
              },
              id: "settings"
            }
          ],
          type: "views/update"
        }
      ]
    },
    "settings.focusNext": {
      commands: [
        {
          payload: "settings",
          type: "slot/next"
        }
      ]
    },
    "settings.focusPrevious": {
      commands: [
        {
          payload: "settings",
          type: "slot/back"
        }
      ]
    },
    "settings.icons.back": {
      commands: [
        {
          payload: "icons-list",
          type: "slot/back"
        }
      ]
    },
    "settings.icons.next": {
      commands: [
        {
          payload: "icons-list",
          type: "slot/next"
        }
      ]
    },
    "settings.icons.show": {
      commands: [
        {
          payload: [
            {
              changes: {
                focused: "icons"
              },
              id: "settings"
            }
          ],
          type: "views/update"
        }
      ]
    },
    "settings.icons.submit": {
      commands: [
        {
          payload: "icons-list",
          type: "slot/submit"
        }
      ]
    },
    "settings.keyboardShortcuts.show": {
      commands: [
        {
          payload: [
            {
              changes: {
                focused: "keyboardShortcuts"
              },
              id: "settings"
            }
          ],
          type: "views/update"
        }
      ]
    },
    "settings.tree.expandLess": {
      commands: [
        {
          payload: "setting-tree-layout",
          type: "tree/expandLess"
        }
      ]
    },
    "settings.tree.expandMore": {
      commands: [
        {
          payload: "setting-tree-layout",
          type: "tree/expandMore"
        }
      ]
    },
    "settings.tree.toggleExpand": {
      commands: [
        {
          payload: "setting-tree-layout",
          type: "tree/toggleExpand"
        }
      ]
    },
    "settings.user.show": {
      commands: [
        {
          payload: [
            {
              changes: {
                focused: "user"
              },
              id: "settings"
            }
          ],
          type: "views/update"
        }
      ]
    },
    "show.submit.setting": {
      commands: [
        {
          payload: ["showSubmitSetting", null],
          type: "actions/exec"
        }
      ]
    },
    "string.cancel": {
      commands: [
        {
          payload: ["string.cancel"],
          type: "actions/exec"
        }
      ],
      private: !0
    },
    "string.change": {
      commands: [
        {
          payload: ["string.change"],
          type: "actions/exec"
        }
      ],
      private: !0
    },
    "tools.tip.click": {
      commands: [
        {
          payload: ["tip.click"],
          type: "actions/exec"
        }
      ]
    },
    "view.leftSide.close": {
      commands: [
        {
          payload: [
            {
              changes: {
                value: !1
              },
              id: "visibility/leftSide.boolean"
            }
          ],
          type: "settings/update"
        }
      ],
      label: "leftSide : close"
    },
    "view.leftSide.open": {
      commands: [
        {
          payload: [
            {
              changes: {
                value: !0
              },
              id: "visibility/leftSide.boolean"
            }
          ],
          type: "settings/update"
        }
      ]
    },
    "view.leftSide.toggle": {
      commands: [
        {
          payload: "visibility/leftSide.boolean",
          type: "settings/toggle"
        }
      ]
    },
    "view.rightSide.close": {
      commands: [
        {
          payload: [
            {
              changes: {
                value: !1
              },
              id: "visibility/rightSide.boolean"
            }
          ],
          type: "settings/update"
        }
      ]
    },
    "view.rightSide.open": {
      commands: [
        {
          payload: [
            {
              changes: {
                value: !0
              },
              id: "visibility/rightSide.boolean"
            }
          ],
          type: "settings/update"
        }
      ]
    },
    "view.rightSide.toggle": {
      commands: [
        {
          payload: "visibility/rightSide.boolean",
          type: "settings/toggle"
        }
      ]
    },
    "view.settings.hide": {
      commands: [
        {
          payload: [
            {
              changes: {
                value: !1
              },
              id: "visibility/configurations.boolean"
            }
          ],
          type: "settings/update"
        }
      ],
      label: "view : hide settings view"
    },
    "view.settings.show": {
      commands: [
        {
          payload: [
            {
              changes: {
                value: !0
              },
              id: "visibility/configurations.boolean"
            }
          ],
          type: "settings/update"
        },
        {
          payload: [
            {
              changes: {
                value: ""
              },
              id: "findConfigurations-local"
            }
          ],
          type: "fields/update"
        },
        {
          payload: ["focus", "findConfigurations-local"],
          type: "actions/exec"
        }
      ],
      label: "view : show settings view"
    },
    "view.settings.update.hide": {
      commands: [
        {
          payload: {
            direction: "view.settings",
            force: !0,
            value: null
          },
          type: "object/setValue"
        },
        {
          payload: ["focus", "findConfigurations-local"],
          type: "actions/exec"
        }
      ],
      label: "view : hide settings update view"
    },
    "window.toggleMode": {
      commands: [
        {
          payload: "window/dark.boolean",
          type: "settings/toggle"
        }
      ],
      label: "window : toggle between (light/dark) mode"
    },
    "enum/next": {
      commands: [
        {
          type: "slot/next",
          payload: "enum-list"
        }
      ],
      label: "enum : go to next"
    },
    "enum/back": {
      commands: [
        {
          type: "slot/back",
          payload: "enum-list"
        }
      ],
      label: "enum : go to back"
    },
    "enum/submit": {
      commands: [
        {
          type: "slot/submit",
          payload: "enum-list"
        }
      ],
      label: "enum : select"
    },
    "enum/escape": {
      commands: [
        {
          payload: {
            direction: "enum.id",
            force: !0,
            value: null
          },
          type: "object/setValue"
        }
      ],
      label: "enum : escape"
    },
    "bottomSheet/escape": {
      commands: [
        {
          payload: {
            direction: "view.bottomSheet",
            force: !0,
            value: !1
          },
          type: "object/setValue"
        }
      ],
      label: "bottom sheet : escape"
    },
    "feedback/send": {
      commands: [
        {
          payload: ["send-feedback"],
          type: "actions/exec"
        }
      ],
      label: "Help : Send Feedback"
    }
  }
}, { data: qS } = jS, zS = "commands";
function lv(t, e = Fe.getState()) {
  const { [zS]: n } = e, r = [], i = n.entities[t], s = i == null ? void 0 : i.commands;
  return i != null && i.blocked ? [] : (s == null || s.forEach((o) => {
    typeof o == "string" ? r.push(...lv(o)) : typeof o != "number" && r.push(o);
  }), r);
}
function WS(t, e = Fe.getState()) {
  return !!(e != null && e.commands.entities[t]);
}
async function uv(t, e = Fe.getState()) {
  const n = t.toString();
  ur.inf("start invoke command : ", n), e = e || Fe.getState();
  const r = lv(t, e), i = new Uf();
  for (let s = 0; s < r.length; s++) {
    const o = r[s];
    typeof o == "number" ? await i.start(o) : Fe.dispatch(o);
  }
  ur.succ("end invoking command : ", n);
}
const GS = {
  id: "commandId",
  name: "commands",
  data: qS,
  default: (t, e) => {
    if (!e.commandId)
      return {};
    const [n = "", ...r] = e.commandId.split(".");
    return {
      label: `${wc(n, "camel", "normal")} : ${r.map((s) => wc(s, void 0, "normal")).join(" ")}`
    };
  }
}, { hooks: dv, slice: zm, entitySelect: tB, init: HS } = yn(GS), { data: KS } = $S, YS = {
  name: "keys",
  id: "keyId",
  data: Object.entries(KS).map(([t, e]) => ({
    keyId: t,
    ...e
  })),
  default: () => ({
    repeation: !0,
    type: "down",
    only: !0,
    preventDefault: !0,
    keyId: `key_${$t()}`
  })
}, { init: XS, hooks: ul, slice: Wm } = yn(YS), Ya = "_" + $t().replaceAll(/[^0-9A-Za-z$_]+/gi, "_");
function QS(t) {
  return Function(`
    return ({ state , focused })=> {
      ${Ya}_window = window;
      window = null;
      let ${Ya} = ${t};
      window = ${Ya}_window;
      return ${Ya}
    }
  `)();
}
function JS() {
  XS();
  const t = ul.getAll(), e = Er("commands.isBlocked"), n = Me.useMemo(() => e ? [] : t.filter(({ value: r, command: i }) => r && i).map((r) => {
    const { value: i = "", when: s, repeation: o = !0, type: a = "down", only: l = !0, preventDefault: u = !0 } = r, d = new Ob(i);
    return {
      fn: async (p) => {
        if (!o && p.repeat || !d.test(p))
          return;
        const g = Fe.getState();
        if (s) {
          const _ = mI(), b = QS(s);
          try {
            if (!b({ state: g, focused: _ }))
              return;
          } catch {
            return;
          }
        }
        l && p.stopImmediatePropagation(), u && p.preventDefault(), ur.inf(`KEYID       = ${r.keyId}`), ur.inf(`RUN         = ${r.command || "no command run"}`), ur.inf(`COMB        = (${r.value})`), ur.inf(`WHEN        = ${r.when || "no provide"}`), r.command && WS(r.command, g) ? ur.succ("EXISTS") : ur.warn("COMMAND NOT FOUND"), uv(r.command, g);
      },
      type: a
    };
  }), [t, e]);
  yD(
    () => (n.forEach(({ fn: r, type: i }) => {
      document.addEventListener(`key${i}`, r);
    }), () => {
      n.forEach(({ fn: r, type: i }) => {
        document.removeEventListener(`key${i}`, r);
      });
    }),
    [n],
    1e3
  );
}
const fv = "keyboard", ZS = {
  Shift: !1,
  Alt: !1,
  Control: !1,
  SymbolLock: !1,
  AltGraph: !1,
  CapsLock: !1,
  Fn: !1,
  FnLock: !1,
  Hyper: !1,
  Meta: !1,
  NumLock: !1,
  Super: !1,
  ScrollLock: !1,
  Symbol: !1,
  Key: void 0
}, eA = (t) => t[fv], Pd = ll({
  name: fv,
  initialState: ZS,
  reducers: {
    // actions
    setModifier(t, { payload: e }) {
      try {
        t[e.modifierName] = e.value;
      } catch {
      }
    }
  }
});
function nB(t) {
  return At(eA, (n, r) => Ni(n[t], r[t]))[t];
}
function hn(t, e) {
  Fe.dispatch(Pd.actions.setModifier({ modifierName: t, value: e }));
}
const tA = {
  name: "fields",
  id: "fieldId",
  default: () => ({
    selection: {
      direction: "forward",
      end: 0,
      start: 0
    },
    value: ""
  })
}, { entity: rB, slice: Gm, hooks: Xt, entitySelect: iB, init: nA } = yn(tA), rA = {
  data: {
    autoCompleteInput: {
      default: "#888A"
    },
    "bg.selection": {
      dark: "#fff",
      light: "#000"
    },
    "bottom-sheeet.background": {},
    danger: {
      default: "#F33"
    },
    success: {
      default: "#2ea043"
    },
    "black.opacity": {
      dark: "#0006",
      light: "#0003"
    },
    borders: {
      dark: "#333",
      light: "#bebebe"
    },
    "checkbox.background": {
      default: "#8884"
    },
    "checkbox.false": {
      default: "#F33"
    },
    "checkbox.true": {
      default: "#393"
    },
    error: {
      default: "#F33"
    },
    "error.border": {
      default: "#733"
    },
    "error.content": {
      default: "white"
    },
    "error.text": {
      default: "#F33"
    },
    "field.background": {
      default: "#A0A0A011"
    },
    "focus.text": {
      default: "#F33"
    },
    "gray.opacity": {
      default: "#8884"
    },
    "gray.opacity.2": {
      default: "#8887"
    },
    "gray.opacity.toLight": {
      default: "#eee4"
    },
    htmlContentHover: {
      default: "#27F5"
    },
    "info.text": {
      default: "#37F"
    },
    locationIconSetup: {
      default: "yellow"
    },
    "log.error.color": {
      default: "#F33"
    },
    "log.info.color": {
      default: "#27F"
    },
    "log.secuess.color": {
      default: "#393"
    },
    "log.warning.color": {
      default: "rgb(227 138 32)"
    },
    "notifay.error": {
      default: "#e61a1a"
    },
    "notifay.error.text": {
      default: "#fff"
    },
    "notifay.info": {
      default: "#2e7aec"
    },
    "notifay.info.text": {
      default: "#fff"
    },
    "notifay.success": {
      default: "#2b8817"
    },
    "notifay.success.text": {
      default: "#fff"
    },
    "notifay.warning": {
      default: "#e7a428"
    },
    "notifay.warning.text": {
      default: "#fff"
    },
    primary: {
      dark: "#0078d4",
      light: "#46A"
    },
    "primary.background": {
      dark: "#111",
      light: "#ececec"
    },
    "primary.content": {
      dark: "#fff",
      light: "#fff"
    },
    "primary.hover.background": {
      dark: "#222",
      light: "#e1e1e1"
    },
    secondary: {
      dark: "#043853",
      light: "#0d8c9c"
    },
    "secondary.background": {
      dark: "#171717",
      light: "#e1e1e1"
    },
    "secondary.content": {
      default: "#fff"
    },
    selectedTextBackgroundBlured: {
      default: "#8885"
    },
    selectedTextBackgroundFocused: {
      default: "#26F6"
    },
    selectedTextColorBlur: {
      default: "#222"
    },
    selectedTextColorFocused: {
      default: "#fff"
    },
    "shadow.background.from": {
      default: "transparent"
    },
    "shadow.background.to": {
      dark: "#000",
      light: "#999"
    },
    "shadow.color": {
      dark: "#000b",
      light: "#4444"
    },
    "starts.color": {
      dark: "#FA0",
      light: "#E90"
    },
    "status.content": {
      default: "white"
    },
    "submit.background": {
      default: "#9994"
    },
    "submit.color": {
      default: "#fff"
    },
    "success.text": {
      default: "#14B85B"
    },
    "text.color": {
      dark: "#ccc",
      light: "#333"
    },
    "text.selection": {
      dark: "#000",
      light: "#fff"
    },
    "toast.background": {
      dark: "#333",
      light: "#eee"
    },
    transparent: {
      default: "transparent"
    },
    "warning.text": {
      default: "rgb(227 138 32)"
    },
    warning: {
      default: "rgb(227 138 32)"
    },
    opacity: {
      dark: "#fff2",
      light: "#0002"
    }
  }
}, { data: iA } = rA, sA = {
  id: "colorId",
  name: "color",
  data: iA
}, { hooks: fr, slice: Hm, init: oA, select: sB, entity: oB, entitySelect: aB } = yn(sA), aA = {
  id: "linkId",
  name: "cahser",
  default() {
    return {
      status: "idle"
    };
  }
}, { init: cA, hooks: cB, slice: Km } = yn(aA), lc = {
  name: "actions",
  id: "actionId",
  data: {},
  default() {
    return {
      status: "ready",
      args: null
    };
  },
  actions: {
    exec(t, { payload: e }) {
      const [n, r] = e, i = t.entities[n];
      i && (i.args = r, i.status = "idle");
    }
  }
}, { entity: lB, slice: Ym, hooks: Xn, entitySelect: uB } = yn(lc);
function lA(t) {
  const e = Xn.getOne(t);
  Me.useEffect(() => {
    e || Xn.upsert([
      {
        actionId: t,
        status: "ready",
        args: null
      }
    ]);
  }, [e]);
}
function uA(t, e, n = []) {
  Me.useEffect(() => () => {
    Xn.remove([t]);
  }, []), lA(t);
  const r = Xn.getOne(t);
  return Vs(async () => {
    if (!r)
      return;
    const { status: i } = r;
    if (i == "idle") {
      try {
        const { args: s } = r;
        Xn.setOneFeild(t, "status", "loading");
        let o = null, a = null;
        o = e(s), o instanceof Promise ? a = await o : a = o, Xn.setOneFeild(t, "output", a), Xn.setOneFeild(t, "status", "success");
      } catch (s) {
        console.log(s), Xn.setOneFeild(t, "output", null), Xn.setOneFeild(t, "status", "error");
      }
      Xn.setOneFeild(t, "args", null);
    }
  }, [r, ...n]), r;
}
function dA(t, e) {
  return new Promise((n, r) => {
    Fe.dispatch({ type: "actions/exec", payload: [t, e] });
    const i = Qc(`${lc.name}.entities.` + t + ".status", "success", (o) => {
      s(), n({
        output: o[lc.name].entities[t].output,
        state: o
      });
    }), s = Qc(`${lc.name}.entities.` + t + ".status", "error", (o) => {
      i(), r(o);
    });
  });
}
const dB = (t) => ha(t, "loading"), fB = (t) => ha(t, "ready"), hB = (t) => ha(t, "success"), pB = (t) => ha(t, "idle"), mB = (t) => ha(t, "error"), ha = (t, e = "success") => typeof t == "string" ? t == e : typeof t == "object" ? (t == null ? void 0 : t.status) === e : !1, Fe = E0({
  reducer: {
    // normal reducers
    [Pd.name]: Pd.reducer,
    [Zi.name]: Zi.reducer,
    [Ws.name]: Ws.reducer,
    // system space
    [zm.name]: zm.reducer,
    [Wm.name]: Wm.reducer,
    [$m.name]: $m.reducer,
    [Mm.name]: Mm.reducer,
    [Bm.name]: Bm.reducer,
    [Fm.name]: Fm.reducer,
    [Vm.name]: Vm.reducer,
    [Gm.name]: Gm.reducer,
    [Ym.name]: Ym.reducer,
    [Hm.name]: Hm.reducer,
    [Lm.name]: Lm.reducer,
    [jm.name]: jm.reducer,
    [qm.name]: qm.reducer,
    [Km.name]: Km.reducer,
    [Um.name]: Um.reducer
    /* main database */
  }
}), Ns = class Ns {
  constructor(e, n = null) {
    if (this.name = e, this.parent = n, this.name.includes(".") || Ns.allTemps[this.name])
      throw `temp name ${this.name} exists before`;
    Ns.allTemps[this.name] = this;
  }
  getTemp(e) {
    return Er([this.name, e].join("."));
  }
  getTempFromStore(e, n) {
    return Yf([this.name, e].join("."), n);
  }
  setTemp(e, n) {
    Et([this.name, e].join("."), n);
  }
  useTemp(e) {
    return ov([this.name, e].join("."));
  }
  get childsTemps() {
    return Object.values(Ns.allTemps).filter(({ parent: e }) => e == this);
  }
};
Ui(Ns, "allTemps", {});
let Rt = Ns;
const gB = new Rt("path"), yB = new Rt("window"), zr = new Rt("views"), _B = new Rt("toast"), Xm = new Rt("dialog"), bB = new Rt("loading"), Qm = new Rt("progress"), vB = new Rt("password"), _s = new Rt("menu"), EB = new Rt("news"), hv = new Rt("visibility"), wB = new Rt("ipinfo"), TB = new Rt("submited"), ji = new Rt("camera"), IB = new Rt("recaptcha"), Cc = new Rt("iframe"), SB = new Rt("enum"), AB = new Rt("resize"), RB = new Rt("dateTime"), Un = new Rt("action");
class fA {
  constructor(e) {
    this.name = e;
  }
  getInfo() {
    const e = Un.getTemp(`${this.name}.id`), n = Un.getTemp(`${this.name}.output`), r = Un.getTemp(`${this.name}.input`), i = Un.getTemp(`${this.name}.status`);
    return {
      id: e,
      output: n,
      input: r,
      status: i
    };
  }
  setId(e = null) {
    Un.setTemp(`${this.name}.id`, e);
  }
  setOutput(e = null) {
    Un.setTemp(`${this.name}.output`, e);
  }
  setInput(e = null) {
    Un.setTemp(`${this.name}.input`, e);
  }
  setStatus(e = null) {
    Un.setTemp(`${this.name}.status`, e);
  }
  getInfoFromStore(e) {
    const n = Un.getTempFromStore(`${this.name}.id`, e), r = Un.getTempFromStore(`${this.name}.output`, e), i = Un.getTempFromStore(`${this.name}.input`, e), s = Un.getTempFromStore(`${this.name}.status`, e);
    return {
      id: n,
      output: r,
      input: i,
      status: s
    };
  }
  async run(e) {
    const n = crypto.randomUUID();
    return this.setId(n), this.setInput(e), this.setStatus(null), new Promise((r, i) => {
      const s = `object.data.action.${this.name}`, o = sp(
        s,
        (a) => typeof a == "object" && (a == null ? void 0 : a.status),
        (a) => {
          const { id: l, output: u, status: d } = this.getInfoFromStore(a);
          l === n && typeof d == "string" && (o(), r(u), this.setInput(null), this.setOutput(null), this.setId(null), this.setStatus(null), d === "error" ? i(u) : r(u));
        }
      );
    });
  }
  use() {
    const e = this.getInfo();
    return {
      error: () => {
        this.setStatus("error");
      },
      success: (n) => {
        this.setOutput(n), this.setStatus("success");
      },
      ...e
    };
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pv = function(t) {
  const e = [];
  let n = 0;
  for (let r = 0; r < t.length; r++) {
    let i = t.charCodeAt(r);
    i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = i >> 6 | 192, e[n++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < t.length && (t.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++r) & 1023), e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128) : (e[n++] = i >> 12 | 224, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128);
  }
  return e;
}, hA = function(t) {
  const e = [];
  let n = 0, r = 0;
  for (; n < t.length; ) {
    const i = t[n++];
    if (i < 128)
      e[r++] = String.fromCharCode(i);
    else if (i > 191 && i < 224) {
      const s = t[n++];
      e[r++] = String.fromCharCode((i & 31) << 6 | s & 63);
    } else if (i > 239 && i < 365) {
      const s = t[n++], o = t[n++], a = t[n++], l = ((i & 7) << 18 | (s & 63) << 12 | (o & 63) << 6 | a & 63) - 65536;
      e[r++] = String.fromCharCode(55296 + (l >> 10)), e[r++] = String.fromCharCode(56320 + (l & 1023));
    } else {
      const s = t[n++], o = t[n++];
      e[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | o & 63);
    }
  }
  return e.join("");
}, mv = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(t, e) {
    if (!Array.isArray(t))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = [];
    for (let i = 0; i < t.length; i += 3) {
      const s = t[i], o = i + 1 < t.length, a = o ? t[i + 1] : 0, l = i + 2 < t.length, u = l ? t[i + 2] : 0, d = s >> 2, f = (s & 3) << 4 | a >> 4;
      let p = (a & 15) << 2 | u >> 6, g = u & 63;
      l || (g = 64, o || (p = 64)), r.push(n[d], n[f], n[p], n[g]);
    }
    return r.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(pv(t), e);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : hA(this.decodeStringToByteArray(t, e));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(t, e) {
    this.init_();
    const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = [];
    for (let i = 0; i < t.length; ) {
      const s = n[t.charAt(i++)], a = i < t.length ? n[t.charAt(i)] : 0;
      ++i;
      const u = i < t.length ? n[t.charAt(i)] : 64;
      ++i;
      const f = i < t.length ? n[t.charAt(i)] : 64;
      if (++i, s == null || a == null || u == null || f == null)
        throw new pA();
      const p = s << 2 | a >> 4;
      if (r.push(p), u !== 64) {
        const g = a << 4 & 240 | u >> 2;
        if (r.push(g), f !== 64) {
          const _ = u << 6 & 192 | f;
          r.push(_);
        }
      }
    }
    return r;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let t = 0; t < this.ENCODED_VALS.length; t++)
        this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t);
    }
  }
};
class pA extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const mA = function(t) {
  const e = pv(t);
  return mv.encodeByteArray(e, !0);
}, kc = function(t) {
  return mA(t).replace(/\./g, "");
}, gv = function(t) {
  try {
    return mv.decodeString(t, !0);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function gA() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof globalThis < "u")
    return globalThis;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yA = () => gA().__FIREBASE_DEFAULTS__, _A = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const t = process.env.__FIREBASE_DEFAULTS__;
  if (t)
    return JSON.parse(t);
}, bA = () => {
  if (typeof document > "u")
    return;
  let t;
  try {
    t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const e = t && gv(t[1]);
  return e && JSON.parse(e);
}, dl = () => {
  try {
    return yA() || _A() || bA();
  } catch (t) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
    return;
  }
}, yv = (t) => {
  var e, n;
  return (n = (e = dl()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || n === void 0 ? void 0 : n[t];
}, Xf = (t) => {
  const e = yv(t);
  if (!e)
    return;
  const n = e.lastIndexOf(":");
  if (n <= 0 || n + 1 === e.length)
    throw new Error(`Invalid host ${e} with no separate hostname and port!`);
  const r = parseInt(e.substring(n + 1), 10);
  return e[0] === "[" ? [e.substring(1, n - 1), r] : [e.substring(0, n), r];
}, _v = () => {
  var t;
  return (t = dl()) === null || t === void 0 ? void 0 : t.config;
}, bv = (t) => {
  var e;
  return (e = dl()) === null || e === void 0 ? void 0 : e[`_${t}`];
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vA {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((e, n) => {
      this.resolve = e, this.reject = n;
    });
  }
  /**
   * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(e) {
    return (n, r) => {
      n ? this.reject(n) : this.resolve(r), typeof e == "function" && (this.promise.catch(() => {
      }), e.length === 1 ? e(n) : e(n, r));
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function vv(t, e) {
  if (t.uid)
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  const n = {
    alg: "none",
    type: "JWT"
  }, r = e || "demo-project", i = t.iat || 0, s = t.sub || t.user_id;
  if (!s)
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  const o = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${r}`,
    aud: r,
    iat: i,
    exp: i + 3600,
    auth_time: i,
    sub: s,
    user_id: s,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, t);
  return [
    kc(JSON.stringify(n)),
    kc(JSON.stringify(o)),
    ""
  ].join(".");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cn() {
  return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : "";
}
function EA() {
  return typeof window < "u" && // @ts-ignore Setting up an broadly applicable index signature for Window
  // just to deal with this case would probably be a bad idea.
  !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(cn());
}
function wA() {
  var t;
  const e = (t = dl()) === null || t === void 0 ? void 0 : t.forceEnvironment;
  if (e === "node")
    return !0;
  if (e === "browser")
    return !1;
  try {
    return Object.prototype.toString.call(globalThis.process) === "[object process]";
  } catch {
    return !1;
  }
}
function TA() {
  return typeof navigator < "u" && navigator.userAgent === "Cloudflare-Workers";
}
function IA() {
  const t = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
  return typeof t == "object" && t.id !== void 0;
}
function SA() {
  return typeof navigator == "object" && navigator.product === "ReactNative";
}
function AA() {
  const t = cn();
  return t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0;
}
function RA() {
  return !wA() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
}
function CA() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function kA() {
  return new Promise((t, e) => {
    try {
      let n = !0;
      const r = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(r);
      i.onsuccess = () => {
        i.result.close(), n || self.indexedDB.deleteDatabase(r), t(!0);
      }, i.onupgradeneeded = () => {
        n = !1;
      }, i.onerror = () => {
        var s;
        e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (n) {
      e(n);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NA = "FirebaseError";
class rr extends Error {
  constructor(e, n, r) {
    super(n), this.code = e, this.customData = r, this.name = NA, Object.setPrototypeOf(this, rr.prototype), Error.captureStackTrace && Error.captureStackTrace(this, pa.prototype.create);
  }
}
class pa {
  constructor(e, n, r) {
    this.service = e, this.serviceName = n, this.errors = r;
  }
  create(e, ...n) {
    const r = n[0] || {}, i = `${this.service}/${e}`, s = this.errors[e], o = s ? OA(s, r) : "Error", a = `${this.serviceName}: ${o} (${i}).`;
    return new rr(i, a, r);
  }
}
function OA(t, e) {
  return t.replace(PA, (n, r) => {
    const i = e[r];
    return i != null ? String(i) : `<${r}?>`;
  });
}
const PA = /\{\$([^}]+)}/g;
function xA(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e))
      return !1;
  return !0;
}
function Nc(t, e) {
  if (t === e)
    return !0;
  const n = Object.keys(t), r = Object.keys(e);
  for (const i of n) {
    if (!r.includes(i))
      return !1;
    const s = t[i], o = e[i];
    if (Jm(s) && Jm(o)) {
      if (!Nc(s, o))
        return !1;
    } else if (s !== o)
      return !1;
  }
  for (const i of r)
    if (!n.includes(i))
      return !1;
  return !0;
}
function Jm(t) {
  return t !== null && typeof t == "object";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ma(t) {
  const e = [];
  for (const [n, r] of Object.entries(t))
    Array.isArray(r) ? r.forEach((i) => {
      e.push(encodeURIComponent(n) + "=" + encodeURIComponent(i));
    }) : e.push(encodeURIComponent(n) + "=" + encodeURIComponent(r));
  return e.length ? "&" + e.join("&") : "";
}
function No(t) {
  const e = {};
  return t.replace(/^\?/, "").split("&").forEach((r) => {
    if (r) {
      const [i, s] = r.split("=");
      e[decodeURIComponent(i)] = decodeURIComponent(s);
    }
  }), e;
}
function Oo(t) {
  const e = t.indexOf("?");
  if (!e)
    return "";
  const n = t.indexOf("#", e);
  return t.substring(e, n > 0 ? n : void 0);
}
function MA(t, e) {
  const n = new DA(t, e);
  return n.subscribe.bind(n);
}
class DA {
  /**
   * @param executor Function which can make calls to a single Observer
   *     as a proxy.
   * @param onNoObservers Callback when count of Observers goes to zero.
   */
  constructor(e, n) {
    this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = n, this.task.then(() => {
      e(this);
    }).catch((r) => {
      this.error(r);
    });
  }
  next(e) {
    this.forEachObserver((n) => {
      n.next(e);
    });
  }
  error(e) {
    this.forEachObserver((n) => {
      n.error(e);
    }), this.close(e);
  }
  complete() {
    this.forEachObserver((e) => {
      e.complete();
    }), this.close();
  }
  /**
   * Subscribe function that can be used to add an Observer to the fan-out list.
   *
   * - We require that no event is sent to a subscriber synchronously to their
   *   call to subscribe().
   */
  subscribe(e, n, r) {
    let i;
    if (e === void 0 && n === void 0 && r === void 0)
      throw new Error("Missing Observer.");
    LA(e, [
      "next",
      "error",
      "complete"
    ]) ? i = e : i = {
      next: e,
      error: n,
      complete: r
    }, i.next === void 0 && (i.next = cu), i.error === void 0 && (i.error = cu), i.complete === void 0 && (i.complete = cu);
    const s = this.unsubscribeOne.bind(this, this.observers.length);
    return this.finalized && this.task.then(() => {
      try {
        this.finalError ? i.error(this.finalError) : i.complete();
      } catch {
      }
    }), this.observers.push(i), s;
  }
  // Unsubscribe is synchronous - we guarantee that no events are sent to
  // any unsubscribed Observer.
  unsubscribeOne(e) {
    this.observers === void 0 || this.observers[e] === void 0 || (delete this.observers[e], this.observerCount -= 1, this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this));
  }
  forEachObserver(e) {
    if (!this.finalized)
      for (let n = 0; n < this.observers.length; n++)
        this.sendOne(n, e);
  }
  // Call the Observer via one of it's callback function. We are careful to
  // confirm that the observe has not been unsubscribed since this asynchronous
  // function had been queued.
  sendOne(e, n) {
    this.task.then(() => {
      if (this.observers !== void 0 && this.observers[e] !== void 0)
        try {
          n(this.observers[e]);
        } catch (r) {
          typeof console < "u" && console.error && console.error(r);
        }
    });
  }
  close(e) {
    this.finalized || (this.finalized = !0, e !== void 0 && (this.finalError = e), this.task.then(() => {
      this.observers = void 0, this.onNoObservers = void 0;
    }));
  }
}
function LA(t, e) {
  if (typeof t != "object" || t === null)
    return !1;
  for (const n of e)
    if (n in t && typeof t[n] == "function")
      return !0;
  return !1;
}
function cu() {
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function st(t) {
  return t && t._delegate ? t._delegate : t;
}
class Wr {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, n, r) {
    this.name = e, this.instanceFactory = n, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(e) {
    return this.instantiationMode = e, this;
  }
  setMultipleInstances(e) {
    return this.multipleInstances = e, this;
  }
  setServiceProps(e) {
    return this.serviceProps = e, this;
  }
  setInstanceCreatedCallback(e) {
    return this.onInstanceCreated = e, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $i = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UA {
  constructor(e, n) {
    this.name = e, this.container = n, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide multiple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(e) {
    const n = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(n)) {
      const r = new vA();
      if (this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize())
        try {
          const i = this.getOrInitializeService({
            instanceIdentifier: n
          });
          i && r.resolve(i);
        } catch {
        }
    }
    return this.instancesDeferred.get(n).promise;
  }
  getImmediate(e) {
    var n;
    const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier), i = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1;
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: r
        });
      } catch (s) {
        if (i)
          return null;
        throw s;
      }
    else {
      if (i)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = e, !!this.shouldAutoInitialize()) {
      if (VA(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: $i });
        } catch {
        }
      for (const [n, r] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(n);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: i
          });
          r.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(e = $i) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((n) => "INTERNAL" in n).map((n) => n.INTERNAL.delete()),
      ...e.filter((n) => "_delete" in n).map((n) => n._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = $i) {
    return this.instances.has(e);
  }
  getOptions(e = $i) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: n = {} } = e, r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(r))
      throw Error(`${this.name}(${r}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const i = this.getOrInitializeService({
      instanceIdentifier: r,
      options: n
    });
    for (const [s, o] of this.instancesDeferred.entries()) {
      const a = this.normalizeInstanceIdentifier(s);
      r === a && o.resolve(i);
    }
    return i;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(e, n) {
    var r;
    const i = this.normalizeInstanceIdentifier(n), s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : /* @__PURE__ */ new Set();
    s.add(e), this.onInitCallbacks.set(i, s);
    const o = this.instances.get(i);
    return o && e(o, i), () => {
      s.delete(e);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(e, n) {
    const r = this.onInitCallbacks.get(n);
    if (r)
      for (const i of r)
        try {
          i(e, n);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: e, options: n = {} }) {
    let r = this.instances.get(e);
    if (!r && this.component && (r = this.component.instanceFactory(this.container, {
      instanceIdentifier: FA(e),
      options: n
    }), this.instances.set(e, r), this.instancesOptions.set(e, n), this.invokeOnInitCallbacks(r, e), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, e, r);
      } catch {
      }
    return r || null;
  }
  normalizeInstanceIdentifier(e = $i) {
    return this.component ? this.component.multipleInstances ? e : $i : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function FA(t) {
  return t === $i ? void 0 : t;
}
function VA(t) {
  return t.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BA {
  constructor(e) {
    this.name = e, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(e) {
    const n = this.getProvider(e.name);
    if (n.isComponentSet())
      throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    n.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(e) {
    if (this.providers.has(e))
      return this.providers.get(e);
    const n = new UA(e, this);
    return this.providers.set(e, n), n;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ze;
(function(t) {
  t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT";
})(ze || (ze = {}));
const $A = {
  debug: ze.DEBUG,
  verbose: ze.VERBOSE,
  info: ze.INFO,
  warn: ze.WARN,
  error: ze.ERROR,
  silent: ze.SILENT
}, jA = ze.INFO, qA = {
  [ze.DEBUG]: "log",
  [ze.VERBOSE]: "log",
  [ze.INFO]: "info",
  [ze.WARN]: "warn",
  [ze.ERROR]: "error"
}, zA = (t, e, ...n) => {
  if (e < t.logLevel)
    return;
  const r = (/* @__PURE__ */ new Date()).toISOString(), i = qA[e];
  if (i)
    console[i](`[${r}]  ${t.name}:`, ...n);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
};
class Qf {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(e) {
    this.name = e, this._logLevel = jA, this._logHandler = zA, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in ze))
      throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(e) {
    this._logLevel = typeof e == "string" ? $A[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, ze.DEBUG, ...e), this._logHandler(this, ze.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, ze.VERBOSE, ...e), this._logHandler(this, ze.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, ze.INFO, ...e), this._logHandler(this, ze.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, ze.WARN, ...e), this._logHandler(this, ze.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, ze.ERROR, ...e), this._logHandler(this, ze.ERROR, ...e);
  }
}
const WA = (t, e) => e.some((n) => t instanceof n);
let Zm, eg;
function GA() {
  return Zm || (Zm = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function HA() {
  return eg || (eg = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const Ev = /* @__PURE__ */ new WeakMap(), xd = /* @__PURE__ */ new WeakMap(), wv = /* @__PURE__ */ new WeakMap(), lu = /* @__PURE__ */ new WeakMap(), Jf = /* @__PURE__ */ new WeakMap();
function KA(t) {
  const e = new Promise((n, r) => {
    const i = () => {
      t.removeEventListener("success", s), t.removeEventListener("error", o);
    }, s = () => {
      n(gi(t.result)), i();
    }, o = () => {
      r(t.error), i();
    };
    t.addEventListener("success", s), t.addEventListener("error", o);
  });
  return e.then((n) => {
    n instanceof IDBCursor && Ev.set(n, t);
  }).catch(() => {
  }), Jf.set(e, t), e;
}
function YA(t) {
  if (xd.has(t))
    return;
  const e = new Promise((n, r) => {
    const i = () => {
      t.removeEventListener("complete", s), t.removeEventListener("error", o), t.removeEventListener("abort", o);
    }, s = () => {
      n(), i();
    }, o = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), i();
    };
    t.addEventListener("complete", s), t.addEventListener("error", o), t.addEventListener("abort", o);
  });
  xd.set(t, e);
}
let Md = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return xd.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || wv.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return gi(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function XA(t) {
  Md = t(Md);
}
function QA(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(uu(this), e, ...n);
    return wv.set(r, e.sort ? e.sort() : [e]), gi(r);
  } : HA().includes(t) ? function(...e) {
    return t.apply(uu(this), e), gi(Ev.get(this));
  } : function(...e) {
    return gi(t.apply(uu(this), e));
  };
}
function JA(t) {
  return typeof t == "function" ? QA(t) : (t instanceof IDBTransaction && YA(t), WA(t, GA()) ? new Proxy(t, Md) : t);
}
function gi(t) {
  if (t instanceof IDBRequest)
    return KA(t);
  if (lu.has(t))
    return lu.get(t);
  const e = JA(t);
  return e !== t && (lu.set(t, e), Jf.set(e, t)), e;
}
const uu = (t) => Jf.get(t);
function ZA(t, e, { blocked: n, upgrade: r, blocking: i, terminated: s } = {}) {
  const o = indexedDB.open(t, e), a = gi(o);
  return r && o.addEventListener("upgradeneeded", (l) => {
    r(gi(o.result), l.oldVersion, l.newVersion, gi(o.transaction), l);
  }), n && o.addEventListener("blocked", (l) => n(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    l.oldVersion,
    l.newVersion,
    l
  )), a.then((l) => {
    s && l.addEventListener("close", () => s()), i && l.addEventListener("versionchange", (u) => i(u.oldVersion, u.newVersion, u));
  }).catch(() => {
  }), a;
}
const eR = ["get", "getKey", "getAll", "getAllKeys", "count"], tR = ["put", "add", "delete", "clear"], du = /* @__PURE__ */ new Map();
function tg(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (du.get(e))
    return du.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, i = tR.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || eR.includes(n))
  )
    return;
  const s = async function(o, ...a) {
    const l = this.transaction(o, i ? "readwrite" : "readonly");
    let u = l.store;
    return r && (u = u.index(a.shift())), (await Promise.all([
      u[n](...a),
      i && l.done
    ]))[0];
  };
  return du.set(e, s), s;
}
XA((t) => ({
  ...t,
  get: (e, n, r) => tg(e, n) || t.get(e, n, r),
  has: (e, n) => !!tg(e, n) || t.has(e, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nR {
  constructor(e) {
    this.container = e;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((n) => {
      if (rR(n)) {
        const r = n.getImmediate();
        return `${r.library}/${r.version}`;
      } else
        return null;
    }).filter((n) => n).join(" ");
  }
}
function rR(t) {
  const e = t.getComponent();
  return (e == null ? void 0 : e.type) === "VERSION";
}
const Dd = "@firebase/app", ng = "0.10.13";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Gr = new Qf("@firebase/app"), iR = "@firebase/app-compat", sR = "@firebase/analytics-compat", oR = "@firebase/analytics", aR = "@firebase/app-check-compat", cR = "@firebase/app-check", lR = "@firebase/auth", uR = "@firebase/auth-compat", dR = "@firebase/database", fR = "@firebase/data-connect", hR = "@firebase/database-compat", pR = "@firebase/functions", mR = "@firebase/functions-compat", gR = "@firebase/installations", yR = "@firebase/installations-compat", _R = "@firebase/messaging", bR = "@firebase/messaging-compat", vR = "@firebase/performance", ER = "@firebase/performance-compat", wR = "@firebase/remote-config", TR = "@firebase/remote-config-compat", IR = "@firebase/storage", SR = "@firebase/storage-compat", AR = "@firebase/firestore", RR = "@firebase/vertexai-preview", CR = "@firebase/firestore-compat", kR = "firebase", NR = "10.14.1";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ld = "[DEFAULT]", OR = {
  [Dd]: "fire-core",
  [iR]: "fire-core-compat",
  [oR]: "fire-analytics",
  [sR]: "fire-analytics-compat",
  [cR]: "fire-app-check",
  [aR]: "fire-app-check-compat",
  [lR]: "fire-auth",
  [uR]: "fire-auth-compat",
  [dR]: "fire-rtdb",
  [fR]: "fire-data-connect",
  [hR]: "fire-rtdb-compat",
  [pR]: "fire-fn",
  [mR]: "fire-fn-compat",
  [gR]: "fire-iid",
  [yR]: "fire-iid-compat",
  [_R]: "fire-fcm",
  [bR]: "fire-fcm-compat",
  [vR]: "fire-perf",
  [ER]: "fire-perf-compat",
  [wR]: "fire-rc",
  [TR]: "fire-rc-compat",
  [IR]: "fire-gcs",
  [SR]: "fire-gcs-compat",
  [AR]: "fire-fst",
  [CR]: "fire-fst-compat",
  [RR]: "fire-vertex",
  "fire-js": "fire-js",
  [kR]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Oc = /* @__PURE__ */ new Map(), PR = /* @__PURE__ */ new Map(), Ud = /* @__PURE__ */ new Map();
function rg(t, e) {
  try {
    t.container.addComponent(e);
  } catch (n) {
    Gr.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n);
  }
}
function bi(t) {
  const e = t.name;
  if (Ud.has(e))
    return Gr.debug(`There were multiple attempts to register component ${e}.`), !1;
  Ud.set(e, t);
  for (const n of Oc.values())
    rg(n, t);
  for (const n of PR.values())
    rg(n, t);
  return !0;
}
function ga(t, e) {
  const n = t.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return n && n.triggerHeartbeat(), t.container.getProvider(e);
}
function Bn(t) {
  return t.settings !== void 0;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xR = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}'",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "server-app-deleted": "Firebase Server App has been deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}, yi = new pa("app", "Firebase", xR);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MR {
  constructor(e, n, r) {
    this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new Wr(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = e;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw yi.create("app-deleted", { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ls = NR;
function DR(t, e = {}) {
  let n = t;
  typeof e != "object" && (e = { name: e });
  const r = Object.assign({ name: Ld, automaticDataCollectionEnabled: !1 }, e), i = r.name;
  if (typeof i != "string" || !i)
    throw yi.create("bad-app-name", {
      appName: String(i)
    });
  if (n || (n = _v()), !n)
    throw yi.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = Oc.get(i);
  if (s) {
    if (Nc(n, s.options) && Nc(r, s.config))
      return s;
    throw yi.create("duplicate-app", { appName: i });
  }
  const o = new BA(i);
  for (const l of Ud.values())
    o.addComponent(l);
  const a = new MR(n, r, o);
  return Oc.set(i, a), a;
}
function fl(t = Ld) {
  const e = Oc.get(t);
  if (!e && t === Ld && _v())
    return DR();
  if (!e)
    throw yi.create("no-app", { appName: t });
  return e;
}
function $n(t, e, n) {
  var r;
  let i = (r = OR[t]) !== null && r !== void 0 ? r : t;
  n && (i += `-${n}`);
  const s = i.match(/\s|\//), o = e.match(/\s|\//);
  if (s || o) {
    const a = [
      `Unable to register library "${i}" with version "${e}":`
    ];
    s && a.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && o && a.push("and"), o && a.push(`version name "${e}" contains illegal characters (whitespace or "/")`), Gr.warn(a.join(" "));
    return;
  }
  bi(new Wr(
    `${i}-version`,
    () => ({ library: i, version: e }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LR = "firebase-heartbeat-database", UR = 1, Qo = "firebase-heartbeat-store";
let fu = null;
function Tv() {
  return fu || (fu = ZA(LR, UR, {
    upgrade: (t, e) => {
      switch (e) {
        case 0:
          try {
            t.createObjectStore(Qo);
          } catch (n) {
            console.warn(n);
          }
      }
    }
  }).catch((t) => {
    throw yi.create("idb-open", {
      originalErrorMessage: t.message
    });
  })), fu;
}
async function FR(t) {
  try {
    const n = (await Tv()).transaction(Qo), r = await n.objectStore(Qo).get(Iv(t));
    return await n.done, r;
  } catch (e) {
    if (e instanceof rr)
      Gr.warn(e.message);
    else {
      const n = yi.create("idb-get", {
        originalErrorMessage: e == null ? void 0 : e.message
      });
      Gr.warn(n.message);
    }
  }
}
async function ig(t, e) {
  try {
    const r = (await Tv()).transaction(Qo, "readwrite");
    await r.objectStore(Qo).put(e, Iv(t)), await r.done;
  } catch (n) {
    if (n instanceof rr)
      Gr.warn(n.message);
    else {
      const r = yi.create("idb-set", {
        originalErrorMessage: n == null ? void 0 : n.message
      });
      Gr.warn(r.message);
    }
  }
}
function Iv(t) {
  return `${t.name}!${t.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VR = 1024, BR = 30 * 24 * 60 * 60 * 1e3;
class $R {
  constructor(e) {
    this.container = e, this._heartbeatsCache = null;
    const n = this.container.getProvider("app").getImmediate();
    this._storage = new qR(n), this._heartbeatsCachePromise = this._storage.read().then((r) => (this._heartbeatsCache = r, r));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var e, n;
    try {
      const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), s = sg();
      return ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some((o) => o.date === s) ? void 0 : (this._heartbeatsCache.heartbeats.push({ date: s, agent: i }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((o) => {
        const a = new Date(o.date).valueOf();
        return Date.now() - a <= BR;
      }), this._storage.overwrite(this._heartbeatsCache));
    } catch (r) {
      Gr.warn(r);
    }
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var e;
    try {
      if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
        return "";
      const n = sg(), { heartbeatsToSend: r, unsentEntries: i } = jR(this._heartbeatsCache.heartbeats), s = kc(JSON.stringify({ version: 2, heartbeats: r }));
      return this._heartbeatsCache.lastSentHeartbeatDate = n, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s;
    } catch (n) {
      return Gr.warn(n), "";
    }
  }
}
function sg() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function jR(t, e = VR) {
  const n = [];
  let r = t.slice();
  for (const i of t) {
    const s = n.find((o) => o.agent === i.agent);
    if (s) {
      if (s.dates.push(i.date), og(n) > e) {
        s.dates.pop();
        break;
      }
    } else if (n.push({
      agent: i.agent,
      dates: [i.date]
    }), og(n) > e) {
      n.pop();
      break;
    }
    r = r.slice(1);
  }
  return {
    heartbeatsToSend: n,
    unsentEntries: r
  };
}
class qR {
  constructor(e) {
    this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return CA() ? kA().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const n = await FR(this.app);
      return n != null && n.heartbeats ? n : { heartbeats: [] };
    } else
      return { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(e) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return ig(this.app, {
        lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
        heartbeats: e.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(e) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return ig(this.app, {
        lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
        heartbeats: [
          ...i.heartbeats,
          ...e.heartbeats
        ]
      });
    } else
      return;
  }
}
function og(t) {
  return kc(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: t })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zR(t) {
  bi(new Wr(
    "platform-logger",
    (e) => new nR(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), bi(new Wr(
    "heartbeat",
    (e) => new $R(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), $n(Dd, ng, t), $n(Dd, ng, "esm2017"), $n("fire-js", "");
}
zR("");
var WR = "firebase", GR = "10.14.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
$n(WR, GR, "app");
function Zf(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function Sv() {
  return {
    "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
  };
}
const HR = Sv, Av = new pa("auth", "Firebase", Sv());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Pc = new Qf("@firebase/auth");
function KR(t, ...e) {
  Pc.logLevel <= ze.WARN && Pc.warn(`Auth (${ls}): ${t}`, ...e);
}
function uc(t, ...e) {
  Pc.logLevel <= ze.ERROR && Pc.error(`Auth (${ls}): ${t}`, ...e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qn(t, ...e) {
  throw th(t, ...e);
}
function er(t, ...e) {
  return th(t, ...e);
}
function eh(t, e, n) {
  const r = Object.assign(Object.assign({}, HR()), { [e]: n });
  return new pa("auth", "Firebase", r).create(e, {
    appName: t.name
  });
}
function mr(t) {
  return eh(t, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp");
}
function YR(t, e, n) {
  const r = n;
  if (!(e instanceof r))
    throw r.name !== e.constructor.name && qn(
      t,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), eh(t, "argument-error", `Type of ${e.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`);
}
function th(t, ...e) {
  if (typeof t != "string") {
    const n = e[0], r = [...e.slice(1)];
    return r[0] && (r[0].appName = t.name), t._errorFactory.create(n, ...r);
  }
  return Av.create(t, ...e);
}
function we(t, e, ...n) {
  if (!t)
    throw th(e, ...n);
}
function Vr(t) {
  const e = "INTERNAL ASSERTION FAILED: " + t;
  throw uc(e), new Error(e);
}
function Hr(t, e) {
  t || Vr(e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Fd() {
  var t;
  return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.href) || "";
}
function XR() {
  return ag() === "http:" || ag() === "https:";
}
function ag() {
  var t;
  return typeof self < "u" && ((t = self.location) === null || t === void 0 ? void 0 : t.protocol) || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function QR() {
  return typeof navigator < "u" && navigator && "onLine" in navigator && typeof navigator.onLine == "boolean" && // Apply only for traditional web apps and Chrome extensions.
  // This is especially true for Cordova apps which have unreliable
  // navigator.onLine behavior unless cordova-plugin-network-information is
  // installed which overwrites the native navigator.onLine value and
  // defines navigator.connection.
  (XR() || IA() || "connection" in navigator) ? navigator.onLine : !0;
}
function JR() {
  if (typeof navigator > "u")
    return null;
  const t = navigator;
  return (
    // Most reliable, but only supported in Chrome/Firefox.
    t.languages && t.languages[0] || // Supported in most browsers, but returns the language of the browser
    // UI, not the language set in browser settings.
    t.language || // Couldn't determine language.
    null
  );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ya {
  constructor(e, n) {
    this.shortDelay = e, this.longDelay = n, Hr(n > e, "Short delay should be less than long delay!"), this.isMobile = EA() || SA();
  }
  get() {
    return QR() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nh(t, e) {
  Hr(t.emulator, "Emulator should always be set here");
  const { url: n } = t.emulator;
  return e ? `${n}${e.startsWith("/") ? e.slice(1) : e}` : n;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Rv {
  static initialize(e, n, r) {
    this.fetchImpl = e, n && (this.headersImpl = n), r && (this.responseImpl = r);
  }
  static fetch() {
    if (this.fetchImpl)
      return this.fetchImpl;
    if (typeof self < "u" && "fetch" in self)
      return self.fetch;
    if (typeof globalThis < "u" && globalThis.fetch)
      return globalThis.fetch;
    if (typeof fetch < "u")
      return fetch;
    Vr("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static headers() {
    if (this.headersImpl)
      return this.headersImpl;
    if (typeof self < "u" && "Headers" in self)
      return self.Headers;
    if (typeof globalThis < "u" && globalThis.Headers)
      return globalThis.Headers;
    if (typeof Headers < "u")
      return Headers;
    Vr("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static response() {
    if (this.responseImpl)
      return this.responseImpl;
    if (typeof self < "u" && "Response" in self)
      return self.Response;
    if (typeof globalThis < "u" && globalThis.Response)
      return globalThis.Response;
    if (typeof Response < "u")
      return Response;
    Vr("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ZR = {
  // Custom token errors.
  CREDENTIAL_MISMATCH: "custom-token-mismatch",
  // This can only happen if the SDK sends a bad request.
  MISSING_CUSTOM_TOKEN: "internal-error",
  // Create Auth URI errors.
  INVALID_IDENTIFIER: "invalid-email",
  // This can only happen if the SDK sends a bad request.
  MISSING_CONTINUE_URI: "internal-error",
  // Sign in with email and password errors (some apply to sign up too).
  INVALID_PASSWORD: "wrong-password",
  // This can only happen if the SDK sends a bad request.
  MISSING_PASSWORD: "missing-password",
  // Thrown if Email Enumeration Protection is enabled in the project and the email or password is
  // invalid.
  INVALID_LOGIN_CREDENTIALS: "invalid-credential",
  // Sign up with email and password errors.
  EMAIL_EXISTS: "email-already-in-use",
  PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
  // Verify assertion for sign in with credential errors:
  INVALID_IDP_RESPONSE: "invalid-credential",
  INVALID_PENDING_TOKEN: "invalid-credential",
  FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
  // This can only happen if the SDK sends a bad request.
  MISSING_REQ_TYPE: "internal-error",
  // Send Password reset email errors:
  EMAIL_NOT_FOUND: "user-not-found",
  RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
  EXPIRED_OOB_CODE: "expired-action-code",
  INVALID_OOB_CODE: "invalid-action-code",
  // This can only happen if the SDK sends a bad request.
  MISSING_OOB_CODE: "internal-error",
  // Operations that require ID token in request:
  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
  INVALID_ID_TOKEN: "invalid-user-token",
  TOKEN_EXPIRED: "user-token-expired",
  USER_NOT_FOUND: "user-token-expired",
  // Other errors.
  TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
  PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements",
  // Phone Auth related errors.
  INVALID_CODE: "invalid-verification-code",
  INVALID_SESSION_INFO: "invalid-verification-id",
  INVALID_TEMPORARY_PROOF: "invalid-credential",
  MISSING_SESSION_INFO: "missing-verification-id",
  SESSION_EXPIRED: "code-expired",
  // Other action code errors when additional settings passed.
  // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.
  // This is OK as this error will be caught by client side validation.
  MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
  UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
  // getProjectConfig errors when clientId is passed.
  INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
  // User actions (sign-up or deletion) disabled errors.
  ADMIN_ONLY_OPERATION: "admin-restricted-operation",
  // Multi factor related errors.
  INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
  MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
  MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
  MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
  SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
  SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
  // Blocking functions related errors.
  BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
  // Recaptcha related errors.
  RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
  MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
  INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
  INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
  MISSING_CLIENT_TYPE: "missing-client-type",
  MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
  INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
  INVALID_REQ_TYPE: "invalid-req-type"
  /* AuthErrorCode.INVALID_REQ_TYPE */
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const eC = new ya(3e4, 6e4);
function Jt(t, e) {
  return t.tenantId && !e.tenantId ? Object.assign(Object.assign({}, e), { tenantId: t.tenantId }) : e;
}
async function Rn(t, e, n, r, i = {}) {
  return Cv(t, i, async () => {
    let s = {}, o = {};
    r && (e === "GET" ? o = r : s = {
      body: JSON.stringify(r)
    });
    const a = ma(Object.assign({ key: t.config.apiKey }, o)).slice(1), l = await t._getAdditionalHeaders();
    l[
      "Content-Type"
      /* HttpHeader.CONTENT_TYPE */
    ] = "application/json", t.languageCode && (l[
      "X-Firebase-Locale"
      /* HttpHeader.X_FIREBASE_LOCALE */
    ] = t.languageCode);
    const u = Object.assign({
      method: e,
      headers: l
    }, s);
    return TA() || (u.referrerPolicy = "no-referrer"), Rv.fetch()(kv(t, t.config.apiHost, n, a), u);
  });
}
async function Cv(t, e, n) {
  t._canInitEmulator = !1;
  const r = Object.assign(Object.assign({}, ZR), e);
  try {
    const i = new nC(t), s = await Promise.race([
      n(),
      i.promise
    ]);
    i.clearNetworkTimeout();
    const o = await s.json();
    if ("needConfirmation" in o)
      throw Po(t, "account-exists-with-different-credential", o);
    if (s.ok && !("errorMessage" in o))
      return o;
    {
      const a = s.ok ? o.errorMessage : o.error.message, [l, u] = a.split(" : ");
      if (l === "FEDERATED_USER_ID_ALREADY_LINKED")
        throw Po(t, "credential-already-in-use", o);
      if (l === "EMAIL_EXISTS")
        throw Po(t, "email-already-in-use", o);
      if (l === "USER_DISABLED")
        throw Po(t, "user-disabled", o);
      const d = r[l] || l.toLowerCase().replace(/[_\s]+/g, "-");
      if (u)
        throw eh(t, d, u);
      qn(t, d);
    }
  } catch (i) {
    if (i instanceof rr)
      throw i;
    qn(t, "network-request-failed", { message: String(i) });
  }
}
async function Zr(t, e, n, r, i = {}) {
  const s = await Rn(t, e, n, r, i);
  return "mfaPendingCredential" in s && qn(t, "multi-factor-auth-required", {
    _serverResponse: s
  }), s;
}
function kv(t, e, n, r) {
  const i = `${e}${n}?${r}`;
  return t.config.emulator ? nh(t.config, i) : `${t.config.apiScheme}://${i}`;
}
function tC(t) {
  switch (t) {
    case "ENFORCE":
      return "ENFORCE";
    case "AUDIT":
      return "AUDIT";
    case "OFF":
      return "OFF";
    default:
      return "ENFORCEMENT_STATE_UNSPECIFIED";
  }
}
class nC {
  constructor(e) {
    this.auth = e, this.timer = null, this.promise = new Promise((n, r) => {
      this.timer = setTimeout(() => r(er(
        this.auth,
        "network-request-failed"
        /* AuthErrorCode.NETWORK_REQUEST_FAILED */
      )), eC.get());
    });
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer);
  }
}
function Po(t, e, n) {
  const r = {
    appName: t.name
  };
  n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber);
  const i = er(t, e, r);
  return i.customData._tokenResponse = n, i;
}
function cg(t) {
  return t !== void 0 && t.enterprise !== void 0;
}
class rC {
  constructor(e) {
    if (this.siteKey = "", this.recaptchaEnforcementState = [], e.recaptchaKey === void 0)
      throw new Error("recaptchaKey undefined");
    this.siteKey = e.recaptchaKey.split("/")[3], this.recaptchaEnforcementState = e.recaptchaEnforcementState;
  }
  /**
   * Returns the reCAPTCHA Enterprise enforcement state for the given provider.
   *
   * @param providerStr - The provider whose enforcement state is to be returned.
   * @returns The reCAPTCHA Enterprise enforcement state for the given provider.
   */
  getProviderEnforcementState(e) {
    if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0)
      return null;
    for (const n of this.recaptchaEnforcementState)
      if (n.provider && n.provider === e)
        return tC(n.enforcementState);
    return null;
  }
  /**
   * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.
   *
   * @param providerStr - The provider whose enablement state is to be returned.
   * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.
   */
  isProviderEnabled(e) {
    return this.getProviderEnforcementState(e) === "ENFORCE" || this.getProviderEnforcementState(e) === "AUDIT";
  }
}
async function iC(t, e) {
  return Rn(t, "GET", "/v2/recaptchaConfig", Jt(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sC(t, e) {
  return Rn(t, "POST", "/v1/accounts:delete", e);
}
async function Nv(t, e) {
  return Rn(t, "POST", "/v1/accounts:lookup", e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $o(t) {
  if (t)
    try {
      const e = new Date(Number(t));
      if (!isNaN(e.getTime()))
        return e.toUTCString();
    } catch {
    }
}
async function oC(t, e = !1) {
  const n = st(t), r = await n.getIdToken(e), i = rh(r);
  we(
    i && i.exp && i.auth_time && i.iat,
    n.auth,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  const s = typeof i.firebase == "object" ? i.firebase : void 0, o = s == null ? void 0 : s.sign_in_provider;
  return {
    claims: i,
    token: r,
    authTime: $o(hu(i.auth_time)),
    issuedAtTime: $o(hu(i.iat)),
    expirationTime: $o(hu(i.exp)),
    signInProvider: o || null,
    signInSecondFactor: (s == null ? void 0 : s.sign_in_second_factor) || null
  };
}
function hu(t) {
  return Number(t) * 1e3;
}
function rh(t) {
  const [e, n, r] = t.split(".");
  if (e === void 0 || n === void 0 || r === void 0)
    return uc("JWT malformed, contained fewer than 3 sections"), null;
  try {
    const i = gv(n);
    return i ? JSON.parse(i) : (uc("Failed to decode base64 JWT payload"), null);
  } catch (i) {
    return uc("Caught error parsing JWT payload as JSON", i == null ? void 0 : i.toString()), null;
  }
}
function lg(t) {
  const e = rh(t);
  return we(
    e,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), we(
    typeof e.exp < "u",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), we(
    typeof e.iat < "u",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), Number(e.exp) - Number(e.iat);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Jo(t, e, n = !1) {
  if (n)
    return e;
  try {
    return await e;
  } catch (r) {
    throw r instanceof rr && aC(r) && t.auth.currentUser === t && await t.auth.signOut(), r;
  }
}
function aC({ code: t }) {
  return t === "auth/user-disabled" || t === "auth/user-token-expired";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cC {
  constructor(e) {
    this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4;
  }
  _start() {
    this.isRunning || (this.isRunning = !0, this.schedule());
  }
  _stop() {
    this.isRunning && (this.isRunning = !1, this.timerId !== null && clearTimeout(this.timerId));
  }
  getInterval(e) {
    var n;
    if (e) {
      const r = this.errorBackoff;
      return this.errorBackoff = Math.min(
        this.errorBackoff * 2,
        96e4
        /* Duration.RETRY_BACKOFF_MAX */
      ), r;
    } else {
      this.errorBackoff = 3e4;
      const i = ((n = this.user.stsTokenManager.expirationTime) !== null && n !== void 0 ? n : 0) - Date.now() - 3e5;
      return Math.max(0, i);
    }
  }
  schedule(e = !1) {
    if (!this.isRunning)
      return;
    const n = this.getInterval(e);
    this.timerId = setTimeout(async () => {
      await this.iteration();
    }, n);
  }
  async iteration() {
    try {
      await this.user.getIdToken(!0);
    } catch (e) {
      (e == null ? void 0 : e.code) === "auth/network-request-failed" && this.schedule(
        /* wasError */
        !0
      );
      return;
    }
    this.schedule();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vd {
  constructor(e, n) {
    this.createdAt = e, this.lastLoginAt = n, this._initializeTime();
  }
  _initializeTime() {
    this.lastSignInTime = $o(this.lastLoginAt), this.creationTime = $o(this.createdAt);
  }
  _copy(e) {
    this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime();
  }
  toJSON() {
    return {
      createdAt: this.createdAt,
      lastLoginAt: this.lastLoginAt
    };
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function xc(t) {
  var e;
  const n = t.auth, r = await t.getIdToken(), i = await Jo(t, Nv(n, { idToken: r }));
  we(
    i == null ? void 0 : i.users.length,
    n,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  const s = i.users[0];
  t._notifyReloadListener(s);
  const o = !((e = s.providerUserInfo) === null || e === void 0) && e.length ? Ov(s.providerUserInfo) : [], a = uC(t.providerData, o), l = t.isAnonymous, u = !(t.email && s.passwordHash) && !(a != null && a.length), d = l ? u : !1, f = {
    uid: s.localId,
    displayName: s.displayName || null,
    photoURL: s.photoUrl || null,
    email: s.email || null,
    emailVerified: s.emailVerified || !1,
    phoneNumber: s.phoneNumber || null,
    tenantId: s.tenantId || null,
    providerData: a,
    metadata: new Vd(s.createdAt, s.lastLoginAt),
    isAnonymous: d
  };
  Object.assign(t, f);
}
async function lC(t) {
  const e = st(t);
  await xc(e), await e.auth._persistUserIfCurrent(e), e.auth._notifyListenersIfCurrent(e);
}
function uC(t, e) {
  return [...t.filter((r) => !e.some((i) => i.providerId === r.providerId)), ...e];
}
function Ov(t) {
  return t.map((e) => {
    var { providerId: n } = e, r = Zf(e, ["providerId"]);
    return {
      providerId: n,
      uid: r.rawId || "",
      displayName: r.displayName || null,
      email: r.email || null,
      phoneNumber: r.phoneNumber || null,
      photoURL: r.photoUrl || null
    };
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function dC(t, e) {
  const n = await Cv(t, {}, async () => {
    const r = ma({
      grant_type: "refresh_token",
      refresh_token: e
    }).slice(1), { tokenApiHost: i, apiKey: s } = t.config, o = kv(t, i, "/v1/token", `key=${s}`), a = await t._getAdditionalHeaders();
    return a[
      "Content-Type"
      /* HttpHeader.CONTENT_TYPE */
    ] = "application/x-www-form-urlencoded", Rv.fetch()(o, {
      method: "POST",
      headers: a,
      body: r
    });
  });
  return {
    accessToken: n.access_token,
    expiresIn: n.expires_in,
    refreshToken: n.refresh_token
  };
}
async function fC(t, e) {
  return Rn(t, "POST", "/v2/accounts:revokeToken", Jt(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Os {
  constructor() {
    this.refreshToken = null, this.accessToken = null, this.expirationTime = null;
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
  }
  updateFromServerResponse(e) {
    we(
      e.idToken,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), we(
      typeof e.idToken < "u",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), we(
      typeof e.refreshToken < "u",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const n = "expiresIn" in e && typeof e.expiresIn < "u" ? Number(e.expiresIn) : lg(e.idToken);
    this.updateTokensAndExpiration(e.idToken, e.refreshToken, n);
  }
  updateFromIdToken(e) {
    we(
      e.length !== 0,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const n = lg(e);
    this.updateTokensAndExpiration(e, null, n);
  }
  async getToken(e, n = !1) {
    return !n && this.accessToken && !this.isExpired ? this.accessToken : (we(
      this.refreshToken,
      e,
      "user-token-expired"
      /* AuthErrorCode.TOKEN_EXPIRED */
    ), this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null);
  }
  clearRefreshToken() {
    this.refreshToken = null;
  }
  async refresh(e, n) {
    const { accessToken: r, refreshToken: i, expiresIn: s } = await dC(e, n);
    this.updateTokensAndExpiration(r, i, Number(s));
  }
  updateTokensAndExpiration(e, n, r) {
    this.refreshToken = n || null, this.accessToken = e || null, this.expirationTime = Date.now() + r * 1e3;
  }
  static fromJSON(e, n) {
    const { refreshToken: r, accessToken: i, expirationTime: s } = n, o = new Os();
    return r && (we(typeof r == "string", "internal-error", {
      appName: e
    }), o.refreshToken = r), i && (we(typeof i == "string", "internal-error", {
      appName: e
    }), o.accessToken = i), s && (we(typeof s == "number", "internal-error", {
      appName: e
    }), o.expirationTime = s), o;
  }
  toJSON() {
    return {
      refreshToken: this.refreshToken,
      accessToken: this.accessToken,
      expirationTime: this.expirationTime
    };
  }
  _assign(e) {
    this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime;
  }
  _clone() {
    return Object.assign(new Os(), this.toJSON());
  }
  _performRefresh() {
    return Vr("not implemented");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ii(t, e) {
  we(typeof t == "string" || typeof t > "u", "internal-error", { appName: e });
}
class Br {
  constructor(e) {
    var { uid: n, auth: r, stsTokenManager: i } = e, s = Zf(e, ["uid", "auth", "stsTokenManager"]);
    this.providerId = "firebase", this.proactiveRefresh = new cC(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = n, this.auth = r, this.stsTokenManager = i, this.accessToken = i.accessToken, this.displayName = s.displayName || null, this.email = s.email || null, this.emailVerified = s.emailVerified || !1, this.phoneNumber = s.phoneNumber || null, this.photoURL = s.photoURL || null, this.isAnonymous = s.isAnonymous || !1, this.tenantId = s.tenantId || null, this.providerData = s.providerData ? [...s.providerData] : [], this.metadata = new Vd(s.createdAt || void 0, s.lastLoginAt || void 0);
  }
  async getIdToken(e) {
    const n = await Jo(this, this.stsTokenManager.getToken(this.auth, e));
    return we(
      n,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.accessToken !== n && (this.accessToken = n, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), n;
  }
  getIdTokenResult(e) {
    return oC(this, e);
  }
  reload() {
    return lC(this);
  }
  _assign(e) {
    this !== e && (we(
      this.uid === e.uid,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map((n) => Object.assign({}, n)), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager));
  }
  _clone(e) {
    const n = new Br(Object.assign(Object.assign({}, this), { auth: e, stsTokenManager: this.stsTokenManager._clone() }));
    return n.metadata._copy(this.metadata), n;
  }
  _onReload(e) {
    we(
      !this.reloadListener,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null);
  }
  _notifyReloadListener(e) {
    this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e;
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start();
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop();
  }
  async _updateTokensIfNecessary(e, n = !1) {
    let r = !1;
    e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), r = !0), n && await xc(this), await this.auth._persistUserIfCurrent(this), r && this.auth._notifyListenersIfCurrent(this);
  }
  async delete() {
    if (Bn(this.auth.app))
      return Promise.reject(mr(this.auth));
    const e = await this.getIdToken();
    return await Jo(this, sC(this.auth, { idToken: e })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut();
  }
  toJSON() {
    return Object.assign(Object.assign({
      uid: this.uid,
      email: this.email || void 0,
      emailVerified: this.emailVerified,
      displayName: this.displayName || void 0,
      isAnonymous: this.isAnonymous,
      photoURL: this.photoURL || void 0,
      phoneNumber: this.phoneNumber || void 0,
      tenantId: this.tenantId || void 0,
      providerData: this.providerData.map((e) => Object.assign({}, e)),
      stsTokenManager: this.stsTokenManager.toJSON(),
      // Redirect event ID must be maintained in case there is a pending
      // redirect event.
      _redirectEventId: this._redirectEventId
    }, this.metadata.toJSON()), {
      // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
      apiKey: this.auth.config.apiKey,
      appName: this.auth.name
    });
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || "";
  }
  static _fromJSON(e, n) {
    var r, i, s, o, a, l, u, d;
    const f = (r = n.displayName) !== null && r !== void 0 ? r : void 0, p = (i = n.email) !== null && i !== void 0 ? i : void 0, g = (s = n.phoneNumber) !== null && s !== void 0 ? s : void 0, _ = (o = n.photoURL) !== null && o !== void 0 ? o : void 0, b = (a = n.tenantId) !== null && a !== void 0 ? a : void 0, m = (l = n._redirectEventId) !== null && l !== void 0 ? l : void 0, v = (u = n.createdAt) !== null && u !== void 0 ? u : void 0, C = (d = n.lastLoginAt) !== null && d !== void 0 ? d : void 0, { uid: x, emailVerified: P, isAnonymous: k, providerData: U, stsTokenManager: I } = n;
    we(
      x && I,
      e,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const E = Os.fromJSON(this.name, I);
    we(
      typeof x == "string",
      e,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), ii(f, e.name), ii(p, e.name), we(
      typeof P == "boolean",
      e,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), we(
      typeof k == "boolean",
      e,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), ii(g, e.name), ii(_, e.name), ii(b, e.name), ii(m, e.name), ii(v, e.name), ii(C, e.name);
    const T = new Br({
      uid: x,
      auth: e,
      email: p,
      emailVerified: P,
      displayName: f,
      isAnonymous: k,
      photoURL: _,
      phoneNumber: g,
      tenantId: b,
      stsTokenManager: E,
      createdAt: v,
      lastLoginAt: C
    });
    return U && Array.isArray(U) && (T.providerData = U.map((A) => Object.assign({}, A))), m && (T._redirectEventId = m), T;
  }
  /**
   * Initialize a User from an idToken server response
   * @param auth
   * @param idTokenResponse
   */
  static async _fromIdTokenResponse(e, n, r = !1) {
    const i = new Os();
    i.updateFromServerResponse(n);
    const s = new Br({
      uid: n.localId,
      auth: e,
      stsTokenManager: i,
      isAnonymous: r
    });
    return await xc(s), s;
  }
  /**
   * Initialize a User from an idToken server response
   * @param auth
   * @param idTokenResponse
   */
  static async _fromGetAccountInfoResponse(e, n, r) {
    const i = n.users[0];
    we(
      i.localId !== void 0,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const s = i.providerUserInfo !== void 0 ? Ov(i.providerUserInfo) : [], o = !(i.email && i.passwordHash) && !(s != null && s.length), a = new Os();
    a.updateFromIdToken(r);
    const l = new Br({
      uid: i.localId,
      auth: e,
      stsTokenManager: a,
      isAnonymous: o
    }), u = {
      uid: i.localId,
      displayName: i.displayName || null,
      photoURL: i.photoUrl || null,
      email: i.email || null,
      emailVerified: i.emailVerified || !1,
      phoneNumber: i.phoneNumber || null,
      tenantId: i.tenantId || null,
      providerData: s,
      metadata: new Vd(i.createdAt, i.lastLoginAt),
      isAnonymous: !(i.email && i.passwordHash) && !(s != null && s.length)
    };
    return Object.assign(l, u), l;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ug = /* @__PURE__ */ new Map();
function $r(t) {
  Hr(t instanceof Function, "Expected a class definition");
  let e = ug.get(t);
  return e ? (Hr(e instanceof t, "Instance stored in cache mismatched with class"), e) : (e = new t(), ug.set(t, e), e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pv {
  constructor() {
    this.type = "NONE", this.storage = {};
  }
  async _isAvailable() {
    return !0;
  }
  async _set(e, n) {
    this.storage[e] = n;
  }
  async _get(e) {
    const n = this.storage[e];
    return n === void 0 ? null : n;
  }
  async _remove(e) {
    delete this.storage[e];
  }
  _addListener(e, n) {
  }
  _removeListener(e, n) {
  }
}
Pv.type = "NONE";
const dg = Pv;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function dc(t, e, n) {
  return `firebase:${t}:${e}:${n}`;
}
class Ps {
  constructor(e, n, r) {
    this.persistence = e, this.auth = n, this.userKey = r;
    const { config: i, name: s } = this.auth;
    this.fullUserKey = dc(this.userKey, i.apiKey, s), this.fullPersistenceKey = dc("persistence", i.apiKey, s), this.boundEventHandler = n._onStorageEvent.bind(n), this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
  }
  setCurrentUser(e) {
    return this.persistence._set(this.fullUserKey, e.toJSON());
  }
  async getCurrentUser() {
    const e = await this.persistence._get(this.fullUserKey);
    return e ? Br._fromJSON(this.auth, e) : null;
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey);
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
  }
  async setPersistence(e) {
    if (this.persistence === e)
      return;
    const n = await this.getCurrentUser();
    if (await this.removeCurrentUser(), this.persistence = e, n)
      return this.setCurrentUser(n);
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
  }
  static async create(e, n, r = "authUser") {
    if (!n.length)
      return new Ps($r(dg), e, r);
    const i = (await Promise.all(n.map(async (u) => {
      if (await u._isAvailable())
        return u;
    }))).filter((u) => u);
    let s = i[0] || $r(dg);
    const o = dc(r, e.config.apiKey, e.name);
    let a = null;
    for (const u of n)
      try {
        const d = await u._get(o);
        if (d) {
          const f = Br._fromJSON(e, d);
          u !== s && (a = f), s = u;
          break;
        }
      } catch {
      }
    const l = i.filter((u) => u._shouldAllowMigration);
    return !s._shouldAllowMigration || !l.length ? new Ps(s, e, r) : (s = l[0], a && await s._set(o, a.toJSON()), await Promise.all(n.map(async (u) => {
      if (u !== s)
        try {
          await u._remove(o);
        } catch {
        }
    })), new Ps(s, e, r));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fg(t) {
  const e = t.toLowerCase();
  if (e.includes("opera/") || e.includes("opr/") || e.includes("opios/"))
    return "Opera";
  if (Lv(e))
    return "IEMobile";
  if (e.includes("msie") || e.includes("trident/"))
    return "IE";
  if (e.includes("edge/"))
    return "Edge";
  if (xv(e))
    return "Firefox";
  if (e.includes("silk/"))
    return "Silk";
  if (Fv(e))
    return "Blackberry";
  if (Vv(e))
    return "Webos";
  if (Mv(e))
    return "Safari";
  if ((e.includes("chrome/") || Dv(e)) && !e.includes("edge/"))
    return "Chrome";
  if (Uv(e))
    return "Android";
  {
    const n = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/, r = t.match(n);
    if ((r == null ? void 0 : r.length) === 2)
      return r[1];
  }
  return "Other";
}
function xv(t = cn()) {
  return /firefox\//i.test(t);
}
function Mv(t = cn()) {
  const e = t.toLowerCase();
  return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android");
}
function Dv(t = cn()) {
  return /crios\//i.test(t);
}
function Lv(t = cn()) {
  return /iemobile/i.test(t);
}
function Uv(t = cn()) {
  return /android/i.test(t);
}
function Fv(t = cn()) {
  return /blackberry/i.test(t);
}
function Vv(t = cn()) {
  return /webos/i.test(t);
}
function ih(t = cn()) {
  return /iphone|ipad|ipod/i.test(t) || /macintosh/i.test(t) && /mobile/i.test(t);
}
function hC(t = cn()) {
  var e;
  return ih(t) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone);
}
function pC() {
  return AA() && document.documentMode === 10;
}
function Bv(t = cn()) {
  return ih(t) || Uv(t) || Vv(t) || Fv(t) || /windows phone/i.test(t) || Lv(t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $v(t, e = []) {
  let n;
  switch (t) {
    case "Browser":
      n = fg(cn());
      break;
    case "Worker":
      n = `${fg(cn())}-${t}`;
      break;
    default:
      n = t;
  }
  const r = e.length ? e.join(",") : "FirebaseCore-web";
  return `${n}/JsCore/${ls}/${r}`;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mC {
  constructor(e) {
    this.auth = e, this.queue = [];
  }
  pushCallback(e, n) {
    const r = (s) => new Promise((o, a) => {
      try {
        const l = e(s);
        o(l);
      } catch (l) {
        a(l);
      }
    });
    r.onAbort = n, this.queue.push(r);
    const i = this.queue.length - 1;
    return () => {
      this.queue[i] = () => Promise.resolve();
    };
  }
  async runMiddleware(e) {
    if (this.auth.currentUser === e)
      return;
    const n = [];
    try {
      for (const r of this.queue)
        await r(e), r.onAbort && n.push(r.onAbort);
    } catch (r) {
      n.reverse();
      for (const i of n)
        try {
          i();
        } catch {
        }
      throw this.auth._errorFactory.create("login-blocked", {
        originalMessage: r == null ? void 0 : r.message
      });
    }
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function gC(t, e = {}) {
  return Rn(t, "GET", "/v2/passwordPolicy", Jt(t, e));
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yC = 6;
class _C {
  constructor(e) {
    var n, r, i, s;
    const o = e.customStrengthOptions;
    this.customStrengthOptions = {}, this.customStrengthOptions.minPasswordLength = (n = o.minPasswordLength) !== null && n !== void 0 ? n : yC, o.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = o.maxPasswordLength), o.containsLowercaseCharacter !== void 0 && (this.customStrengthOptions.containsLowercaseLetter = o.containsLowercaseCharacter), o.containsUppercaseCharacter !== void 0 && (this.customStrengthOptions.containsUppercaseLetter = o.containsUppercaseCharacter), o.containsNumericCharacter !== void 0 && (this.customStrengthOptions.containsNumericCharacter = o.containsNumericCharacter), o.containsNonAlphanumericCharacter !== void 0 && (this.customStrengthOptions.containsNonAlphanumericCharacter = o.containsNonAlphanumericCharacter), this.enforcementState = e.enforcementState, this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED" && (this.enforcementState = "OFF"), this.allowedNonAlphanumericCharacters = (i = (r = e.allowedNonAlphanumericCharacters) === null || r === void 0 ? void 0 : r.join("")) !== null && i !== void 0 ? i : "", this.forceUpgradeOnSignin = (s = e.forceUpgradeOnSignin) !== null && s !== void 0 ? s : !1, this.schemaVersion = e.schemaVersion;
  }
  validatePassword(e) {
    var n, r, i, s, o, a;
    const l = {
      isValid: !0,
      passwordPolicy: this
    };
    return this.validatePasswordLengthOptions(e, l), this.validatePasswordCharacterOptions(e, l), l.isValid && (l.isValid = (n = l.meetsMinPasswordLength) !== null && n !== void 0 ? n : !0), l.isValid && (l.isValid = (r = l.meetsMaxPasswordLength) !== null && r !== void 0 ? r : !0), l.isValid && (l.isValid = (i = l.containsLowercaseLetter) !== null && i !== void 0 ? i : !0), l.isValid && (l.isValid = (s = l.containsUppercaseLetter) !== null && s !== void 0 ? s : !0), l.isValid && (l.isValid = (o = l.containsNumericCharacter) !== null && o !== void 0 ? o : !0), l.isValid && (l.isValid = (a = l.containsNonAlphanumericCharacter) !== null && a !== void 0 ? a : !0), l;
  }
  /**
   * Validates that the password meets the length options for the policy.
   *
   * @param password Password to validate.
   * @param status Validation status.
   */
  validatePasswordLengthOptions(e, n) {
    const r = this.customStrengthOptions.minPasswordLength, i = this.customStrengthOptions.maxPasswordLength;
    r && (n.meetsMinPasswordLength = e.length >= r), i && (n.meetsMaxPasswordLength = e.length <= i);
  }
  /**
   * Validates that the password meets the character options for the policy.
   *
   * @param password Password to validate.
   * @param status Validation status.
   */
  validatePasswordCharacterOptions(e, n) {
    this.updatePasswordCharacterOptionsStatuses(
      n,
      /* containsLowercaseCharacter= */
      !1,
      /* containsUppercaseCharacter= */
      !1,
      /* containsNumericCharacter= */
      !1,
      /* containsNonAlphanumericCharacter= */
      !1
    );
    let r;
    for (let i = 0; i < e.length; i++)
      r = e.charAt(i), this.updatePasswordCharacterOptionsStatuses(
        n,
        /* containsLowercaseCharacter= */
        r >= "a" && r <= "z",
        /* containsUppercaseCharacter= */
        r >= "A" && r <= "Z",
        /* containsNumericCharacter= */
        r >= "0" && r <= "9",
        /* containsNonAlphanumericCharacter= */
        this.allowedNonAlphanumericCharacters.includes(r)
      );
  }
  /**
   * Updates the running validation status with the statuses for the character options.
   * Expected to be called each time a character is processed to update each option status
   * based on the current character.
   *
   * @param status Validation status.
   * @param containsLowercaseCharacter Whether the character is a lowercase letter.
   * @param containsUppercaseCharacter Whether the character is an uppercase letter.
   * @param containsNumericCharacter Whether the character is a numeric character.
   * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.
   */
  updatePasswordCharacterOptionsStatuses(e, n, r, i, s) {
    this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = n)), this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = r)), this.customStrengthOptions.containsNumericCharacter && (e.containsNumericCharacter || (e.containsNumericCharacter = i)), this.customStrengthOptions.containsNonAlphanumericCharacter && (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = s));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bC {
  constructor(e, n, r, i) {
    this.app = e, this.heartbeatServiceProvider = n, this.appCheckServiceProvider = r, this.config = i, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new hg(this), this.idTokenSubscription = new hg(this), this.beforeStateQueue = new mC(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = Av, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this._projectPasswordPolicy = null, this._tenantPasswordPolicies = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = e.name, this.clientVersion = i.sdkClientVersion;
  }
  _initializeWithPersistence(e, n) {
    return n && (this._popupRedirectResolver = $r(n)), this._initializationPromise = this.queue(async () => {
      var r, i;
      if (!this._deleted && (this.persistenceManager = await Ps.create(this, e), !this._deleted)) {
        if (!((r = this._popupRedirectResolver) === null || r === void 0) && r._shouldInitProactively)
          try {
            await this._popupRedirectResolver._initialize(this);
          } catch {
          }
        await this.initializeCurrentUser(n), this.lastNotifiedUid = ((i = this.currentUser) === null || i === void 0 ? void 0 : i.uid) || null, !this._deleted && (this._isInitialized = !0);
      }
    }), this._initializationPromise;
  }
  /**
   * If the persistence is changed in another window, the user manager will let us know
   */
  async _onStorageEvent() {
    if (this._deleted)
      return;
    const e = await this.assertedPersistence.getCurrentUser();
    if (!(!this.currentUser && !e)) {
      if (this.currentUser && e && this.currentUser.uid === e.uid) {
        this._currentUser._assign(e), await this.currentUser.getIdToken();
        return;
      }
      await this._updateCurrentUser(
        e,
        /* skipBeforeStateCallbacks */
        !0
      );
    }
  }
  async initializeCurrentUserFromIdToken(e) {
    try {
      const n = await Nv(this, { idToken: e }), r = await Br._fromGetAccountInfoResponse(this, n, e);
      await this.directlySetCurrentUser(r);
    } catch (n) {
      console.warn("FirebaseServerApp could not login user with provided authIdToken: ", n), await this.directlySetCurrentUser(null);
    }
  }
  async initializeCurrentUser(e) {
    var n;
    if (Bn(this.app)) {
      const o = this.app.settings.authIdToken;
      return o ? new Promise((a) => {
        setTimeout(() => this.initializeCurrentUserFromIdToken(o).then(a, a));
      }) : this.directlySetCurrentUser(null);
    }
    const r = await this.assertedPersistence.getCurrentUser();
    let i = r, s = !1;
    if (e && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager();
      const o = (n = this.redirectUser) === null || n === void 0 ? void 0 : n._redirectEventId, a = i == null ? void 0 : i._redirectEventId, l = await this.tryRedirectSignIn(e);
      (!o || o === a) && (l != null && l.user) && (i = l.user, s = !0);
    }
    if (!i)
      return this.directlySetCurrentUser(null);
    if (!i._redirectEventId) {
      if (s)
        try {
          await this.beforeStateQueue.runMiddleware(i);
        } catch (o) {
          i = r, this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(o));
        }
      return i ? this.reloadAndSetCurrentUserOrClear(i) : this.directlySetCurrentUser(null);
    }
    return we(
      this._popupRedirectResolver,
      this,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === i._redirectEventId ? this.directlySetCurrentUser(i) : this.reloadAndSetCurrentUserOrClear(i);
  }
  async tryRedirectSignIn(e) {
    let n = null;
    try {
      n = await this._popupRedirectResolver._completeRedirectFn(this, e, !0);
    } catch {
      await this._setRedirectUser(null);
    }
    return n;
  }
  async reloadAndSetCurrentUserOrClear(e) {
    try {
      await xc(e);
    } catch (n) {
      if ((n == null ? void 0 : n.code) !== "auth/network-request-failed")
        return this.directlySetCurrentUser(null);
    }
    return this.directlySetCurrentUser(e);
  }
  useDeviceLanguage() {
    this.languageCode = JR();
  }
  async _delete() {
    this._deleted = !0;
  }
  async updateCurrentUser(e) {
    if (Bn(this.app))
      return Promise.reject(mr(this));
    const n = e ? st(e) : null;
    return n && we(
      n.auth.config.apiKey === this.config.apiKey,
      this,
      "invalid-user-token"
      /* AuthErrorCode.INVALID_AUTH */
    ), this._updateCurrentUser(n && n._clone(this));
  }
  async _updateCurrentUser(e, n = !1) {
    if (!this._deleted)
      return e && we(
        this.tenantId === e.tenantId,
        this,
        "tenant-id-mismatch"
        /* AuthErrorCode.TENANT_ID_MISMATCH */
      ), n || await this.beforeStateQueue.runMiddleware(e), this.queue(async () => {
        await this.directlySetCurrentUser(e), this.notifyAuthListeners();
      });
  }
  async signOut() {
    return Bn(this.app) ? Promise.reject(mr(this)) : (await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(
      null,
      /* skipBeforeStateCallbacks */
      !0
    ));
  }
  setPersistence(e) {
    return Bn(this.app) ? Promise.reject(mr(this)) : this.queue(async () => {
      await this.assertedPersistence.setPersistence($r(e));
    });
  }
  _getRecaptchaConfig() {
    return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId];
  }
  async validatePassword(e) {
    this._getPasswordPolicyInternal() || await this._updatePasswordPolicy();
    const n = this._getPasswordPolicyInternal();
    return n.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {})) : n.validatePassword(e);
  }
  _getPasswordPolicyInternal() {
    return this.tenantId === null ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId];
  }
  async _updatePasswordPolicy() {
    const e = await gC(this), n = new _C(e);
    this.tenantId === null ? this._projectPasswordPolicy = n : this._tenantPasswordPolicies[this.tenantId] = n;
  }
  _getPersistence() {
    return this.assertedPersistence.persistence.type;
  }
  _updateErrorMap(e) {
    this._errorFactory = new pa("auth", "Firebase", e());
  }
  onAuthStateChanged(e, n, r) {
    return this.registerStateListener(this.authStateSubscription, e, n, r);
  }
  beforeAuthStateChanged(e, n) {
    return this.beforeStateQueue.pushCallback(e, n);
  }
  onIdTokenChanged(e, n, r) {
    return this.registerStateListener(this.idTokenSubscription, e, n, r);
  }
  authStateReady() {
    return new Promise((e, n) => {
      if (this.currentUser)
        e();
      else {
        const r = this.onAuthStateChanged(() => {
          r(), e();
        }, n);
      }
    });
  }
  /**
   * Revokes the given access token. Currently only supports Apple OAuth access tokens.
   */
  async revokeAccessToken(e) {
    if (this.currentUser) {
      const n = await this.currentUser.getIdToken(), r = {
        providerId: "apple.com",
        tokenType: "ACCESS_TOKEN",
        token: e,
        idToken: n
      };
      this.tenantId != null && (r.tenantId = this.tenantId), await fC(this, r);
    }
  }
  toJSON() {
    var e;
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON()
    };
  }
  async _setRedirectUser(e, n) {
    const r = await this.getOrInitRedirectPersistenceManager(n);
    return e === null ? r.removeCurrentUser() : r.setCurrentUser(e);
  }
  async getOrInitRedirectPersistenceManager(e) {
    if (!this.redirectPersistenceManager) {
      const n = e && $r(e) || this._popupRedirectResolver;
      we(
        n,
        this,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      ), this.redirectPersistenceManager = await Ps.create(
        this,
        [$r(n._redirectPersistence)],
        "redirectUser"
        /* KeyName.REDIRECT_USER */
      ), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
    }
    return this.redirectPersistenceManager;
  }
  async _redirectUserForId(e) {
    var n, r;
    return this._isInitialized && await this.queue(async () => {
    }), ((n = this._currentUser) === null || n === void 0 ? void 0 : n._redirectEventId) === e ? this._currentUser : ((r = this.redirectUser) === null || r === void 0 ? void 0 : r._redirectEventId) === e ? this.redirectUser : null;
  }
  async _persistUserIfCurrent(e) {
    if (e === this.currentUser)
      return this.queue(async () => this.directlySetCurrentUser(e));
  }
  /** Notifies listeners only if the user is current */
  _notifyListenersIfCurrent(e) {
    e === this.currentUser && this.notifyAuthListeners();
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
  }
  _startProactiveRefresh() {
    this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh();
  }
  _stopProactiveRefresh() {
    this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh();
  }
  /** Returns the current user cast as the internal type */
  get _currentUser() {
    return this.currentUser;
  }
  notifyAuthListeners() {
    var e, n;
    if (!this._isInitialized)
      return;
    this.idTokenSubscription.next(this.currentUser);
    const r = (n = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null && n !== void 0 ? n : null;
    this.lastNotifiedUid !== r && (this.lastNotifiedUid = r, this.authStateSubscription.next(this.currentUser));
  }
  registerStateListener(e, n, r, i) {
    if (this._deleted)
      return () => {
      };
    const s = typeof n == "function" ? n : n.next.bind(n);
    let o = !1;
    const a = this._isInitialized ? Promise.resolve() : this._initializationPromise;
    if (we(
      a,
      this,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), a.then(() => {
      o || s(this.currentUser);
    }), typeof n == "function") {
      const l = e.addObserver(n, r, i);
      return () => {
        o = !0, l();
      };
    } else {
      const l = e.addObserver(n);
      return () => {
        o = !0, l();
      };
    }
  }
  /**
   * Unprotected (from race conditions) method to set the current user. This
   * should only be called from within a queued callback. This is necessary
   * because the queue shouldn't rely on another queued callback.
   */
  async directlySetCurrentUser(e) {
    this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser();
  }
  queue(e) {
    return this.operations = this.operations.then(e, e), this.operations;
  }
  get assertedPersistence() {
    return we(
      this.persistenceManager,
      this,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.persistenceManager;
  }
  _logFramework(e) {
    !e || this.frameworks.includes(e) || (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = $v(this.config.clientPlatform, this._getFrameworks()));
  }
  _getFrameworks() {
    return this.frameworks;
  }
  async _getAdditionalHeaders() {
    var e;
    const n = {
      "X-Client-Version": this.clientVersion
    };
    this.app.options.appId && (n[
      "X-Firebase-gmpid"
      /* HttpHeader.X_FIREBASE_GMPID */
    ] = this.app.options.appId);
    const r = await ((e = this.heartbeatServiceProvider.getImmediate({
      optional: !0
    })) === null || e === void 0 ? void 0 : e.getHeartbeatsHeader());
    r && (n[
      "X-Firebase-Client"
      /* HttpHeader.X_FIREBASE_CLIENT */
    ] = r);
    const i = await this._getAppCheckToken();
    return i && (n[
      "X-Firebase-AppCheck"
      /* HttpHeader.X_FIREBASE_APP_CHECK */
    ] = i), n;
  }
  async _getAppCheckToken() {
    var e;
    const n = await ((e = this.appCheckServiceProvider.getImmediate({ optional: !0 })) === null || e === void 0 ? void 0 : e.getToken());
    return n != null && n.error && KR(`Error while retrieving App Check token: ${n.error}`), n == null ? void 0 : n.token;
  }
}
function ir(t) {
  return st(t);
}
class hg {
  constructor(e) {
    this.auth = e, this.observer = null, this.addObserver = MA((n) => this.observer = n);
  }
  get next() {
    return we(
      this.observer,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), this.observer.next.bind(this.observer);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let hl = {
  async loadJS() {
    throw new Error("Unable to load external scripts");
  },
  recaptchaV2Script: "",
  recaptchaEnterpriseScript: "",
  gapiScript: ""
};
function vC(t) {
  hl = t;
}
function jv(t) {
  return hl.loadJS(t);
}
function EC() {
  return hl.recaptchaEnterpriseScript;
}
function wC() {
  return hl.gapiScript;
}
function TC(t) {
  return `__${t}${Math.floor(Math.random() * 1e6)}`;
}
const IC = "recaptcha-enterprise", SC = "NO_RECAPTCHA";
class AC {
  /**
   *
   * @param authExtern - The corresponding Firebase {@link Auth} instance.
   *
   */
  constructor(e) {
    this.type = IC, this.auth = ir(e);
  }
  /**
   * Executes the verification process.
   *
   * @returns A Promise for a token that can be used to assert the validity of a request.
   */
  async verify(e = "verify", n = !1) {
    async function r(s) {
      if (!n) {
        if (s.tenantId == null && s._agentRecaptchaConfig != null)
          return s._agentRecaptchaConfig.siteKey;
        if (s.tenantId != null && s._tenantRecaptchaConfigs[s.tenantId] !== void 0)
          return s._tenantRecaptchaConfigs[s.tenantId].siteKey;
      }
      return new Promise(async (o, a) => {
        iC(s, {
          clientType: "CLIENT_TYPE_WEB",
          version: "RECAPTCHA_ENTERPRISE"
          /* RecaptchaVersion.ENTERPRISE */
        }).then((l) => {
          if (l.recaptchaKey === void 0)
            a(new Error("recaptcha Enterprise site key undefined"));
          else {
            const u = new rC(l);
            return s.tenantId == null ? s._agentRecaptchaConfig = u : s._tenantRecaptchaConfigs[s.tenantId] = u, o(u.siteKey);
          }
        }).catch((l) => {
          a(l);
        });
      });
    }
    function i(s, o, a) {
      const l = window.grecaptcha;
      cg(l) ? l.enterprise.ready(() => {
        l.enterprise.execute(s, { action: e }).then((u) => {
          o(u);
        }).catch(() => {
          o(SC);
        });
      }) : a(Error("No reCAPTCHA enterprise script loaded."));
    }
    return new Promise((s, o) => {
      r(this.auth).then((a) => {
        if (!n && cg(window.grecaptcha))
          i(a, s, o);
        else {
          if (typeof window > "u") {
            o(new Error("RecaptchaVerifier is only supported in browser"));
            return;
          }
          let l = EC();
          l.length !== 0 && (l += a), jv(l).then(() => {
            i(a, s, o);
          }).catch((u) => {
            o(u);
          });
        }
      }).catch((a) => {
        o(a);
      });
    });
  }
}
async function pg(t, e, n, r = !1) {
  const i = new AC(t);
  let s;
  try {
    s = await i.verify(n);
  } catch {
    s = await i.verify(n, !0);
  }
  const o = Object.assign({}, e);
  return r ? Object.assign(o, { captchaResp: s }) : Object.assign(o, { captchaResponse: s }), Object.assign(o, {
    clientType: "CLIENT_TYPE_WEB"
    /* RecaptchaClientType.WEB */
  }), Object.assign(o, {
    recaptchaVersion: "RECAPTCHA_ENTERPRISE"
    /* RecaptchaVersion.ENTERPRISE */
  }), o;
}
async function Mc(t, e, n, r) {
  var i;
  if (!((i = t._getRecaptchaConfig()) === null || i === void 0) && i.isProviderEnabled(
    "EMAIL_PASSWORD_PROVIDER"
    /* RecaptchaProvider.EMAIL_PASSWORD_PROVIDER */
  )) {
    const s = await pg(
      t,
      e,
      n,
      n === "getOobCode"
      /* RecaptchaActionName.GET_OOB_CODE */
    );
    return r(t, s);
  } else
    return r(t, e).catch(async (s) => {
      if (s.code === "auth/missing-recaptcha-token") {
        console.log(`${n} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);
        const o = await pg(
          t,
          e,
          n,
          n === "getOobCode"
          /* RecaptchaActionName.GET_OOB_CODE */
        );
        return r(t, o);
      } else
        return Promise.reject(s);
    });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function RC(t, e) {
  const n = ga(t, "auth");
  if (n.isInitialized()) {
    const i = n.getImmediate(), s = n.getOptions();
    if (Nc(s, e ?? {}))
      return i;
    qn(
      i,
      "already-initialized"
      /* AuthErrorCode.ALREADY_INITIALIZED */
    );
  }
  return n.initialize({ options: e });
}
function CC(t, e) {
  const n = (e == null ? void 0 : e.persistence) || [], r = (Array.isArray(n) ? n : [n]).map($r);
  e != null && e.errorMap && t._updateErrorMap(e.errorMap), t._initializeWithPersistence(r, e == null ? void 0 : e.popupRedirectResolver);
}
function kC(t, e, n) {
  const r = ir(t);
  we(
    r._canInitEmulator,
    r,
    "emulator-config-failed"
    /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
  ), we(
    /^https?:\/\//.test(e),
    r,
    "invalid-emulator-scheme"
    /* AuthErrorCode.INVALID_EMULATOR_SCHEME */
  );
  const i = !1, s = qv(e), { host: o, port: a } = NC(e), l = a === null ? "" : `:${a}`;
  r.config.emulator = { url: `${s}//${o}${l}/` }, r.settings.appVerificationDisabledForTesting = !0, r.emulatorConfig = Object.freeze({
    host: o,
    port: a,
    protocol: s.replace(":", ""),
    options: Object.freeze({ disableWarnings: i })
  }), OC();
}
function qv(t) {
  const e = t.indexOf(":");
  return e < 0 ? "" : t.substr(0, e + 1);
}
function NC(t) {
  const e = qv(t), n = /(\/\/)?([^?#/]+)/.exec(t.substr(e.length));
  if (!n)
    return { host: "", port: null };
  const r = n[2].split("@").pop() || "", i = /^(\[[^\]]+\])(:|$)/.exec(r);
  if (i) {
    const s = i[1];
    return { host: s, port: mg(r.substr(s.length + 1)) };
  } else {
    const [s, o] = r.split(":");
    return { host: s, port: mg(o) };
  }
}
function mg(t) {
  if (!t)
    return null;
  const e = Number(t);
  return isNaN(e) ? null : e;
}
function OC() {
  function t() {
    const e = document.createElement("p"), n = e.style;
    e.innerText = "Running in emulator mode. Do not use with production credentials.", n.position = "fixed", n.width = "100%", n.backgroundColor = "#ffffff", n.border = ".1em solid #000000", n.color = "#b50000", n.bottom = "0px", n.left = "0px", n.margin = "0px", n.zIndex = "10000", n.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e);
  }
  typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", t) : t());
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pl {
  /** @internal */
  constructor(e, n) {
    this.providerId = e, this.signInMethod = n;
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns a JSON-serializable representation of this object.
   */
  toJSON() {
    return Vr("not implemented");
  }
  /** @internal */
  _getIdTokenResponse(e) {
    return Vr("not implemented");
  }
  /** @internal */
  _linkToIdToken(e, n) {
    return Vr("not implemented");
  }
  /** @internal */
  _getReauthenticationResolver(e) {
    return Vr("not implemented");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function PC(t, e) {
  return Rn(t, "POST", "/v1/accounts:resetPassword", Jt(t, e));
}
async function xC(t, e) {
  return Rn(t, "POST", "/v1/accounts:signUp", e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function MC(t, e) {
  return Zr(t, "POST", "/v1/accounts:signInWithPassword", Jt(t, e));
}
async function DC(t, e) {
  return Rn(t, "POST", "/v1/accounts:sendOobCode", Jt(t, e));
}
async function LC(t, e) {
  return DC(t, e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function UC(t, e) {
  return Zr(t, "POST", "/v1/accounts:signInWithEmailLink", Jt(t, e));
}
async function FC(t, e) {
  return Zr(t, "POST", "/v1/accounts:signInWithEmailLink", Jt(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zo extends pl {
  /** @internal */
  constructor(e, n, r, i = null) {
    super("password", r), this._email = e, this._password = n, this._tenantId = i;
  }
  /** @internal */
  static _fromEmailAndPassword(e, n) {
    return new Zo(
      e,
      n,
      "password"
      /* SignInMethod.EMAIL_PASSWORD */
    );
  }
  /** @internal */
  static _fromEmailAndCode(e, n, r = null) {
    return new Zo(e, n, "emailLink", r);
  }
  /** {@inheritdoc AuthCredential.toJSON} */
  toJSON() {
    return {
      email: this._email,
      password: this._password,
      signInMethod: this.signInMethod,
      tenantId: this._tenantId
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.
   *
   * @param json - Either `object` or the stringified representation of the object. When string is
   * provided, `JSON.parse` would be called first.
   *
   * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.
   */
  static fromJSON(e) {
    const n = typeof e == "string" ? JSON.parse(e) : e;
    if (n != null && n.email && (n != null && n.password)) {
      if (n.signInMethod === "password")
        return this._fromEmailAndPassword(n.email, n.password);
      if (n.signInMethod === "emailLink")
        return this._fromEmailAndCode(n.email, n.password, n.tenantId);
    }
    return null;
  }
  /** @internal */
  async _getIdTokenResponse(e) {
    switch (this.signInMethod) {
      case "password":
        const n = {
          returnSecureToken: !0,
          email: this._email,
          password: this._password,
          clientType: "CLIENT_TYPE_WEB"
          /* RecaptchaClientType.WEB */
        };
        return Mc(e, n, "signInWithPassword", MC);
      case "emailLink":
        return UC(e, {
          email: this._email,
          oobCode: this._password
        });
      default:
        qn(
          e,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  /** @internal */
  async _linkToIdToken(e, n) {
    switch (this.signInMethod) {
      case "password":
        const r = {
          idToken: n,
          returnSecureToken: !0,
          email: this._email,
          password: this._password,
          clientType: "CLIENT_TYPE_WEB"
          /* RecaptchaClientType.WEB */
        };
        return Mc(e, r, "signUpPassword", xC);
      case "emailLink":
        return FC(e, {
          idToken: n,
          email: this._email,
          oobCode: this._password
        });
      default:
        qn(
          e,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  /** @internal */
  _getReauthenticationResolver(e) {
    return this._getIdTokenResponse(e);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function xs(t, e) {
  return Zr(t, "POST", "/v1/accounts:signInWithIdp", Jt(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VC = "http://localhost";
class Kr extends pl {
  constructor() {
    super(...arguments), this.pendingToken = null;
  }
  /** @internal */
  static _fromParams(e) {
    const n = new Kr(e.providerId, e.signInMethod);
    return e.idToken || e.accessToken ? (e.idToken && (n.idToken = e.idToken), e.accessToken && (n.accessToken = e.accessToken), e.nonce && !e.pendingToken && (n.nonce = e.nonce), e.pendingToken && (n.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (n.accessToken = e.oauthToken, n.secret = e.oauthTokenSecret) : qn(
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), n;
  }
  /** {@inheritdoc AuthCredential.toJSON}  */
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an
   * {@link  AuthCredential}.
   *
   * @param json - Input can be either Object or the stringified representation of the object.
   * When string is provided, JSON.parse would be called first.
   *
   * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
   */
  static fromJSON(e) {
    const n = typeof e == "string" ? JSON.parse(e) : e, { providerId: r, signInMethod: i } = n, s = Zf(n, ["providerId", "signInMethod"]);
    if (!r || !i)
      return null;
    const o = new Kr(r, i);
    return o.idToken = s.idToken || void 0, o.accessToken = s.accessToken || void 0, o.secret = s.secret, o.nonce = s.nonce, o.pendingToken = s.pendingToken || null, o;
  }
  /** @internal */
  _getIdTokenResponse(e) {
    const n = this.buildRequest();
    return xs(e, n);
  }
  /** @internal */
  _linkToIdToken(e, n) {
    const r = this.buildRequest();
    return r.idToken = n, xs(e, r);
  }
  /** @internal */
  _getReauthenticationResolver(e) {
    const n = this.buildRequest();
    return n.autoCreate = !1, xs(e, n);
  }
  buildRequest() {
    const e = {
      requestUri: VC,
      returnSecureToken: !0
    };
    if (this.pendingToken)
      e.pendingToken = this.pendingToken;
    else {
      const n = {};
      this.idToken && (n.id_token = this.idToken), this.accessToken && (n.access_token = this.accessToken), this.secret && (n.oauth_token_secret = this.secret), n.providerId = this.providerId, this.nonce && !this.pendingToken && (n.nonce = this.nonce), e.postBody = ma(n);
    }
    return e;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function BC(t, e) {
  return Rn(t, "POST", "/v1/accounts:sendVerificationCode", Jt(t, e));
}
async function $C(t, e) {
  return Zr(t, "POST", "/v1/accounts:signInWithPhoneNumber", Jt(t, e));
}
async function jC(t, e) {
  const n = await Zr(t, "POST", "/v1/accounts:signInWithPhoneNumber", Jt(t, e));
  if (n.temporaryProof)
    throw Po(t, "account-exists-with-different-credential", n);
  return n;
}
const qC = {
  USER_NOT_FOUND: "user-not-found"
  /* AuthErrorCode.USER_DELETED */
};
async function zC(t, e) {
  const n = Object.assign(Object.assign({}, e), { operation: "REAUTH" });
  return Zr(t, "POST", "/v1/accounts:signInWithPhoneNumber", Jt(t, n), qC);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ms extends pl {
  constructor(e) {
    super(
      "phone",
      "phone"
      /* SignInMethod.PHONE */
    ), this.params = e;
  }
  /** @internal */
  static _fromVerification(e, n) {
    return new Ms({ verificationId: e, verificationCode: n });
  }
  /** @internal */
  static _fromTokenResponse(e, n) {
    return new Ms({ phoneNumber: e, temporaryProof: n });
  }
  /** @internal */
  _getIdTokenResponse(e) {
    return $C(e, this._makeVerificationRequest());
  }
  /** @internal */
  _linkToIdToken(e, n) {
    return jC(e, Object.assign({ idToken: n }, this._makeVerificationRequest()));
  }
  /** @internal */
  _getReauthenticationResolver(e) {
    return zC(e, this._makeVerificationRequest());
  }
  /** @internal */
  _makeVerificationRequest() {
    const { temporaryProof: e, phoneNumber: n, verificationId: r, verificationCode: i } = this.params;
    return e && n ? { temporaryProof: e, phoneNumber: n } : {
      sessionInfo: r,
      code: i
    };
  }
  /** {@inheritdoc AuthCredential.toJSON} */
  toJSON() {
    const e = {
      providerId: this.providerId
    };
    return this.params.phoneNumber && (e.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (e.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (e.verificationCode = this.params.verificationCode), this.params.verificationId && (e.verificationId = this.params.verificationId), e;
  }
  /** Generates a phone credential based on a plain object or a JSON string. */
  static fromJSON(e) {
    typeof e == "string" && (e = JSON.parse(e));
    const { verificationId: n, verificationCode: r, phoneNumber: i, temporaryProof: s } = e;
    return !r && !n && !i && !s ? null : new Ms({
      verificationId: n,
      verificationCode: r,
      phoneNumber: i,
      temporaryProof: s
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function WC(t) {
  switch (t) {
    case "recoverEmail":
      return "RECOVER_EMAIL";
    case "resetPassword":
      return "PASSWORD_RESET";
    case "signIn":
      return "EMAIL_SIGNIN";
    case "verifyEmail":
      return "VERIFY_EMAIL";
    case "verifyAndChangeEmail":
      return "VERIFY_AND_CHANGE_EMAIL";
    case "revertSecondFactorAddition":
      return "REVERT_SECOND_FACTOR_ADDITION";
    default:
      return null;
  }
}
function GC(t) {
  const e = No(Oo(t)).link, n = e ? No(Oo(e)).deep_link_id : null, r = No(Oo(t)).deep_link_id;
  return (r ? No(Oo(r)).link : null) || r || n || e || t;
}
class sh {
  /**
   * @param actionLink - The link from which to extract the URL.
   * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
   *
   * @internal
   */
  constructor(e) {
    var n, r, i, s, o, a;
    const l = No(Oo(e)), u = (n = l.apiKey) !== null && n !== void 0 ? n : null, d = (r = l.oobCode) !== null && r !== void 0 ? r : null, f = WC((i = l.mode) !== null && i !== void 0 ? i : null);
    we(
      u && d && f,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), this.apiKey = u, this.operation = f, this.code = d, this.continueUrl = (s = l.continueUrl) !== null && s !== void 0 ? s : null, this.languageCode = (o = l.languageCode) !== null && o !== void 0 ? o : null, this.tenantId = (a = l.tenantId) !== null && a !== void 0 ? a : null;
  }
  /**
   * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,
   * otherwise returns null.
   *
   * @param link  - The email action link string.
   * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
   *
   * @public
   */
  static parseLink(e) {
    const n = GC(e);
    try {
      return new sh(n);
    } catch {
      return null;
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oo {
  constructor() {
    this.providerId = oo.PROVIDER_ID;
  }
  /**
   * Initialize an {@link AuthCredential} using an email and password.
   *
   * @example
   * ```javascript
   * const authCredential = EmailAuthProvider.credential(email, password);
   * const userCredential = await signInWithCredential(auth, authCredential);
   * ```
   *
   * @example
   * ```javascript
   * const userCredential = await signInWithEmailAndPassword(auth, email, password);
   * ```
   *
   * @param email - Email address.
   * @param password - User account password.
   * @returns The auth provider credential.
   */
  static credential(e, n) {
    return Zo._fromEmailAndPassword(e, n);
  }
  /**
   * Initialize an {@link AuthCredential} using an email and an email link after a sign in with
   * email link operation.
   *
   * @example
   * ```javascript
   * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);
   * const userCredential = await signInWithCredential(auth, authCredential);
   * ```
   *
   * @example
   * ```javascript
   * await sendSignInLinkToEmail(auth, email);
   * // Obtain emailLink from user.
   * const userCredential = await signInWithEmailLink(auth, email, emailLink);
   * ```
   *
   * @param auth - The {@link Auth} instance used to verify the link.
   * @param email - Email address.
   * @param emailLink - Sign-in email link.
   * @returns - The auth provider credential.
   */
  static credentialWithLink(e, n) {
    const r = sh.parseLink(n);
    return we(
      r,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), Zo._fromEmailAndCode(e, r.code, r.tenantId);
  }
}
oo.PROVIDER_ID = "password";
oo.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
oo.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oh {
  /**
   * Constructor for generic OAuth providers.
   *
   * @param providerId - Provider for which credentials should be generated.
   */
  constructor(e) {
    this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {};
  }
  /**
   * Set the language gode.
   *
   * @param languageCode - language code
   */
  setDefaultLanguage(e) {
    this.defaultLanguageCode = e;
  }
  /**
   * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in
   * operations.
   *
   * @remarks
   * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,
   * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.
   *
   * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.
   */
  setCustomParameters(e) {
    return this.customParameters = e, this;
  }
  /**
   * Retrieve the current list of {@link CustomParameters}.
   */
  getCustomParameters() {
    return this.customParameters;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ao extends oh {
  constructor() {
    super(...arguments), this.scopes = [];
  }
  /**
   * Add an OAuth scope to the credential.
   *
   * @param scope - Provider OAuth scope to add.
   */
  addScope(e) {
    return this.scopes.includes(e) || this.scopes.push(e), this;
  }
  /**
   * Retrieve the current list of OAuth scopes.
   */
  getScopes() {
    return [...this.scopes];
  }
}
let CB = class fc extends ao {
  /**
   * Creates an {@link OAuthCredential} from a JSON string or a plain object.
   * @param json - A plain object or a JSON string
   */
  static credentialFromJSON(e) {
    const n = typeof e == "string" ? JSON.parse(e) : e;
    return we(
      "providerId" in n && "signInMethod" in n,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), Kr._fromParams(n);
  }
  /**
   * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.
   *
   * @remarks
   * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of
   * the raw nonce must match the nonce field in the ID token.
   *
   * @example
   * ```javascript
   * // `googleUser` from the onsuccess Google Sign In callback.
   * // Initialize a generate OAuth provider with a `google.com` providerId.
   * const provider = new OAuthProvider('google.com');
   * const credential = provider.credential({
   *   idToken: googleUser.getAuthResponse().id_token,
   * });
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param params - Either the options object containing the ID token, access token and raw nonce
   * or the ID token string.
   */
  credential(e) {
    return this._credential(Object.assign(Object.assign({}, e), { nonce: e.rawNonce }));
  }
  /** An internal credential method that accepts more permissive options */
  _credential(e) {
    return we(
      e.idToken || e.accessToken,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), Kr._fromParams(Object.assign(Object.assign({}, e), { providerId: this.providerId, signInMethod: this.providerId }));
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return fc.oauthCredentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return fc.oauthCredentialFromTaggedObject(e.customData || {});
  }
  static oauthCredentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e)
      return null;
    const { oauthIdToken: n, oauthAccessToken: r, oauthTokenSecret: i, pendingToken: s, nonce: o, providerId: a } = e;
    if (!r && !i && !n && !s || !a)
      return null;
    try {
      return new fc(a)._credential({
        idToken: n,
        accessToken: r,
        nonce: o,
        pendingToken: s
      });
    } catch {
      return null;
    }
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ci extends ao {
  constructor() {
    super(
      "facebook.com"
      /* ProviderId.FACEBOOK */
    );
  }
  /**
   * Creates a credential for Facebook.
   *
   * @example
   * ```javascript
   * // `event` from the Facebook auth.authResponseChange callback.
   * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param accessToken - Facebook access token.
   */
  static credential(e) {
    return Kr._fromParams({
      providerId: ci.PROVIDER_ID,
      signInMethod: ci.FACEBOOK_SIGN_IN_METHOD,
      accessToken: e
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return ci.credentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return ci.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken)
      return null;
    try {
      return ci.credential(e.oauthAccessToken);
    } catch {
      return null;
    }
  }
}
ci.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
ci.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class li extends ao {
  constructor() {
    super(
      "google.com"
      /* ProviderId.GOOGLE */
    ), this.addScope("profile");
  }
  /**
   * Creates a credential for Google. At least one of ID token and access token is required.
   *
   * @example
   * ```javascript
   * // \`googleUser\` from the onsuccess Google Sign In callback.
   * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param idToken - Google ID token.
   * @param accessToken - Google access token.
   */
  static credential(e, n) {
    return Kr._fromParams({
      providerId: li.PROVIDER_ID,
      signInMethod: li.GOOGLE_SIGN_IN_METHOD,
      idToken: e,
      accessToken: n
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return li.credentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return li.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e)
      return null;
    const { oauthIdToken: n, oauthAccessToken: r } = e;
    if (!n && !r)
      return null;
    try {
      return li.credential(n, r);
    } catch {
      return null;
    }
  }
}
li.GOOGLE_SIGN_IN_METHOD = "google.com";
li.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ui extends ao {
  constructor() {
    super(
      "github.com"
      /* ProviderId.GITHUB */
    );
  }
  /**
   * Creates a credential for GitHub.
   *
   * @param accessToken - GitHub access token.
   */
  static credential(e) {
    return Kr._fromParams({
      providerId: ui.PROVIDER_ID,
      signInMethod: ui.GITHUB_SIGN_IN_METHOD,
      accessToken: e
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return ui.credentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return ui.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e || !("oauthAccessToken" in e) || !e.oauthAccessToken)
      return null;
    try {
      return ui.credential(e.oauthAccessToken);
    } catch {
      return null;
    }
  }
}
ui.GITHUB_SIGN_IN_METHOD = "github.com";
ui.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class di extends ao {
  constructor() {
    super(
      "twitter.com"
      /* ProviderId.TWITTER */
    );
  }
  /**
   * Creates a credential for Twitter.
   *
   * @param token - Twitter access token.
   * @param secret - Twitter secret.
   */
  static credential(e, n) {
    return Kr._fromParams({
      providerId: di.PROVIDER_ID,
      signInMethod: di.TWITTER_SIGN_IN_METHOD,
      oauthToken: e,
      oauthTokenSecret: n
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    return di.credentialFromTaggedObject(e);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(e) {
    return di.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e)
      return null;
    const { oauthAccessToken: n, oauthTokenSecret: r } = e;
    if (!n || !r)
      return null;
    try {
      return di.credential(n, r);
    } catch {
      return null;
    }
  }
}
di.TWITTER_SIGN_IN_METHOD = "twitter.com";
di.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function HC(t, e) {
  return Zr(t, "POST", "/v1/accounts:signUp", Jt(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vi {
  constructor(e) {
    this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType;
  }
  static async _fromIdTokenResponse(e, n, r, i = !1) {
    const s = await Br._fromIdTokenResponse(e, r, i), o = gg(r);
    return new vi({
      user: s,
      providerId: o,
      _tokenResponse: r,
      operationType: n
    });
  }
  static async _forOperation(e, n, r) {
    await e._updateTokensIfNecessary(
      r,
      /* reload */
      !0
    );
    const i = gg(r);
    return new vi({
      user: e,
      providerId: i,
      _tokenResponse: r,
      operationType: n
    });
  }
}
function gg(t) {
  return t.providerId ? t.providerId : "phoneNumber" in t ? "phone" : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dc extends rr {
  constructor(e, n, r, i) {
    var s;
    super(n.code, n.message), this.operationType = r, this.user = i, Object.setPrototypeOf(this, Dc.prototype), this.customData = {
      appName: e.name,
      tenantId: (s = e.tenantId) !== null && s !== void 0 ? s : void 0,
      _serverResponse: n.customData._serverResponse,
      operationType: r
    };
  }
  static _fromErrorAndOperation(e, n, r, i) {
    return new Dc(e, n, r, i);
  }
}
function zv(t, e, n, r) {
  return (e === "reauthenticate" ? n._getReauthenticationResolver(t) : n._getIdTokenResponse(t)).catch((s) => {
    throw s.code === "auth/multi-factor-auth-required" ? Dc._fromErrorAndOperation(t, s, e, r) : s;
  });
}
async function KC(t, e, n = !1) {
  const r = await Jo(t, e._linkToIdToken(t.auth, await t.getIdToken()), n);
  return vi._forOperation(t, "link", r);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function YC(t, e, n = !1) {
  const { auth: r } = t;
  if (Bn(r.app))
    return Promise.reject(mr(r));
  const i = "reauthenticate";
  try {
    const s = await Jo(t, zv(r, i, e, t), n);
    we(
      s.idToken,
      r,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const o = rh(s.idToken);
    we(
      o,
      r,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const { sub: a } = o;
    return we(
      t.uid === a,
      r,
      "user-mismatch"
      /* AuthErrorCode.USER_MISMATCH */
    ), vi._forOperation(t, i, s);
  } catch (s) {
    throw (s == null ? void 0 : s.code) === "auth/user-not-found" && qn(
      r,
      "user-mismatch"
      /* AuthErrorCode.USER_MISMATCH */
    ), s;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Wv(t, e, n = !1) {
  if (Bn(t.app))
    return Promise.reject(mr(t));
  const r = "signIn", i = await zv(t, r, e), s = await vi._fromIdTokenResponse(t, r, i);
  return n || await t._updateCurrentUser(s.user), s;
}
async function XC(t, e) {
  return Wv(ir(t), e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function QC(t, e) {
  return Zr(t, "POST", "/v1/accounts:signInWithCustomToken", Jt(t, e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function kB(t, e) {
  if (Bn(t.app))
    return Promise.reject(mr(t));
  const n = ir(t), r = await QC(n, {
    token: e,
    returnSecureToken: !0
  }), i = await vi._fromIdTokenResponse(n, "signIn", r);
  return await n._updateCurrentUser(i.user), i;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ah(t) {
  const e = ir(t);
  e._getPasswordPolicyInternal() && await e._updatePasswordPolicy();
}
async function NB(t, e, n) {
  const r = ir(t);
  await Mc(r, {
    requestType: "PASSWORD_RESET",
    email: e,
    clientType: "CLIENT_TYPE_WEB"
    /* RecaptchaClientType.WEB */
  }, "getOobCode", LC);
}
async function OB(t, e, n) {
  await PC(st(t), {
    oobCode: e,
    newPassword: n
  }).catch(async (r) => {
    throw r.code === "auth/password-does-not-meet-requirements" && ah(t), r;
  });
}
async function PB(t, e, n) {
  if (Bn(t.app))
    return Promise.reject(mr(t));
  const r = ir(t), o = await Mc(r, {
    returnSecureToken: !0,
    email: e,
    password: n,
    clientType: "CLIENT_TYPE_WEB"
    /* RecaptchaClientType.WEB */
  }, "signUpPassword", HC).catch((l) => {
    throw l.code === "auth/password-does-not-meet-requirements" && ah(t), l;
  }), a = await vi._fromIdTokenResponse(r, "signIn", o);
  return await r._updateCurrentUser(a.user), a;
}
function xB(t, e, n) {
  return Bn(t.app) ? Promise.reject(mr(t)) : XC(st(t), oo.credential(e, n)).catch(async (r) => {
    throw r.code === "auth/password-does-not-meet-requirements" && ah(t), r;
  });
}
function JC(t, e, n, r) {
  return st(t).onIdTokenChanged(e, n, r);
}
function ZC(t, e, n) {
  return st(t).beforeAuthStateChanged(e, n);
}
function MB(t, e, n, r) {
  return st(t).onAuthStateChanged(e, n, r);
}
function DB(t) {
  return st(t).signOut();
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ek(t, e) {
  return Rn(t, "POST", "/v2/accounts/mfaEnrollment:start", Jt(t, e));
}
const Lc = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Gv {
  constructor(e, n) {
    this.storageRetriever = e, this.type = n;
  }
  _isAvailable() {
    try {
      return this.storage ? (this.storage.setItem(Lc, "1"), this.storage.removeItem(Lc), Promise.resolve(!0)) : Promise.resolve(!1);
    } catch {
      return Promise.resolve(!1);
    }
  }
  _set(e, n) {
    return this.storage.setItem(e, JSON.stringify(n)), Promise.resolve();
  }
  _get(e) {
    const n = this.storage.getItem(e);
    return Promise.resolve(n ? JSON.parse(n) : null);
  }
  _remove(e) {
    return this.storage.removeItem(e), Promise.resolve();
  }
  get storage() {
    return this.storageRetriever();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tk = 1e3, nk = 10;
class Hv extends Gv {
  constructor() {
    super(
      () => window.localStorage,
      "LOCAL"
      /* PersistenceType.LOCAL */
    ), this.boundEventHandler = (e, n) => this.onStorageEvent(e, n), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.fallbackToPolling = Bv(), this._shouldAllowMigration = !0;
  }
  forAllChangedKeys(e) {
    for (const n of Object.keys(this.listeners)) {
      const r = this.storage.getItem(n), i = this.localCache[n];
      r !== i && e(n, i, r);
    }
  }
  onStorageEvent(e, n = !1) {
    if (!e.key) {
      this.forAllChangedKeys((o, a, l) => {
        this.notifyListeners(o, l);
      });
      return;
    }
    const r = e.key;
    n ? this.detachListener() : this.stopPolling();
    const i = () => {
      const o = this.storage.getItem(r);
      !n && this.localCache[r] === o || this.notifyListeners(r, o);
    }, s = this.storage.getItem(r);
    pC() && s !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, nk) : i();
  }
  notifyListeners(e, n) {
    this.localCache[e] = n;
    const r = this.listeners[e];
    if (r)
      for (const i of Array.from(r))
        i(n && JSON.parse(n));
  }
  startPolling() {
    this.stopPolling(), this.pollTimer = setInterval(() => {
      this.forAllChangedKeys((e, n, r) => {
        this.onStorageEvent(
          new StorageEvent("storage", {
            key: e,
            oldValue: n,
            newValue: r
          }),
          /* poll */
          !0
        );
      });
    }, tk);
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
  }
  attachListener() {
    window.addEventListener("storage", this.boundEventHandler);
  }
  detachListener() {
    window.removeEventListener("storage", this.boundEventHandler);
  }
  _addListener(e, n) {
    Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = /* @__PURE__ */ new Set(), this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(n);
  }
  _removeListener(e, n) {
    this.listeners[e] && (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && (this.detachListener(), this.stopPolling());
  }
  // Update local cache on base operations:
  async _set(e, n) {
    await super._set(e, n), this.localCache[e] = JSON.stringify(n);
  }
  async _get(e) {
    const n = await super._get(e);
    return this.localCache[e] = JSON.stringify(n), n;
  }
  async _remove(e) {
    await super._remove(e), delete this.localCache[e];
  }
}
Hv.type = "LOCAL";
const rk = Hv;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Kv extends Gv {
  constructor() {
    super(
      () => window.sessionStorage,
      "SESSION"
      /* PersistenceType.SESSION */
    );
  }
  _addListener(e, n) {
  }
  _removeListener(e, n) {
  }
}
Kv.type = "SESSION";
const Yv = Kv;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ik(t) {
  return Promise.all(t.map(async (e) => {
    try {
      return {
        fulfilled: !0,
        value: await e
      };
    } catch (n) {
      return {
        fulfilled: !1,
        reason: n
      };
    }
  }));
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ml {
  constructor(e) {
    this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this);
  }
  /**
   * Obtain an instance of a Receiver for a given event target, if none exists it will be created.
   *
   * @param eventTarget - An event target (such as window or self) through which the underlying
   * messages will be received.
   */
  static _getInstance(e) {
    const n = this.receivers.find((i) => i.isListeningto(e));
    if (n)
      return n;
    const r = new ml(e);
    return this.receivers.push(r), r;
  }
  isListeningto(e) {
    return this.eventTarget === e;
  }
  /**
   * Fans out a MessageEvent to the appropriate listeners.
   *
   * @remarks
   * Sends an {@link Status.ACK} upon receipt and a {@link Status.DONE} once all handlers have
   * finished processing.
   *
   * @param event - The MessageEvent.
   *
   */
  async handleEvent(e) {
    const n = e, { eventId: r, eventType: i, data: s } = n.data, o = this.handlersMap[i];
    if (!(o != null && o.size))
      return;
    n.ports[0].postMessage({
      status: "ack",
      eventId: r,
      eventType: i
    });
    const a = Array.from(o).map(async (u) => u(n.origin, s)), l = await ik(a);
    n.ports[0].postMessage({
      status: "done",
      eventId: r,
      eventType: i,
      response: l
    });
  }
  /**
   * Subscribe an event handler for a particular event.
   *
   * @param eventType - Event name to subscribe to.
   * @param eventHandler - The event handler which should receive the events.
   *
   */
  _subscribe(e, n) {
    Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = /* @__PURE__ */ new Set()), this.handlersMap[e].add(n);
  }
  /**
   * Unsubscribe an event handler from a particular event.
   *
   * @param eventType - Event name to unsubscribe from.
   * @param eventHandler - Optional event handler, if none provided, unsubscribe all handlers on this event.
   *
   */
  _unsubscribe(e, n) {
    this.handlersMap[e] && n && this.handlersMap[e].delete(n), (!n || this.handlersMap[e].size === 0) && delete this.handlersMap[e], Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler);
  }
}
ml.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ch(t = "", e = 10) {
  let n = "";
  for (let r = 0; r < e; r++)
    n += Math.floor(Math.random() * 10);
  return t + n;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sk {
  constructor(e) {
    this.target = e, this.handlers = /* @__PURE__ */ new Set();
  }
  /**
   * Unsubscribe the handler and remove it from our tracking Set.
   *
   * @param handler - The handler to unsubscribe.
   */
  removeMessageHandler(e) {
    e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e);
  }
  /**
   * Send a message to the Receiver located at {@link target}.
   *
   * @remarks
   * We'll first wait a bit for an ACK , if we get one we will wait significantly longer until the
   * receiver has had a chance to fully process the event.
   *
   * @param eventType - Type of event to send.
   * @param data - The payload of the event.
   * @param timeout - Timeout for waiting on an ACK from the receiver.
   *
   * @returns An array of settled promises from all the handlers that were listening on the receiver.
   */
  async _send(e, n, r = 50) {
    const i = typeof MessageChannel < "u" ? new MessageChannel() : null;
    if (!i)
      throw new Error(
        "connection_unavailable"
        /* _MessageError.CONNECTION_UNAVAILABLE */
      );
    let s, o;
    return new Promise((a, l) => {
      const u = ch("", 20);
      i.port1.start();
      const d = setTimeout(() => {
        l(new Error(
          "unsupported_event"
          /* _MessageError.UNSUPPORTED_EVENT */
        ));
      }, r);
      o = {
        messageChannel: i,
        onMessage(f) {
          const p = f;
          if (p.data.eventId === u)
            switch (p.data.status) {
              case "ack":
                clearTimeout(d), s = setTimeout(
                  () => {
                    l(new Error(
                      "timeout"
                      /* _MessageError.TIMEOUT */
                    ));
                  },
                  3e3
                  /* _TimeoutDuration.COMPLETION */
                );
                break;
              case "done":
                clearTimeout(s), a(p.data.response);
                break;
              default:
                clearTimeout(d), clearTimeout(s), l(new Error(
                  "invalid_response"
                  /* _MessageError.INVALID_RESPONSE */
                ));
                break;
            }
        }
      }, this.handlers.add(o), i.port1.addEventListener("message", o.onMessage), this.target.postMessage({
        eventType: e,
        eventId: u,
        data: n
      }, [i.port2]);
    }).finally(() => {
      o && this.removeMessageHandler(o);
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function gr() {
  return window;
}
function ok(t) {
  gr().location.href = t;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Xv() {
  return typeof gr().WorkerGlobalScope < "u" && typeof gr().importScripts == "function";
}
async function ak() {
  if (!(navigator != null && navigator.serviceWorker))
    return null;
  try {
    return (await navigator.serviceWorker.ready).active;
  } catch {
    return null;
  }
}
function ck() {
  var t;
  return ((t = navigator == null ? void 0 : navigator.serviceWorker) === null || t === void 0 ? void 0 : t.controller) || null;
}
function lk() {
  return Xv() ? self : null;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Qv = "firebaseLocalStorageDb", uk = 1, Uc = "firebaseLocalStorage", Jv = "fbase_key";
class _a {
  constructor(e) {
    this.request = e;
  }
  toPromise() {
    return new Promise((e, n) => {
      this.request.addEventListener("success", () => {
        e(this.request.result);
      }), this.request.addEventListener("error", () => {
        n(this.request.error);
      });
    });
  }
}
function gl(t, e) {
  return t.transaction([Uc], e ? "readwrite" : "readonly").objectStore(Uc);
}
function dk() {
  const t = indexedDB.deleteDatabase(Qv);
  return new _a(t).toPromise();
}
function Bd() {
  const t = indexedDB.open(Qv, uk);
  return new Promise((e, n) => {
    t.addEventListener("error", () => {
      n(t.error);
    }), t.addEventListener("upgradeneeded", () => {
      const r = t.result;
      try {
        r.createObjectStore(Uc, { keyPath: Jv });
      } catch (i) {
        n(i);
      }
    }), t.addEventListener("success", async () => {
      const r = t.result;
      r.objectStoreNames.contains(Uc) ? e(r) : (r.close(), await dk(), e(await Bd()));
    });
  });
}
async function yg(t, e, n) {
  const r = gl(t, !0).put({
    [Jv]: e,
    value: n
  });
  return new _a(r).toPromise();
}
async function fk(t, e) {
  const n = gl(t, !1).get(e), r = await new _a(n).toPromise();
  return r === void 0 ? null : r.value;
}
function _g(t, e) {
  const n = gl(t, !0).delete(e);
  return new _a(n).toPromise();
}
const hk = 800, pk = 3;
class Zv {
  constructor() {
    this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {
    }, () => {
    });
  }
  async _openDb() {
    return this.db ? this.db : (this.db = await Bd(), this.db);
  }
  async _withRetries(e) {
    let n = 0;
    for (; ; )
      try {
        const r = await this._openDb();
        return await e(r);
      } catch (r) {
        if (n++ > pk)
          throw r;
        this.db && (this.db.close(), this.db = void 0);
      }
  }
  /**
   * IndexedDB events do not propagate from the main window to the worker context.  We rely on a
   * postMessage interface to send these events to the worker ourselves.
   */
  async initializeServiceWorkerMessaging() {
    return Xv() ? this.initializeReceiver() : this.initializeSender();
  }
  /**
   * As the worker we should listen to events from the main window.
   */
  async initializeReceiver() {
    this.receiver = ml._getInstance(lk()), this.receiver._subscribe("keyChanged", async (e, n) => ({
      keyProcessed: (await this._poll()).includes(n.key)
    })), this.receiver._subscribe("ping", async (e, n) => [
      "keyChanged"
      /* _EventType.KEY_CHANGED */
    ]);
  }
  /**
   * As the main window, we should let the worker know when keys change (set and remove).
   *
   * @remarks
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/ready | ServiceWorkerContainer.ready}
   * may not resolve.
   */
  async initializeSender() {
    var e, n;
    if (this.activeServiceWorker = await ak(), !this.activeServiceWorker)
      return;
    this.sender = new sk(this.activeServiceWorker);
    const r = await this.sender._send(
      "ping",
      {},
      800
      /* _TimeoutDuration.LONG_ACK */
    );
    r && !((e = r[0]) === null || e === void 0) && e.fulfilled && !((n = r[0]) === null || n === void 0) && n.value.includes(
      "keyChanged"
      /* _EventType.KEY_CHANGED */
    ) && (this.serviceWorkerReceiverAvailable = !0);
  }
  /**
   * Let the worker know about a changed key, the exact key doesn't technically matter since the
   * worker will just trigger a full sync anyway.
   *
   * @remarks
   * For now, we only support one service worker per page.
   *
   * @param key - Storage key which changed.
   */
  async notifyServiceWorker(e) {
    if (!(!this.sender || !this.activeServiceWorker || ck() !== this.activeServiceWorker))
      try {
        await this.sender._send(
          "keyChanged",
          { key: e },
          // Use long timeout if receiver has previously responded to a ping from us.
          this.serviceWorkerReceiverAvailable ? 800 : 50
          /* _TimeoutDuration.ACK */
        );
      } catch {
      }
  }
  async _isAvailable() {
    try {
      if (!indexedDB)
        return !1;
      const e = await Bd();
      return await yg(e, Lc, "1"), await _g(e, Lc), !0;
    } catch {
    }
    return !1;
  }
  async _withPendingWrite(e) {
    this.pendingWrites++;
    try {
      await e();
    } finally {
      this.pendingWrites--;
    }
  }
  async _set(e, n) {
    return this._withPendingWrite(async () => (await this._withRetries((r) => yg(r, e, n)), this.localCache[e] = n, this.notifyServiceWorker(e)));
  }
  async _get(e) {
    const n = await this._withRetries((r) => fk(r, e));
    return this.localCache[e] = n, n;
  }
  async _remove(e) {
    return this._withPendingWrite(async () => (await this._withRetries((n) => _g(n, e)), delete this.localCache[e], this.notifyServiceWorker(e)));
  }
  async _poll() {
    const e = await this._withRetries((i) => {
      const s = gl(i, !1).getAll();
      return new _a(s).toPromise();
    });
    if (!e)
      return [];
    if (this.pendingWrites !== 0)
      return [];
    const n = [], r = /* @__PURE__ */ new Set();
    if (e.length !== 0)
      for (const { fbase_key: i, value: s } of e)
        r.add(i), JSON.stringify(this.localCache[i]) !== JSON.stringify(s) && (this.notifyListeners(i, s), n.push(i));
    for (const i of Object.keys(this.localCache))
      this.localCache[i] && !r.has(i) && (this.notifyListeners(i, null), n.push(i));
    return n;
  }
  notifyListeners(e, n) {
    this.localCache[e] = n;
    const r = this.listeners[e];
    if (r)
      for (const i of Array.from(r))
        i(n);
  }
  startPolling() {
    this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), hk);
  }
  stopPolling() {
    this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null);
  }
  _addListener(e, n) {
    Object.keys(this.listeners).length === 0 && this.startPolling(), this.listeners[e] || (this.listeners[e] = /* @__PURE__ */ new Set(), this._get(e)), this.listeners[e].add(n);
  }
  _removeListener(e, n) {
    this.listeners[e] && (this.listeners[e].delete(n), this.listeners[e].size === 0 && delete this.listeners[e]), Object.keys(this.listeners).length === 0 && this.stopPolling();
  }
}
Zv.type = "LOCAL";
const mk = Zv;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function gk(t, e) {
  return Rn(t, "POST", "/v2/accounts/mfaSignIn:start", Jt(t, e));
}
new ya(3e4, 6e4);
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yk = "recaptcha";
async function _k(t, e, n) {
  var r;
  const i = await n.verify();
  try {
    we(
      typeof i == "string",
      t,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ), we(
      n.type === yk,
      t,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    let s;
    if (typeof e == "string" ? s = {
      phoneNumber: e
    } : s = e, "session" in s) {
      const o = s.session;
      if ("phoneNumber" in s)
        return we(
          o.type === "enroll",
          t,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        ), (await ek(t, {
          idToken: o.credential,
          phoneEnrollmentInfo: {
            phoneNumber: s.phoneNumber,
            recaptchaToken: i
          }
        })).phoneSessionInfo.sessionInfo;
      {
        we(
          o.type === "signin",
          t,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
        const a = ((r = s.multiFactorHint) === null || r === void 0 ? void 0 : r.uid) || s.multiFactorUid;
        return we(
          a,
          t,
          "missing-multi-factor-info"
          /* AuthErrorCode.MISSING_MFA_INFO */
        ), (await gk(t, {
          mfaPendingCredential: o.credential,
          mfaEnrollmentId: a,
          phoneSignInInfo: {
            recaptchaToken: i
          }
        })).phoneResponseInfo.sessionInfo;
      }
    } else {
      const { sessionInfo: o } = await BC(t, {
        phoneNumber: s.phoneNumber,
        recaptchaToken: i
      });
      return o;
    }
  } finally {
    n._reset();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ds {
  /**
   * @param auth - The Firebase {@link Auth} instance in which sign-ins should occur.
   *
   */
  constructor(e) {
    this.providerId = Ds.PROVIDER_ID, this.auth = ir(e);
  }
  /**
   *
   * Starts a phone number authentication flow by sending a verification code to the given phone
   * number.
   *
   * @example
   * ```javascript
   * const provider = new PhoneAuthProvider(auth);
   * const verificationId = await provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
   * // Obtain verificationCode from the user.
   * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
   * const userCredential = await signInWithCredential(auth, authCredential);
   * ```
   *
   * @example
   * An alternative flow is provided using the `signInWithPhoneNumber` method.
   * ```javascript
   * const confirmationResult = signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
   * // Obtain verificationCode from the user.
   * const userCredential = confirmationResult.confirm(verificationCode);
   * ```
   *
   * @param phoneInfoOptions - The user's {@link PhoneInfoOptions}. The phone number should be in
   * E.164 format (e.g. +16505550101).
   * @param applicationVerifier - For abuse prevention, this method also requires a
   * {@link ApplicationVerifier}. This SDK includes a reCAPTCHA-based implementation,
   * {@link RecaptchaVerifier}.
   *
   * @returns A Promise for a verification ID that can be passed to
   * {@link PhoneAuthProvider.credential} to identify this flow..
   */
  verifyPhoneNumber(e, n) {
    return _k(this.auth, e, st(n));
  }
  /**
   * Creates a phone auth credential, given the verification ID from
   * {@link PhoneAuthProvider.verifyPhoneNumber} and the code that was sent to the user's
   * mobile device.
   *
   * @example
   * ```javascript
   * const provider = new PhoneAuthProvider(auth);
   * const verificationId = provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
   * // Obtain verificationCode from the user.
   * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
   * const userCredential = signInWithCredential(auth, authCredential);
   * ```
   *
   * @example
   * An alternative flow is provided using the `signInWithPhoneNumber` method.
   * ```javascript
   * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
   * // Obtain verificationCode from the user.
   * const userCredential = await confirmationResult.confirm(verificationCode);
   * ```
   *
   * @param verificationId - The verification ID returned from {@link PhoneAuthProvider.verifyPhoneNumber}.
   * @param verificationCode - The verification code sent to the user's mobile device.
   *
   * @returns The auth provider credential.
   */
  static credential(e, n) {
    return Ms._fromVerification(e, n);
  }
  /**
   * Generates an {@link AuthCredential} from a {@link UserCredential}.
   * @param userCredential - The user credential.
   */
  static credentialFromResult(e) {
    const n = e;
    return Ds.credentialFromTaggedObject(n);
  }
  /**
   * Returns an {@link AuthCredential} when passed an error.
   *
   * @remarks
   *
   * This method works for errors like
   * `auth/account-exists-with-different-credentials`. This is useful for
   * recovering when attempting to set a user's phone number but the number
   * in question is already tied to another account. For example, the following
   * code tries to update the current user's phone number, and if that
   * fails, links the user with the account associated with that number:
   *
   * ```js
   * const provider = new PhoneAuthProvider(auth);
   * const verificationId = await provider.verifyPhoneNumber(number, verifier);
   * try {
   *   const code = ''; // Prompt the user for the verification code
   *   await updatePhoneNumber(
   *       auth.currentUser,
   *       PhoneAuthProvider.credential(verificationId, code));
   * } catch (e) {
   *   if ((e as FirebaseError)?.code === 'auth/account-exists-with-different-credential') {
   *     const cred = PhoneAuthProvider.credentialFromError(e);
   *     await linkWithCredential(auth.currentUser, cred);
   *   }
   * }
   *
   * // At this point, auth.currentUser.phoneNumber === number.
   * ```
   *
   * @param error - The error to generate a credential from.
   */
  static credentialFromError(e) {
    return Ds.credentialFromTaggedObject(e.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: e }) {
    if (!e)
      return null;
    const { phoneNumber: n, temporaryProof: r } = e;
    return n && r ? Ms._fromTokenResponse(n, r) : null;
  }
}
Ds.PROVIDER_ID = "phone";
Ds.PHONE_SIGN_IN_METHOD = "phone";
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function eE(t, e) {
  return e ? $r(e) : (we(
    t._popupRedirectResolver,
    t,
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  ), t._popupRedirectResolver);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lh extends pl {
  constructor(e) {
    super(
      "custom",
      "custom"
      /* ProviderId.CUSTOM */
    ), this.params = e;
  }
  _getIdTokenResponse(e) {
    return xs(e, this._buildIdpRequest());
  }
  _linkToIdToken(e, n) {
    return xs(e, this._buildIdpRequest(n));
  }
  _getReauthenticationResolver(e) {
    return xs(e, this._buildIdpRequest());
  }
  _buildIdpRequest(e) {
    const n = {
      requestUri: this.params.requestUri,
      sessionId: this.params.sessionId,
      postBody: this.params.postBody,
      tenantId: this.params.tenantId,
      pendingToken: this.params.pendingToken,
      returnSecureToken: !0,
      returnIdpCredential: !0
    };
    return e && (n.idToken = e), n;
  }
}
function bk(t) {
  return Wv(t.auth, new lh(t), t.bypassAuthState);
}
function vk(t) {
  const { auth: e, user: n } = t;
  return we(
    n,
    e,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), YC(n, new lh(t), t.bypassAuthState);
}
async function Ek(t) {
  const { auth: e, user: n } = t;
  return we(
    n,
    e,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), KC(n, new lh(t), t.bypassAuthState);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class tE {
  constructor(e, n, r, i, s = !1) {
    this.auth = e, this.resolver = r, this.user = i, this.bypassAuthState = s, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(n) ? n : [n];
  }
  execute() {
    return new Promise(async (e, n) => {
      this.pendingPromise = { resolve: e, reject: n };
      try {
        this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this);
      } catch (r) {
        this.reject(r);
      }
    });
  }
  async onAuthEvent(e) {
    const { urlResponse: n, sessionId: r, postBody: i, tenantId: s, error: o, type: a } = e;
    if (o) {
      this.reject(o);
      return;
    }
    const l = {
      auth: this.auth,
      requestUri: n,
      sessionId: r,
      tenantId: s || void 0,
      postBody: i || void 0,
      user: this.user,
      bypassAuthState: this.bypassAuthState
    };
    try {
      this.resolve(await this.getIdpTask(a)(l));
    } catch (u) {
      this.reject(u);
    }
  }
  onError(e) {
    this.reject(e);
  }
  getIdpTask(e) {
    switch (e) {
      case "signInViaPopup":
      case "signInViaRedirect":
        return bk;
      case "linkViaPopup":
      case "linkViaRedirect":
        return Ek;
      case "reauthViaPopup":
      case "reauthViaRedirect":
        return vk;
      default:
        qn(
          this.auth,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  resolve(e) {
    Hr(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp();
  }
  reject(e) {
    Hr(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp();
  }
  unregisterAndCleanUp() {
    this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wk = new ya(2e3, 1e4);
async function LB(t, e, n) {
  if (Bn(t.app))
    return Promise.reject(er(
      t,
      "operation-not-supported-in-this-environment"
      /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
    ));
  const r = ir(t);
  YR(t, e, oh);
  const i = eE(r, n);
  return new qi(r, "signInViaPopup", e, i).executeNotNull();
}
class qi extends tE {
  constructor(e, n, r, i, s) {
    super(e, n, i, s), this.provider = r, this.authWindow = null, this.pollId = null, qi.currentPopupAction && qi.currentPopupAction.cancel(), qi.currentPopupAction = this;
  }
  async executeNotNull() {
    const e = await this.execute();
    return we(
      e,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ), e;
  }
  async onExecution() {
    Hr(this.filter.length === 1, "Popup operations only handle one event");
    const e = ch();
    this.authWindow = await this.resolver._openPopup(
      this.auth,
      this.provider,
      this.filter[0],
      // There's always one, see constructor
      e
    ), this.authWindow.associatedEvent = e, this.resolver._originValidation(this.auth).catch((n) => {
      this.reject(n);
    }), this.resolver._isIframeWebStorageSupported(this.auth, (n) => {
      n || this.reject(er(
        this.auth,
        "web-storage-unsupported"
        /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */
      ));
    }), this.pollUserCancellation();
  }
  get eventId() {
    var e;
    return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null;
  }
  cancel() {
    this.reject(er(
      this.auth,
      "cancelled-popup-request"
      /* AuthErrorCode.EXPIRED_POPUP_REQUEST */
    ));
  }
  cleanUp() {
    this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, qi.currentPopupAction = null;
  }
  pollUserCancellation() {
    const e = () => {
      var n, r;
      if (!((r = (n = this.authWindow) === null || n === void 0 ? void 0 : n.window) === null || r === void 0) && r.closed) {
        this.pollId = window.setTimeout(
          () => {
            this.pollId = null, this.reject(er(
              this.auth,
              "popup-closed-by-user"
              /* AuthErrorCode.POPUP_CLOSED_BY_USER */
            ));
          },
          8e3
          /* _Timeout.AUTH_EVENT */
        );
        return;
      }
      this.pollId = window.setTimeout(e, wk.get());
    };
    e();
  }
}
qi.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Tk = "pendingRedirect", hc = /* @__PURE__ */ new Map();
class Ik extends tE {
  constructor(e, n, r = !1) {
    super(e, [
      "signInViaRedirect",
      "linkViaRedirect",
      "reauthViaRedirect",
      "unknown"
      /* AuthEventType.UNKNOWN */
    ], n, void 0, r), this.eventId = null;
  }
  /**
   * Override the execute function; if we already have a redirect result, then
   * just return it.
   */
  async execute() {
    let e = hc.get(this.auth._key());
    if (!e) {
      try {
        const r = await Sk(this.resolver, this.auth) ? await super.execute() : null;
        e = () => Promise.resolve(r);
      } catch (n) {
        e = () => Promise.reject(n);
      }
      hc.set(this.auth._key(), e);
    }
    return this.bypassAuthState || hc.set(this.auth._key(), () => Promise.resolve(null)), e();
  }
  async onAuthEvent(e) {
    if (e.type === "signInViaRedirect")
      return super.onAuthEvent(e);
    if (e.type === "unknown") {
      this.resolve(null);
      return;
    }
    if (e.eventId) {
      const n = await this.auth._redirectUserForId(e.eventId);
      if (n)
        return this.user = n, super.onAuthEvent(e);
      this.resolve(null);
    }
  }
  async onExecution() {
  }
  cleanUp() {
  }
}
async function Sk(t, e) {
  const n = Ck(e), r = Rk(t);
  if (!await r._isAvailable())
    return !1;
  const i = await r._get(n) === "true";
  return await r._remove(n), i;
}
function Ak(t, e) {
  hc.set(t._key(), e);
}
function Rk(t) {
  return $r(t._redirectPersistence);
}
function Ck(t) {
  return dc(Tk, t.config.apiKey, t.name);
}
async function kk(t, e, n = !1) {
  if (Bn(t.app))
    return Promise.reject(mr(t));
  const r = ir(t), i = eE(r, e), o = await new Ik(r, i, n).execute();
  return o && !n && (delete o.user._redirectEventId, await r._persistUserIfCurrent(o.user), await r._setRedirectUser(null, e)), o;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Nk = 10 * 60 * 1e3;
class Ok {
  constructor(e) {
    this.auth = e, this.cachedEventUids = /* @__PURE__ */ new Set(), this.consumers = /* @__PURE__ */ new Set(), this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now();
  }
  registerConsumer(e) {
    this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null);
  }
  unregisterConsumer(e) {
    this.consumers.delete(e);
  }
  onEvent(e) {
    if (this.hasEventBeenHandled(e))
      return !1;
    let n = !1;
    return this.consumers.forEach((r) => {
      this.isEventForConsumer(e, r) && (n = !0, this.sendToConsumer(e, r), this.saveEventToCache(e));
    }), this.hasHandledPotentialRedirect || !Pk(e) || (this.hasHandledPotentialRedirect = !0, n || (this.queuedRedirectEvent = e, n = !0)), n;
  }
  sendToConsumer(e, n) {
    var r;
    if (e.error && !nE(e)) {
      const i = ((r = e.error.code) === null || r === void 0 ? void 0 : r.split("auth/")[1]) || "internal-error";
      n.onError(er(this.auth, i));
    } else
      n.onAuthEvent(e);
  }
  isEventForConsumer(e, n) {
    const r = n.eventId === null || !!e.eventId && e.eventId === n.eventId;
    return n.filter.includes(e.type) && r;
  }
  hasEventBeenHandled(e) {
    return Date.now() - this.lastProcessedEventTime >= Nk && this.cachedEventUids.clear(), this.cachedEventUids.has(bg(e));
  }
  saveEventToCache(e) {
    this.cachedEventUids.add(bg(e)), this.lastProcessedEventTime = Date.now();
  }
}
function bg(t) {
  return [t.type, t.eventId, t.sessionId, t.tenantId].filter((e) => e).join("-");
}
function nE({ type: t, error: e }) {
  return t === "unknown" && (e == null ? void 0 : e.code) === "auth/no-auth-event";
}
function Pk(t) {
  switch (t.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
      return !0;
    case "unknown":
      return nE(t);
    default:
      return !1;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function xk(t, e = {}) {
  return Rn(t, "GET", "/v1/projects", e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Mk = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, Dk = /^https?/;
async function Lk(t) {
  if (t.config.emulator)
    return;
  const { authorizedDomains: e } = await xk(t);
  for (const n of e)
    try {
      if (Uk(n))
        return;
    } catch {
    }
  qn(
    t,
    "unauthorized-domain"
    /* AuthErrorCode.INVALID_ORIGIN */
  );
}
function Uk(t) {
  const e = Fd(), { protocol: n, hostname: r } = new URL(e);
  if (t.startsWith("chrome-extension://")) {
    const o = new URL(t);
    return o.hostname === "" && r === "" ? n === "chrome-extension:" && t.replace("chrome-extension://", "") === e.replace("chrome-extension://", "") : n === "chrome-extension:" && o.hostname === r;
  }
  if (!Dk.test(n))
    return !1;
  if (Mk.test(t))
    return r === t;
  const i = t.replace(/\./g, "\\.");
  return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(r);
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fk = new ya(3e4, 6e4);
function vg() {
  const t = gr().___jsl;
  if (t != null && t.H) {
    for (const e of Object.keys(t.H))
      if (t.H[e].r = t.H[e].r || [], t.H[e].L = t.H[e].L || [], t.H[e].r = [...t.H[e].L], t.CP)
        for (let n = 0; n < t.CP.length; n++)
          t.CP[n] = null;
  }
}
function Vk(t) {
  return new Promise((e, n) => {
    var r, i, s;
    function o() {
      vg(), gapi.load("gapi.iframes", {
        callback: () => {
          e(gapi.iframes.getContext());
        },
        ontimeout: () => {
          vg(), n(er(
            t,
            "network-request-failed"
            /* AuthErrorCode.NETWORK_REQUEST_FAILED */
          ));
        },
        timeout: Fk.get()
      });
    }
    if (!((i = (r = gr().gapi) === null || r === void 0 ? void 0 : r.iframes) === null || i === void 0) && i.Iframe)
      e(gapi.iframes.getContext());
    else if (!((s = gr().gapi) === null || s === void 0) && s.load)
      o();
    else {
      const a = TC("iframefcb");
      return gr()[a] = () => {
        gapi.load ? o() : n(er(
          t,
          "network-request-failed"
          /* AuthErrorCode.NETWORK_REQUEST_FAILED */
        ));
      }, jv(`${wC()}?onload=${a}`).catch((l) => n(l));
    }
  }).catch((e) => {
    throw pc = null, e;
  });
}
let pc = null;
function Bk(t) {
  return pc = pc || Vk(t), pc;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $k = new ya(5e3, 15e3), jk = "__/auth/iframe", qk = "emulator/auth/iframe", zk = {
  style: {
    position: "absolute",
    top: "-100px",
    width: "1px",
    height: "1px"
  },
  "aria-hidden": "true",
  tabindex: "-1"
}, Wk = /* @__PURE__ */ new Map([
  ["identitytoolkit.googleapis.com", "p"],
  ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
  ["test-identitytoolkit.sandbox.googleapis.com", "t"]
  // test
]);
function Gk(t) {
  const e = t.config;
  we(
    e.authDomain,
    t,
    "auth-domain-config-required"
    /* AuthErrorCode.MISSING_AUTH_DOMAIN */
  );
  const n = e.emulator ? nh(e, qk) : `https://${t.config.authDomain}/${jk}`, r = {
    apiKey: e.apiKey,
    appName: t.name,
    v: ls
  }, i = Wk.get(t.config.apiHost);
  i && (r.eid = i);
  const s = t._getFrameworks();
  return s.length && (r.fw = s.join(",")), `${n}?${ma(r).slice(1)}`;
}
async function Hk(t) {
  const e = await Bk(t), n = gr().gapi;
  return we(
    n,
    t,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  ), e.open({
    where: document.body,
    url: Gk(t),
    messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
    attributes: zk,
    dontclear: !0
  }, (r) => new Promise(async (i, s) => {
    await r.restyle({
      // Prevent iframe from closing on mouse out.
      setHideOnLeave: !1
    });
    const o = er(
      t,
      "network-request-failed"
      /* AuthErrorCode.NETWORK_REQUEST_FAILED */
    ), a = gr().setTimeout(() => {
      s(o);
    }, $k.get());
    function l() {
      gr().clearTimeout(a), i(r);
    }
    r.ping(l).then(l, () => {
      s(o);
    });
  }));
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Kk = {
  location: "yes",
  resizable: "yes",
  statusbar: "yes",
  toolbar: "no"
}, Yk = 500, Xk = 600, Qk = "_blank", Jk = "http://localhost";
class Eg {
  constructor(e) {
    this.window = e, this.associatedEvent = null;
  }
  close() {
    if (this.window)
      try {
        this.window.close();
      } catch {
      }
  }
}
function Zk(t, e, n, r = Yk, i = Xk) {
  const s = Math.max((window.screen.availHeight - i) / 2, 0).toString(), o = Math.max((window.screen.availWidth - r) / 2, 0).toString();
  let a = "";
  const l = Object.assign(Object.assign({}, Kk), {
    width: r.toString(),
    height: i.toString(),
    top: s,
    left: o
  }), u = cn().toLowerCase();
  n && (a = Dv(u) ? Qk : n), xv(u) && (e = e || Jk, l.scrollbars = "yes");
  const d = Object.entries(l).reduce((p, [g, _]) => `${p}${g}=${_},`, "");
  if (hC(u) && a !== "_self")
    return eN(e || "", a), new Eg(null);
  const f = window.open(e || "", a, d);
  we(
    f,
    t,
    "popup-blocked"
    /* AuthErrorCode.POPUP_BLOCKED */
  );
  try {
    f.focus();
  } catch {
  }
  return new Eg(f);
}
function eN(t, e) {
  const n = document.createElement("a");
  n.href = t, n.target = e;
  const r = document.createEvent("MouseEvent");
  r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tN = "__/auth/handler", nN = "emulator/auth/handler", rN = encodeURIComponent("fac");
async function wg(t, e, n, r, i, s) {
  we(
    t.config.authDomain,
    t,
    "auth-domain-config-required"
    /* AuthErrorCode.MISSING_AUTH_DOMAIN */
  ), we(
    t.config.apiKey,
    t,
    "invalid-api-key"
    /* AuthErrorCode.INVALID_API_KEY */
  );
  const o = {
    apiKey: t.config.apiKey,
    appName: t.name,
    authType: n,
    redirectUrl: r,
    v: ls,
    eventId: i
  };
  if (e instanceof oh) {
    e.setDefaultLanguage(t.languageCode), o.providerId = e.providerId || "", xA(e.getCustomParameters()) || (o.customParameters = JSON.stringify(e.getCustomParameters()));
    for (const [d, f] of Object.entries({}))
      o[d] = f;
  }
  if (e instanceof ao) {
    const d = e.getScopes().filter((f) => f !== "");
    d.length > 0 && (o.scopes = d.join(","));
  }
  t.tenantId && (o.tid = t.tenantId);
  const a = o;
  for (const d of Object.keys(a))
    a[d] === void 0 && delete a[d];
  const l = await t._getAppCheckToken(), u = l ? `#${rN}=${encodeURIComponent(l)}` : "";
  return `${iN(t)}?${ma(a).slice(1)}${u}`;
}
function iN({ config: t }) {
  return t.emulator ? nh(t, nN) : `https://${t.authDomain}/${tN}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pu = "webStorageSupport";
class sN {
  constructor() {
    this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = Yv, this._completeRedirectFn = kk, this._overrideRedirectResult = Ak;
  }
  // Wrapping in async even though we don't await anywhere in order
  // to make sure errors are raised as promise rejections
  async _openPopup(e, n, r, i) {
    var s;
    Hr((s = this.eventManagers[e._key()]) === null || s === void 0 ? void 0 : s.manager, "_initialize() not called before _openPopup()");
    const o = await wg(e, n, r, Fd(), i);
    return Zk(e, o, ch());
  }
  async _openRedirect(e, n, r, i) {
    await this._originValidation(e);
    const s = await wg(e, n, r, Fd(), i);
    return ok(s), new Promise(() => {
    });
  }
  _initialize(e) {
    const n = e._key();
    if (this.eventManagers[n]) {
      const { manager: i, promise: s } = this.eventManagers[n];
      return i ? Promise.resolve(i) : (Hr(s, "If manager is not set, promise should be"), s);
    }
    const r = this.initAndGetManager(e);
    return this.eventManagers[n] = { promise: r }, r.catch(() => {
      delete this.eventManagers[n];
    }), r;
  }
  async initAndGetManager(e) {
    const n = await Hk(e), r = new Ok(e);
    return n.register("authEvent", (i) => (we(
      i == null ? void 0 : i.authEvent,
      e,
      "invalid-auth-event"
      /* AuthErrorCode.INVALID_AUTH_EVENT */
    ), {
      status: r.onEvent(i.authEvent) ? "ACK" : "ERROR"
      /* GapiOutcome.ERROR */
    }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[e._key()] = { manager: r }, this.iframes[e._key()] = n, r;
  }
  _isIframeWebStorageSupported(e, n) {
    this.iframes[e._key()].send(pu, { type: pu }, (i) => {
      var s;
      const o = (s = i == null ? void 0 : i[0]) === null || s === void 0 ? void 0 : s[pu];
      o !== void 0 && n(!!o), qn(
        e,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
  }
  _originValidation(e) {
    const n = e._key();
    return this.originValidationPromises[n] || (this.originValidationPromises[n] = Lk(e)), this.originValidationPromises[n];
  }
  get _shouldInitProactively() {
    return Bv() || Mv() || ih();
  }
}
const oN = sN;
var Tg = "@firebase/auth", Ig = "1.7.9";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aN {
  constructor(e) {
    this.auth = e, this.internalListeners = /* @__PURE__ */ new Map();
  }
  getUid() {
    var e;
    return this.assertAuthConfigured(), ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null;
  }
  async getToken(e) {
    return this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser ? { accessToken: await this.auth.currentUser.getIdToken(e) } : null;
  }
  addAuthTokenListener(e) {
    if (this.assertAuthConfigured(), this.internalListeners.has(e))
      return;
    const n = this.auth.onIdTokenChanged((r) => {
      e((r == null ? void 0 : r.stsTokenManager.accessToken) || null);
    });
    this.internalListeners.set(e, n), this.updateProactiveRefresh();
  }
  removeAuthTokenListener(e) {
    this.assertAuthConfigured();
    const n = this.internalListeners.get(e);
    n && (this.internalListeners.delete(e), n(), this.updateProactiveRefresh());
  }
  assertAuthConfigured() {
    we(
      this.auth._initializationPromise,
      "dependent-sdk-initialized-before-auth"
      /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
    );
  }
  updateProactiveRefresh() {
    this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cN(t) {
  switch (t) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    case "WebExtension":
      return "web-extension";
    default:
      return;
  }
}
function lN(t) {
  bi(new Wr(
    "auth",
    (e, { options: n }) => {
      const r = e.getProvider("app").getImmediate(), i = e.getProvider("heartbeat"), s = e.getProvider("app-check-internal"), { apiKey: o, authDomain: a } = r.options;
      we(o && !o.includes(":"), "invalid-api-key", { appName: r.name });
      const l = {
        apiKey: o,
        authDomain: a,
        clientPlatform: t,
        apiHost: "identitytoolkit.googleapis.com",
        tokenApiHost: "securetoken.googleapis.com",
        apiScheme: "https",
        sdkClientVersion: $v(t)
      }, u = new bC(r, i, s, l);
      return CC(u, n), u;
    },
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  ).setInstanceCreatedCallback((e, n, r) => {
    e.getProvider(
      "auth-internal"
      /* _ComponentName.AUTH_INTERNAL */
    ).initialize();
  })), bi(new Wr(
    "auth-internal",
    (e) => {
      const n = ir(e.getProvider(
        "auth"
        /* _ComponentName.AUTH */
      ).getImmediate());
      return ((r) => new aN(r))(n);
    },
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  )), $n(Tg, Ig, cN(t)), $n(Tg, Ig, "esm2017");
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const uN = 5 * 60, dN = bv("authIdTokenMaxAge") || uN;
let Sg = null;
const fN = (t) => async (e) => {
  const n = e && await e.getIdTokenResult(), r = n && ((/* @__PURE__ */ new Date()).getTime() - Date.parse(n.issuedAtTime)) / 1e3;
  if (r && r > dN)
    return;
  const i = n == null ? void 0 : n.token;
  Sg !== i && (Sg = i, await fetch(t, {
    method: i ? "POST" : "DELETE",
    headers: i ? {
      Authorization: `Bearer ${i}`
    } : {}
  }));
};
function UB(t = fl()) {
  const e = ga(t, "auth");
  if (e.isInitialized())
    return e.getImmediate();
  const n = RC(t, {
    popupRedirectResolver: oN,
    persistence: [
      mk,
      rk,
      Yv
    ]
  }), r = bv("authTokenSyncURL");
  if (r && typeof isSecureContext == "boolean" && isSecureContext) {
    const s = new URL(r, location.origin);
    if (location.origin === s.origin) {
      const o = fN(s.toString());
      ZC(n, o, () => o(n.currentUser)), JC(n, (a) => o(a));
    }
  }
  const i = yv("auth");
  return i && kC(n, `http://${i}`), n;
}
function hN() {
  var t, e;
  return (e = (t = document.getElementsByTagName("head")) === null || t === void 0 ? void 0 : t[0]) !== null && e !== void 0 ? e : document;
}
vC({
  loadJS(t) {
    return new Promise((e, n) => {
      const r = document.createElement("script");
      r.setAttribute("src", t), r.onload = e, r.onerror = (i) => {
        const s = er(
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
        s.customData = i, n(s);
      }, r.type = "text/javascript", r.charset = "UTF-8", hN().appendChild(r);
    });
  },
  gapiScript: "https://apis.google.com/js/api.js",
  recaptchaV2Script: "https://www.google.com/recaptcha/api.js",
  recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render="
});
lN(
  "Browser"
  /* ClientPlatform.BROWSER */
);
var Ag = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var Yi, rE;
(function() {
  var t;
  /** @license
  
   Copyright The Closure Library Authors.
   SPDX-License-Identifier: Apache-2.0
  */
  function e(I, E) {
    function T() {
    }
    T.prototype = E.prototype, I.D = E.prototype, I.prototype = new T(), I.prototype.constructor = I, I.C = function(A, R, M) {
      for (var S = Array(arguments.length - 2), D = 2; D < arguments.length; D++) S[D - 2] = arguments[D];
      return E.prototype[R].apply(A, S);
    };
  }
  function n() {
    this.blockSize = -1;
  }
  function r() {
    this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.B = Array(this.blockSize), this.o = this.h = 0, this.s();
  }
  e(r, n), r.prototype.s = function() {
    this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.o = this.h = 0;
  };
  function i(I, E, T) {
    T || (T = 0);
    var A = Array(16);
    if (typeof E == "string") for (var R = 0; 16 > R; ++R) A[R] = E.charCodeAt(T++) | E.charCodeAt(T++) << 8 | E.charCodeAt(T++) << 16 | E.charCodeAt(T++) << 24;
    else for (R = 0; 16 > R; ++R) A[R] = E[T++] | E[T++] << 8 | E[T++] << 16 | E[T++] << 24;
    E = I.g[0], T = I.g[1], R = I.g[2];
    var M = I.g[3], S = E + (M ^ T & (R ^ M)) + A[0] + 3614090360 & 4294967295;
    E = T + (S << 7 & 4294967295 | S >>> 25), S = M + (R ^ E & (T ^ R)) + A[1] + 3905402710 & 4294967295, M = E + (S << 12 & 4294967295 | S >>> 20), S = R + (T ^ M & (E ^ T)) + A[2] + 606105819 & 4294967295, R = M + (S << 17 & 4294967295 | S >>> 15), S = T + (E ^ R & (M ^ E)) + A[3] + 3250441966 & 4294967295, T = R + (S << 22 & 4294967295 | S >>> 10), S = E + (M ^ T & (R ^ M)) + A[4] + 4118548399 & 4294967295, E = T + (S << 7 & 4294967295 | S >>> 25), S = M + (R ^ E & (T ^ R)) + A[5] + 1200080426 & 4294967295, M = E + (S << 12 & 4294967295 | S >>> 20), S = R + (T ^ M & (E ^ T)) + A[6] + 2821735955 & 4294967295, R = M + (S << 17 & 4294967295 | S >>> 15), S = T + (E ^ R & (M ^ E)) + A[7] + 4249261313 & 4294967295, T = R + (S << 22 & 4294967295 | S >>> 10), S = E + (M ^ T & (R ^ M)) + A[8] + 1770035416 & 4294967295, E = T + (S << 7 & 4294967295 | S >>> 25), S = M + (R ^ E & (T ^ R)) + A[9] + 2336552879 & 4294967295, M = E + (S << 12 & 4294967295 | S >>> 20), S = R + (T ^ M & (E ^ T)) + A[10] + 4294925233 & 4294967295, R = M + (S << 17 & 4294967295 | S >>> 15), S = T + (E ^ R & (M ^ E)) + A[11] + 2304563134 & 4294967295, T = R + (S << 22 & 4294967295 | S >>> 10), S = E + (M ^ T & (R ^ M)) + A[12] + 1804603682 & 4294967295, E = T + (S << 7 & 4294967295 | S >>> 25), S = M + (R ^ E & (T ^ R)) + A[13] + 4254626195 & 4294967295, M = E + (S << 12 & 4294967295 | S >>> 20), S = R + (T ^ M & (E ^ T)) + A[14] + 2792965006 & 4294967295, R = M + (S << 17 & 4294967295 | S >>> 15), S = T + (E ^ R & (M ^ E)) + A[15] + 1236535329 & 4294967295, T = R + (S << 22 & 4294967295 | S >>> 10), S = E + (R ^ M & (T ^ R)) + A[1] + 4129170786 & 4294967295, E = T + (S << 5 & 4294967295 | S >>> 27), S = M + (T ^ R & (E ^ T)) + A[6] + 3225465664 & 4294967295, M = E + (S << 9 & 4294967295 | S >>> 23), S = R + (E ^ T & (M ^ E)) + A[11] + 643717713 & 4294967295, R = M + (S << 14 & 4294967295 | S >>> 18), S = T + (M ^ E & (R ^ M)) + A[0] + 3921069994 & 4294967295, T = R + (S << 20 & 4294967295 | S >>> 12), S = E + (R ^ M & (T ^ R)) + A[5] + 3593408605 & 4294967295, E = T + (S << 5 & 4294967295 | S >>> 27), S = M + (T ^ R & (E ^ T)) + A[10] + 38016083 & 4294967295, M = E + (S << 9 & 4294967295 | S >>> 23), S = R + (E ^ T & (M ^ E)) + A[15] + 3634488961 & 4294967295, R = M + (S << 14 & 4294967295 | S >>> 18), S = T + (M ^ E & (R ^ M)) + A[4] + 3889429448 & 4294967295, T = R + (S << 20 & 4294967295 | S >>> 12), S = E + (R ^ M & (T ^ R)) + A[9] + 568446438 & 4294967295, E = T + (S << 5 & 4294967295 | S >>> 27), S = M + (T ^ R & (E ^ T)) + A[14] + 3275163606 & 4294967295, M = E + (S << 9 & 4294967295 | S >>> 23), S = R + (E ^ T & (M ^ E)) + A[3] + 4107603335 & 4294967295, R = M + (S << 14 & 4294967295 | S >>> 18), S = T + (M ^ E & (R ^ M)) + A[8] + 1163531501 & 4294967295, T = R + (S << 20 & 4294967295 | S >>> 12), S = E + (R ^ M & (T ^ R)) + A[13] + 2850285829 & 4294967295, E = T + (S << 5 & 4294967295 | S >>> 27), S = M + (T ^ R & (E ^ T)) + A[2] + 4243563512 & 4294967295, M = E + (S << 9 & 4294967295 | S >>> 23), S = R + (E ^ T & (M ^ E)) + A[7] + 1735328473 & 4294967295, R = M + (S << 14 & 4294967295 | S >>> 18), S = T + (M ^ E & (R ^ M)) + A[12] + 2368359562 & 4294967295, T = R + (S << 20 & 4294967295 | S >>> 12), S = E + (T ^ R ^ M) + A[5] + 4294588738 & 4294967295, E = T + (S << 4 & 4294967295 | S >>> 28), S = M + (E ^ T ^ R) + A[8] + 2272392833 & 4294967295, M = E + (S << 11 & 4294967295 | S >>> 21), S = R + (M ^ E ^ T) + A[11] + 1839030562 & 4294967295, R = M + (S << 16 & 4294967295 | S >>> 16), S = T + (R ^ M ^ E) + A[14] + 4259657740 & 4294967295, T = R + (S << 23 & 4294967295 | S >>> 9), S = E + (T ^ R ^ M) + A[1] + 2763975236 & 4294967295, E = T + (S << 4 & 4294967295 | S >>> 28), S = M + (E ^ T ^ R) + A[4] + 1272893353 & 4294967295, M = E + (S << 11 & 4294967295 | S >>> 21), S = R + (M ^ E ^ T) + A[7] + 4139469664 & 4294967295, R = M + (S << 16 & 4294967295 | S >>> 16), S = T + (R ^ M ^ E) + A[10] + 3200236656 & 4294967295, T = R + (S << 23 & 4294967295 | S >>> 9), S = E + (T ^ R ^ M) + A[13] + 681279174 & 4294967295, E = T + (S << 4 & 4294967295 | S >>> 28), S = M + (E ^ T ^ R) + A[0] + 3936430074 & 4294967295, M = E + (S << 11 & 4294967295 | S >>> 21), S = R + (M ^ E ^ T) + A[3] + 3572445317 & 4294967295, R = M + (S << 16 & 4294967295 | S >>> 16), S = T + (R ^ M ^ E) + A[6] + 76029189 & 4294967295, T = R + (S << 23 & 4294967295 | S >>> 9), S = E + (T ^ R ^ M) + A[9] + 3654602809 & 4294967295, E = T + (S << 4 & 4294967295 | S >>> 28), S = M + (E ^ T ^ R) + A[12] + 3873151461 & 4294967295, M = E + (S << 11 & 4294967295 | S >>> 21), S = R + (M ^ E ^ T) + A[15] + 530742520 & 4294967295, R = M + (S << 16 & 4294967295 | S >>> 16), S = T + (R ^ M ^ E) + A[2] + 3299628645 & 4294967295, T = R + (S << 23 & 4294967295 | S >>> 9), S = E + (R ^ (T | ~M)) + A[0] + 4096336452 & 4294967295, E = T + (S << 6 & 4294967295 | S >>> 26), S = M + (T ^ (E | ~R)) + A[7] + 1126891415 & 4294967295, M = E + (S << 10 & 4294967295 | S >>> 22), S = R + (E ^ (M | ~T)) + A[14] + 2878612391 & 4294967295, R = M + (S << 15 & 4294967295 | S >>> 17), S = T + (M ^ (R | ~E)) + A[5] + 4237533241 & 4294967295, T = R + (S << 21 & 4294967295 | S >>> 11), S = E + (R ^ (T | ~M)) + A[12] + 1700485571 & 4294967295, E = T + (S << 6 & 4294967295 | S >>> 26), S = M + (T ^ (E | ~R)) + A[3] + 2399980690 & 4294967295, M = E + (S << 10 & 4294967295 | S >>> 22), S = R + (E ^ (M | ~T)) + A[10] + 4293915773 & 4294967295, R = M + (S << 15 & 4294967295 | S >>> 17), S = T + (M ^ (R | ~E)) + A[1] + 2240044497 & 4294967295, T = R + (S << 21 & 4294967295 | S >>> 11), S = E + (R ^ (T | ~M)) + A[8] + 1873313359 & 4294967295, E = T + (S << 6 & 4294967295 | S >>> 26), S = M + (T ^ (E | ~R)) + A[15] + 4264355552 & 4294967295, M = E + (S << 10 & 4294967295 | S >>> 22), S = R + (E ^ (M | ~T)) + A[6] + 2734768916 & 4294967295, R = M + (S << 15 & 4294967295 | S >>> 17), S = T + (M ^ (R | ~E)) + A[13] + 1309151649 & 4294967295, T = R + (S << 21 & 4294967295 | S >>> 11), S = E + (R ^ (T | ~M)) + A[4] + 4149444226 & 4294967295, E = T + (S << 6 & 4294967295 | S >>> 26), S = M + (T ^ (E | ~R)) + A[11] + 3174756917 & 4294967295, M = E + (S << 10 & 4294967295 | S >>> 22), S = R + (E ^ (M | ~T)) + A[2] + 718787259 & 4294967295, R = M + (S << 15 & 4294967295 | S >>> 17), S = T + (M ^ (R | ~E)) + A[9] + 3951481745 & 4294967295, I.g[0] = I.g[0] + E & 4294967295, I.g[1] = I.g[1] + (R + (S << 21 & 4294967295 | S >>> 11)) & 4294967295, I.g[2] = I.g[2] + R & 4294967295, I.g[3] = I.g[3] + M & 4294967295;
  }
  r.prototype.u = function(I, E) {
    E === void 0 && (E = I.length);
    for (var T = E - this.blockSize, A = this.B, R = this.h, M = 0; M < E; ) {
      if (R == 0) for (; M <= T; ) i(this, I, M), M += this.blockSize;
      if (typeof I == "string") {
        for (; M < E; )
          if (A[R++] = I.charCodeAt(M++), R == this.blockSize) {
            i(this, A), R = 0;
            break;
          }
      } else for (; M < E; ) if (A[R++] = I[M++], R == this.blockSize) {
        i(this, A), R = 0;
        break;
      }
    }
    this.h = R, this.o += E;
  }, r.prototype.v = function() {
    var I = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
    I[0] = 128;
    for (var E = 1; E < I.length - 8; ++E) I[E] = 0;
    var T = 8 * this.o;
    for (E = I.length - 8; E < I.length; ++E) I[E] = T & 255, T /= 256;
    for (this.u(I), I = Array(16), E = T = 0; 4 > E; ++E) for (var A = 0; 32 > A; A += 8) I[T++] = this.g[E] >>> A & 255;
    return I;
  };
  function s(I, E) {
    var T = a;
    return Object.prototype.hasOwnProperty.call(T, I) ? T[I] : T[I] = E(I);
  }
  function o(I, E) {
    this.h = E;
    for (var T = [], A = !0, R = I.length - 1; 0 <= R; R--) {
      var M = I[R] | 0;
      A && M == E || (T[R] = M, A = !1);
    }
    this.g = T;
  }
  var a = {};
  function l(I) {
    return -128 <= I && 128 > I ? s(I, function(E) {
      return new o([E | 0], 0 > E ? -1 : 0);
    }) : new o([I | 0], 0 > I ? -1 : 0);
  }
  function u(I) {
    if (isNaN(I) || !isFinite(I)) return f;
    if (0 > I) return m(u(-I));
    for (var E = [], T = 1, A = 0; I >= T; A++) E[A] = I / T | 0, T *= 4294967296;
    return new o(E, 0);
  }
  function d(I, E) {
    if (I.length == 0) throw Error("number format error: empty string");
    if (E = E || 10, 2 > E || 36 < E) throw Error("radix out of range: " + E);
    if (I.charAt(0) == "-") return m(d(I.substring(1), E));
    if (0 <= I.indexOf("-")) throw Error('number format error: interior "-" character');
    for (var T = u(Math.pow(E, 8)), A = f, R = 0; R < I.length; R += 8) {
      var M = Math.min(8, I.length - R), S = parseInt(I.substring(R, R + M), E);
      8 > M ? (M = u(Math.pow(E, M)), A = A.j(M).add(u(S))) : (A = A.j(T), A = A.add(u(S)));
    }
    return A;
  }
  var f = l(0), p = l(1), g = l(16777216);
  t = o.prototype, t.m = function() {
    if (b(this)) return -m(this).m();
    for (var I = 0, E = 1, T = 0; T < this.g.length; T++) {
      var A = this.i(T);
      I += (0 <= A ? A : 4294967296 + A) * E, E *= 4294967296;
    }
    return I;
  }, t.toString = function(I) {
    if (I = I || 10, 2 > I || 36 < I) throw Error("radix out of range: " + I);
    if (_(this)) return "0";
    if (b(this)) return "-" + m(this).toString(I);
    for (var E = u(Math.pow(I, 6)), T = this, A = ""; ; ) {
      var R = P(T, E).g;
      T = v(T, R.j(E));
      var M = ((0 < T.g.length ? T.g[0] : T.h) >>> 0).toString(I);
      if (T = R, _(T)) return M + A;
      for (; 6 > M.length; ) M = "0" + M;
      A = M + A;
    }
  }, t.i = function(I) {
    return 0 > I ? 0 : I < this.g.length ? this.g[I] : this.h;
  };
  function _(I) {
    if (I.h != 0) return !1;
    for (var E = 0; E < I.g.length; E++) if (I.g[E] != 0) return !1;
    return !0;
  }
  function b(I) {
    return I.h == -1;
  }
  t.l = function(I) {
    return I = v(this, I), b(I) ? -1 : _(I) ? 0 : 1;
  };
  function m(I) {
    for (var E = I.g.length, T = [], A = 0; A < E; A++) T[A] = ~I.g[A];
    return new o(T, ~I.h).add(p);
  }
  t.abs = function() {
    return b(this) ? m(this) : this;
  }, t.add = function(I) {
    for (var E = Math.max(this.g.length, I.g.length), T = [], A = 0, R = 0; R <= E; R++) {
      var M = A + (this.i(R) & 65535) + (I.i(R) & 65535), S = (M >>> 16) + (this.i(R) >>> 16) + (I.i(R) >>> 16);
      A = S >>> 16, M &= 65535, S &= 65535, T[R] = S << 16 | M;
    }
    return new o(T, T[T.length - 1] & -2147483648 ? -1 : 0);
  };
  function v(I, E) {
    return I.add(m(E));
  }
  t.j = function(I) {
    if (_(this) || _(I)) return f;
    if (b(this)) return b(I) ? m(this).j(m(I)) : m(m(this).j(I));
    if (b(I)) return m(this.j(m(I)));
    if (0 > this.l(g) && 0 > I.l(g)) return u(this.m() * I.m());
    for (var E = this.g.length + I.g.length, T = [], A = 0; A < 2 * E; A++) T[A] = 0;
    for (A = 0; A < this.g.length; A++) for (var R = 0; R < I.g.length; R++) {
      var M = this.i(A) >>> 16, S = this.i(A) & 65535, D = I.i(R) >>> 16, V = I.i(R) & 65535;
      T[2 * A + 2 * R] += S * V, C(T, 2 * A + 2 * R), T[2 * A + 2 * R + 1] += M * V, C(T, 2 * A + 2 * R + 1), T[2 * A + 2 * R + 1] += S * D, C(T, 2 * A + 2 * R + 1), T[2 * A + 2 * R + 2] += M * D, C(T, 2 * A + 2 * R + 2);
    }
    for (A = 0; A < E; A++) T[A] = T[2 * A + 1] << 16 | T[2 * A];
    for (A = E; A < 2 * E; A++) T[A] = 0;
    return new o(T, 0);
  };
  function C(I, E) {
    for (; (I[E] & 65535) != I[E]; ) I[E + 1] += I[E] >>> 16, I[E] &= 65535, E++;
  }
  function x(I, E) {
    this.g = I, this.h = E;
  }
  function P(I, E) {
    if (_(E)) throw Error("division by zero");
    if (_(I)) return new x(f, f);
    if (b(I)) return E = P(m(I), E), new x(m(E.g), m(E.h));
    if (b(E)) return E = P(I, m(E)), new x(m(E.g), E.h);
    if (30 < I.g.length) {
      if (b(I) || b(E)) throw Error("slowDivide_ only works with positive integers.");
      for (var T = p, A = E; 0 >= A.l(I); ) T = k(T), A = k(A);
      var R = U(T, 1), M = U(A, 1);
      for (A = U(A, 2), T = U(T, 2); !_(A); ) {
        var S = M.add(A);
        0 >= S.l(I) && (R = R.add(T), M = S), A = U(A, 1), T = U(T, 1);
      }
      return E = v(I, R.j(E)), new x(R, E);
    }
    for (R = f; 0 <= I.l(E); ) {
      for (T = Math.max(1, Math.floor(I.m() / E.m())), A = Math.ceil(Math.log(T) / Math.LN2), A = 48 >= A ? 1 : Math.pow(2, A - 48), M = u(T), S = M.j(E); b(S) || 0 < S.l(I); ) T -= A, M = u(T), S = M.j(E);
      _(M) && (M = p), R = R.add(M), I = v(I, S);
    }
    return new x(R, I);
  }
  t.A = function(I) {
    return P(this, I).h;
  }, t.and = function(I) {
    for (var E = Math.max(this.g.length, I.g.length), T = [], A = 0; A < E; A++) T[A] = this.i(A) & I.i(A);
    return new o(T, this.h & I.h);
  }, t.or = function(I) {
    for (var E = Math.max(this.g.length, I.g.length), T = [], A = 0; A < E; A++) T[A] = this.i(A) | I.i(A);
    return new o(T, this.h | I.h);
  }, t.xor = function(I) {
    for (var E = Math.max(this.g.length, I.g.length), T = [], A = 0; A < E; A++) T[A] = this.i(A) ^ I.i(A);
    return new o(T, this.h ^ I.h);
  };
  function k(I) {
    for (var E = I.g.length + 1, T = [], A = 0; A < E; A++) T[A] = I.i(A) << 1 | I.i(A - 1) >>> 31;
    return new o(T, I.h);
  }
  function U(I, E) {
    var T = E >> 5;
    E %= 32;
    for (var A = I.g.length - T, R = [], M = 0; M < A; M++) R[M] = 0 < E ? I.i(M + T) >>> E | I.i(M + T + 1) << 32 - E : I.i(M + T);
    return new o(R, I.h);
  }
  r.prototype.digest = r.prototype.v, r.prototype.reset = r.prototype.s, r.prototype.update = r.prototype.u, rE = r, o.prototype.add = o.prototype.add, o.prototype.multiply = o.prototype.j, o.prototype.modulo = o.prototype.A, o.prototype.compare = o.prototype.l, o.prototype.toNumber = o.prototype.m, o.prototype.toString = o.prototype.toString, o.prototype.getBits = o.prototype.i, o.fromNumber = u, o.fromString = d, Yi = o;
}).apply(typeof Ag < "u" ? Ag : typeof self < "u" ? self : typeof window < "u" ? window : {});
var Xa = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var iE, xo, sE, mc, $d, oE, aE, cE;
(function() {
  var t, e = typeof Object.defineProperties == "function" ? Object.defineProperty : function(c, h, y) {
    return c == Array.prototype || c == Object.prototype || (c[h] = y.value), c;
  };
  function n(c) {
    c = [typeof globalThis == "object" && globalThis, c, typeof window == "object" && window, typeof self == "object" && self, typeof Xa == "object" && Xa];
    for (var h = 0; h < c.length; ++h) {
      var y = c[h];
      if (y && y.Math == Math) return y;
    }
    throw Error("Cannot find global object");
  }
  var r = n(this);
  function i(c, h) {
    if (h) e: {
      var y = r;
      c = c.split(".");
      for (var w = 0; w < c.length - 1; w++) {
        var L = c[w];
        if (!(L in y)) break e;
        y = y[L];
      }
      c = c[c.length - 1], w = y[c], h = h(w), h != w && h != null && e(y, c, { configurable: !0, writable: !0, value: h });
    }
  }
  function s(c, h) {
    c instanceof String && (c += "");
    var y = 0, w = !1, L = { next: function() {
      if (!w && y < c.length) {
        var F = y++;
        return { value: h(F, c[F]), done: !1 };
      }
      return w = !0, { done: !0, value: void 0 };
    } };
    return L[Symbol.iterator] = function() {
      return L;
    }, L;
  }
  i("Array.prototype.values", function(c) {
    return c || function() {
      return s(this, function(h, y) {
        return y;
      });
    };
  });
  /** @license
  
   Copyright The Closure Library Authors.
   SPDX-License-Identifier: Apache-2.0
  */
  var o = o || {}, a = this || self;
  function l(c) {
    var h = typeof c;
    return h = h != "object" ? h : c ? Array.isArray(c) ? "array" : h : "null", h == "array" || h == "object" && typeof c.length == "number";
  }
  function u(c) {
    var h = typeof c;
    return h == "object" && c != null || h == "function";
  }
  function d(c, h, y) {
    return c.call.apply(c.bind, arguments);
  }
  function f(c, h, y) {
    if (!c) throw Error();
    if (2 < arguments.length) {
      var w = Array.prototype.slice.call(arguments, 2);
      return function() {
        var L = Array.prototype.slice.call(arguments);
        return Array.prototype.unshift.apply(L, w), c.apply(h, L);
      };
    }
    return function() {
      return c.apply(h, arguments);
    };
  }
  function p(c, h, y) {
    return p = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? d : f, p.apply(null, arguments);
  }
  function g(c, h) {
    var y = Array.prototype.slice.call(arguments, 1);
    return function() {
      var w = y.slice();
      return w.push.apply(w, arguments), c.apply(this, w);
    };
  }
  function _(c, h) {
    function y() {
    }
    y.prototype = h.prototype, c.aa = h.prototype, c.prototype = new y(), c.prototype.constructor = c, c.Qb = function(w, L, F) {
      for (var Z = Array(arguments.length - 2), ut = 2; ut < arguments.length; ut++) Z[ut - 2] = arguments[ut];
      return h.prototype[L].apply(w, Z);
    };
  }
  function b(c) {
    const h = c.length;
    if (0 < h) {
      const y = Array(h);
      for (let w = 0; w < h; w++) y[w] = c[w];
      return y;
    }
    return [];
  }
  function m(c, h) {
    for (let y = 1; y < arguments.length; y++) {
      const w = arguments[y];
      if (l(w)) {
        const L = c.length || 0, F = w.length || 0;
        c.length = L + F;
        for (let Z = 0; Z < F; Z++) c[L + Z] = w[Z];
      } else c.push(w);
    }
  }
  class v {
    constructor(h, y) {
      this.i = h, this.j = y, this.h = 0, this.g = null;
    }
    get() {
      let h;
      return 0 < this.h ? (this.h--, h = this.g, this.g = h.next, h.next = null) : h = this.i(), h;
    }
  }
  function C(c) {
    return /^[\s\xa0]*$/.test(c);
  }
  function x() {
    var c = a.navigator;
    return c && (c = c.userAgent) ? c : "";
  }
  function P(c) {
    return P[" "](c), c;
  }
  P[" "] = function() {
  };
  var k = x().indexOf("Gecko") != -1 && !(x().toLowerCase().indexOf("webkit") != -1 && x().indexOf("Edge") == -1) && !(x().indexOf("Trident") != -1 || x().indexOf("MSIE") != -1) && x().indexOf("Edge") == -1;
  function U(c, h, y) {
    for (const w in c) h.call(y, c[w], w, c);
  }
  function I(c, h) {
    for (const y in c) h.call(void 0, c[y], y, c);
  }
  function E(c) {
    const h = {};
    for (const y in c) h[y] = c[y];
    return h;
  }
  const T = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  function A(c, h) {
    let y, w;
    for (let L = 1; L < arguments.length; L++) {
      w = arguments[L];
      for (y in w) c[y] = w[y];
      for (let F = 0; F < T.length; F++) y = T[F], Object.prototype.hasOwnProperty.call(w, y) && (c[y] = w[y]);
    }
  }
  function R(c) {
    var h = 1;
    c = c.split(":");
    const y = [];
    for (; 0 < h && c.length; ) y.push(c.shift()), h--;
    return c.length && y.push(c.join(":")), y;
  }
  function M(c) {
    a.setTimeout(() => {
      throw c;
    }, 0);
  }
  function S() {
    var c = Ie;
    let h = null;
    return c.g && (h = c.g, c.g = c.g.next, c.g || (c.h = null), h.next = null), h;
  }
  class D {
    constructor() {
      this.h = this.g = null;
    }
    add(h, y) {
      const w = V.get();
      w.set(h, y), this.h ? this.h.next = w : this.g = w, this.h = w;
    }
  }
  var V = new v(() => new X(), (c) => c.reset());
  class X {
    constructor() {
      this.next = this.g = this.h = null;
    }
    set(h, y) {
      this.h = h, this.g = y, this.next = null;
    }
    reset() {
      this.next = this.g = this.h = null;
    }
  }
  let ge, Te = !1, Ie = new D(), B = () => {
    const c = a.Promise.resolve(void 0);
    ge = () => {
      c.then(q);
    };
  };
  var q = () => {
    for (var c; c = S(); ) {
      try {
        c.h.call(c.g);
      } catch (y) {
        M(y);
      }
      var h = V;
      h.j(c), 100 > h.h && (h.h++, c.next = h.g, h.g = c);
    }
    Te = !1;
  };
  function se() {
    this.s = this.s, this.C = this.C;
  }
  se.prototype.s = !1, se.prototype.ma = function() {
    this.s || (this.s = !0, this.N());
  }, se.prototype.N = function() {
    if (this.C) for (; this.C.length; ) this.C.shift()();
  };
  function re(c, h) {
    this.type = c, this.g = this.target = h, this.defaultPrevented = !1;
  }
  re.prototype.h = function() {
    this.defaultPrevented = !0;
  };
  var ae = function() {
    if (!a.addEventListener || !Object.defineProperty) return !1;
    var c = !1, h = Object.defineProperty({}, "passive", { get: function() {
      c = !0;
    } });
    try {
      const y = () => {
      };
      a.addEventListener("test", y, h), a.removeEventListener("test", y, h);
    } catch {
    }
    return c;
  }();
  function ce(c, h) {
    if (re.call(this, c ? c.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, c) {
      var y = this.type = c.type, w = c.changedTouches && c.changedTouches.length ? c.changedTouches[0] : null;
      if (this.target = c.target || c.srcElement, this.g = h, h = c.relatedTarget) {
        if (k) {
          e: {
            try {
              P(h.nodeName);
              var L = !0;
              break e;
            } catch {
            }
            L = !1;
          }
          L || (h = null);
        }
      } else y == "mouseover" ? h = c.fromElement : y == "mouseout" && (h = c.toElement);
      this.relatedTarget = h, w ? (this.clientX = w.clientX !== void 0 ? w.clientX : w.pageX, this.clientY = w.clientY !== void 0 ? w.clientY : w.pageY, this.screenX = w.screenX || 0, this.screenY = w.screenY || 0) : (this.clientX = c.clientX !== void 0 ? c.clientX : c.pageX, this.clientY = c.clientY !== void 0 ? c.clientY : c.pageY, this.screenX = c.screenX || 0, this.screenY = c.screenY || 0), this.button = c.button, this.key = c.key || "", this.ctrlKey = c.ctrlKey, this.altKey = c.altKey, this.shiftKey = c.shiftKey, this.metaKey = c.metaKey, this.pointerId = c.pointerId || 0, this.pointerType = typeof c.pointerType == "string" ? c.pointerType : pe[c.pointerType] || "", this.state = c.state, this.i = c, c.defaultPrevented && ce.aa.h.call(this);
    }
  }
  _(ce, re);
  var pe = { 2: "touch", 3: "pen", 4: "mouse" };
  ce.prototype.h = function() {
    ce.aa.h.call(this);
    var c = this.i;
    c.preventDefault ? c.preventDefault() : c.returnValue = !1;
  };
  var ie = "closure_listenable_" + (1e6 * Math.random() | 0), le = 0;
  function Se(c, h, y, w, L) {
    this.listener = c, this.proxy = null, this.src = h, this.type = y, this.capture = !!w, this.ha = L, this.key = ++le, this.da = this.fa = !1;
  }
  function de(c) {
    c.da = !0, c.listener = null, c.proxy = null, c.src = null, c.ha = null;
  }
  function Le(c) {
    this.src = c, this.g = {}, this.h = 0;
  }
  Le.prototype.add = function(c, h, y, w, L) {
    var F = c.toString();
    c = this.g[F], c || (c = this.g[F] = [], this.h++);
    var Z = Qe(c, h, w, L);
    return -1 < Z ? (h = c[Z], y || (h.fa = !1)) : (h = new Se(h, this.src, F, !!w, L), h.fa = y, c.push(h)), h;
  };
  function K(c, h) {
    var y = h.type;
    if (y in c.g) {
      var w = c.g[y], L = Array.prototype.indexOf.call(w, h, void 0), F;
      (F = 0 <= L) && Array.prototype.splice.call(w, L, 1), F && (de(h), c.g[y].length == 0 && (delete c.g[y], c.h--));
    }
  }
  function Qe(c, h, y, w) {
    for (var L = 0; L < c.length; ++L) {
      var F = c[L];
      if (!F.da && F.listener == h && F.capture == !!y && F.ha == w) return L;
    }
    return -1;
  }
  var ue = "closure_lm_" + (1e6 * Math.random() | 0), Ut = {};
  function Ft(c, h, y, w, L) {
    if (Array.isArray(h)) {
      for (var F = 0; F < h.length; F++) Ft(c, h[F], y, w, L);
      return null;
    }
    return y = En(y), c && c[ie] ? c.K(h, y, u(w) ? !!w.capture : !1, L) : kn(c, h, y, !1, w, L);
  }
  function kn(c, h, y, w, L, F) {
    if (!h) throw Error("Invalid event type");
    var Z = u(L) ? !!L.capture : !!L, ut = ar(c);
    if (ut || (c[ue] = ut = new Le(c)), y = ut.add(h, y, w, Z, F), y.proxy) return y;
    if (w = Ir(), y.proxy = w, w.src = c, w.listener = y, c.addEventListener) ae || (L = Z), L === void 0 && (L = !1), c.addEventListener(h.toString(), w, L);
    else if (c.attachEvent) c.attachEvent(or(h.toString()), w);
    else if (c.addListener && c.removeListener) c.addListener(w);
    else throw Error("addEventListener and attachEvent are unavailable.");
    return y;
  }
  function Ir() {
    function c(y) {
      return h.call(c.src, c.listener, y);
    }
    const h = Sr;
    return c;
  }
  function zn(c, h, y, w, L) {
    if (Array.isArray(h)) for (var F = 0; F < h.length; F++) zn(c, h[F], y, w, L);
    else w = u(w) ? !!w.capture : !!w, y = En(y), c && c[ie] ? (c = c.i, h = String(h).toString(), h in c.g && (F = c.g[h], y = Qe(F, y, w, L), -1 < y && (de(F[y]), Array.prototype.splice.call(F, y, 1), F.length == 0 && (delete c.g[h], c.h--)))) : c && (c = ar(c)) && (h = c.g[h.toString()], c = -1, h && (c = Qe(h, y, w, L)), (y = -1 < c ? h[c] : null) && sr(y));
  }
  function sr(c) {
    if (typeof c != "number" && c && !c.da) {
      var h = c.src;
      if (h && h[ie]) K(h.i, c);
      else {
        var y = c.type, w = c.proxy;
        h.removeEventListener ? h.removeEventListener(y, w, c.capture) : h.detachEvent ? h.detachEvent(or(y), w) : h.addListener && h.removeListener && h.removeListener(w), (y = ar(h)) ? (K(y, c), y.h == 0 && (y.src = null, h[ue] = null)) : de(c);
      }
    }
  }
  function or(c) {
    return c in Ut ? Ut[c] : Ut[c] = "on" + c;
  }
  function Sr(c, h) {
    if (c.da) c = !0;
    else {
      h = new ce(h, this);
      var y = c.listener, w = c.ha || c.src;
      c.fa && sr(c), c = y.call(w, h);
    }
    return c;
  }
  function ar(c) {
    return c = c[ue], c instanceof Le ? c : null;
  }
  var un = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
  function En(c) {
    return typeof c == "function" ? c : (c[un] || (c[un] = function(h) {
      return c.handleEvent(h);
    }), c[un]);
  }
  function We() {
    se.call(this), this.i = new Le(this), this.M = this, this.F = null;
  }
  _(We, se), We.prototype[ie] = !0, We.prototype.removeEventListener = function(c, h, y, w) {
    zn(this, c, h, y, w);
  };
  function gt(c, h) {
    var y, w = c.F;
    if (w) for (y = []; w; w = w.F) y.push(w);
    if (c = c.M, w = h.type || h, typeof h == "string") h = new re(h, c);
    else if (h instanceof re) h.target = h.target || c;
    else {
      var L = h;
      h = new re(w, c), A(h, L);
    }
    if (L = !0, y) for (var F = y.length - 1; 0 <= F; F--) {
      var Z = h.g = y[F];
      L = Wn(Z, w, !0, h) && L;
    }
    if (Z = h.g = c, L = Wn(Z, w, !0, h) && L, L = Wn(Z, w, !1, h) && L, y) for (F = 0; F < y.length; F++) Z = h.g = y[F], L = Wn(Z, w, !1, h) && L;
  }
  We.prototype.N = function() {
    if (We.aa.N.call(this), this.i) {
      var c = this.i, h;
      for (h in c.g) {
        for (var y = c.g[h], w = 0; w < y.length; w++) de(y[w]);
        delete c.g[h], c.h--;
      }
    }
    this.F = null;
  }, We.prototype.K = function(c, h, y, w) {
    return this.i.add(String(c), h, !1, y, w);
  }, We.prototype.L = function(c, h, y, w) {
    return this.i.add(String(c), h, !0, y, w);
  };
  function Wn(c, h, y, w) {
    if (h = c.i.g[String(h)], !h) return !0;
    h = h.concat();
    for (var L = !0, F = 0; F < h.length; ++F) {
      var Z = h[F];
      if (Z && !Z.da && Z.capture == y) {
        var ut = Z.listener, jt = Z.ha || Z.src;
        Z.fa && K(c.i, Z), L = ut.call(jt, w) !== !1 && L;
      }
    }
    return L && !w.defaultPrevented;
  }
  function cr(c, h, y) {
    if (typeof c == "function") y && (c = p(c, y));
    else if (c && typeof c.handleEvent == "function") c = p(c.handleEvent, c);
    else throw Error("Invalid listener argument");
    return 2147483647 < Number(h) ? -1 : a.setTimeout(c, h || 0);
  }
  function Gn(c) {
    c.g = cr(() => {
      c.g = null, c.i && (c.i = !1, Gn(c));
    }, c.l);
    const h = c.h;
    c.h = null, c.m.apply(null, h);
  }
  class Oi extends se {
    constructor(h, y) {
      super(), this.m = h, this.l = y, this.h = null, this.i = !1, this.g = null;
    }
    j(h) {
      this.h = arguments, this.g ? this.i = !0 : Gn(this);
    }
    N() {
      super.N(), this.g && (a.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null);
    }
  }
  function Nn(c) {
    se.call(this), this.h = c, this.g = {};
  }
  _(Nn, se);
  var ti = [];
  function Ar(c) {
    U(c.g, function(h, y) {
      this.g.hasOwnProperty(y) && sr(h);
    }, c), c.g = {};
  }
  Nn.prototype.N = function() {
    Nn.aa.N.call(this), Ar(this);
  }, Nn.prototype.handleEvent = function() {
    throw Error("EventHandler.handleEvent not implemented");
  };
  var Rr = a.JSON.stringify, Pi = a.JSON.parse, xi = class {
    stringify(c) {
      return a.JSON.stringify(c, void 0);
    }
    parse(c) {
      return a.JSON.parse(c, void 0);
    }
  };
  function wn() {
  }
  wn.prototype.h = null;
  function lr(c) {
    return c.h || (c.h = c.i());
  }
  function Ue() {
  }
  var Zt = { OPEN: "a", kb: "b", Ja: "c", wb: "d" };
  function en() {
    re.call(this, "d");
  }
  _(en, re);
  function dn() {
    re.call(this, "c");
  }
  _(dn, re);
  var N = {}, $ = null;
  function Q() {
    return $ = $ || new We();
  }
  N.La = "serverreachability";
  function Re(c) {
    re.call(this, N.La, c);
  }
  _(Re, re);
  function Je(c) {
    const h = Q();
    gt(h, new Re(h));
  }
  N.STAT_EVENT = "statevent";
  function dt(c, h) {
    re.call(this, N.STAT_EVENT, c), this.stat = h;
  }
  _(dt, re);
  function ee(c) {
    const h = Q();
    gt(h, new dt(h, c));
  }
  N.Ma = "timingevent";
  function oe(c, h) {
    re.call(this, N.Ma, c), this.size = h;
  }
  _(oe, re);
  function Ee(c, h) {
    if (typeof c != "function") throw Error("Fn must not be null and must be a function");
    return a.setTimeout(function() {
      c();
    }, h);
  }
  function ft() {
    this.g = !0;
  }
  ft.prototype.xa = function() {
    this.g = !1;
  };
  function _t(c, h, y, w, L, F) {
    c.info(function() {
      if (c.g) if (F)
        for (var Z = "", ut = F.split("&"), jt = 0; jt < ut.length; jt++) {
          var Ye = ut[jt].split("=");
          if (1 < Ye.length) {
            var nn = Ye[0];
            Ye = Ye[1];
            var rn = nn.split("_");
            Z = 2 <= rn.length && rn[1] == "type" ? Z + (nn + "=" + Ye + "&") : Z + (nn + "=redacted&");
          }
        }
      else Z = null;
      else Z = F;
      return "XMLHTTP REQ (" + w + ") [attempt " + L + "]: " + h + `
` + y + `
` + Z;
    });
  }
  function Cr(c, h, y, w, L, F, Z) {
    c.info(function() {
      return "XMLHTTP RESP (" + w + ") [ attempt " + L + "]: " + h + `
` + y + `
` + F + " " + Z;
    });
  }
  function On(c, h, y, w) {
    c.info(function() {
      return "XMLHTTP TEXT (" + h + "): " + z(c, y) + (w ? " " + w : "");
    });
  }
  function O(c, h) {
    c.info(function() {
      return "TIMEOUT: " + h;
    });
  }
  ft.prototype.info = function() {
  };
  function z(c, h) {
    if (!c.g) return h;
    if (!h) return null;
    try {
      var y = JSON.parse(h);
      if (y) {
        for (c = 0; c < y.length; c++) if (Array.isArray(y[c])) {
          var w = y[c];
          if (!(2 > w.length)) {
            var L = w[1];
            if (Array.isArray(L) && !(1 > L.length)) {
              var F = L[0];
              if (F != "noop" && F != "stop" && F != "close") for (var Z = 1; Z < L.length; Z++) L[Z] = "";
            }
          }
        }
      }
      return Rr(y);
    } catch {
      return h;
    }
  }
  var te = { NO_ERROR: 0, gb: 1, tb: 2, sb: 3, nb: 4, rb: 5, ub: 6, Ia: 7, TIMEOUT: 8, xb: 9 }, Ae = { lb: "complete", Hb: "success", Ja: "error", Ia: "abort", zb: "ready", Ab: "readystatechange", TIMEOUT: "timeout", vb: "incrementaldata", yb: "progress", ob: "downloadprogress", Pb: "uploadprogress" }, $e;
  function Ge() {
  }
  _(Ge, wn), Ge.prototype.g = function() {
    return new XMLHttpRequest();
  }, Ge.prototype.i = function() {
    return {};
  }, $e = new Ge();
  function ke(c, h, y, w) {
    this.j = c, this.i = h, this.l = y, this.R = w || 1, this.U = new Nn(this), this.I = 45e3, this.H = null, this.o = !1, this.m = this.A = this.v = this.L = this.F = this.S = this.B = null, this.D = [], this.g = null, this.C = 0, this.s = this.u = null, this.X = -1, this.J = !1, this.O = 0, this.M = null, this.W = this.K = this.T = this.P = !1, this.h = new Oe();
  }
  function Oe() {
    this.i = null, this.g = "", this.h = !1;
  }
  var xt = {}, lt = {};
  function ht(c, h, y) {
    c.L = 1, c.v = ps(Hn(h)), c.m = y, c.P = !0, bt(c, null);
  }
  function bt(c, h) {
    c.F = Date.now(), Nt(c), c.A = Hn(c.v);
    var y = c.A, w = c.R;
    Array.isArray(w) || (w = [String(w)]), Ke(y.i, "t", w), c.C = 0, y = c.j.J, c.h = new Oe(), c.g = Hp(c.j, y ? h : null, !c.m), 0 < c.O && (c.M = new Oi(p(c.Y, c, c.g), c.O)), h = c.U, y = c.g, w = c.ca;
    var L = "readystatechange";
    Array.isArray(L) || (L && (ti[0] = L.toString()), L = ti);
    for (var F = 0; F < L.length; F++) {
      var Z = Ft(y, L[F], w || h.handleEvent, !1, h.h || h);
      if (!Z) break;
      h.g[Z.key] = Z;
    }
    h = c.H ? E(c.H) : {}, c.m ? (c.u || (c.u = "POST"), h["Content-Type"] = "application/x-www-form-urlencoded", c.g.ea(
      c.A,
      c.u,
      c.m,
      h
    )) : (c.u = "GET", c.g.ea(c.A, c.u, null, h)), Je(), _t(c.i, c.u, c.A, c.l, c.R, c.m);
  }
  ke.prototype.ca = function(c) {
    c = c.target;
    const h = this.M;
    h && Dr(c) == 3 ? h.j() : this.Y(c);
  }, ke.prototype.Y = function(c) {
    try {
      if (c == this.g) e: {
        const rn = Dr(this.g);
        var h = this.g.Ba();
        const ys = this.g.Z();
        if (!(3 > rn) && (rn != 3 || this.g && (this.h.h || this.g.oa() || Lp(this.g)))) {
          this.J || rn != 4 || h == 7 || (h == 8 || 0 >= ys ? Je(3) : Je(2)), Mi(this);
          var y = this.g.Z();
          this.X = y;
          t: if (Pn(this)) {
            var w = Lp(this.g);
            c = "";
            var L = w.length, F = Dr(this.g) == 4;
            if (!this.h.i) {
              if (typeof TextDecoder > "u") {
                kr(this), Mn(this);
                var Z = "";
                break t;
              }
              this.h.i = new a.TextDecoder();
            }
            for (h = 0; h < L; h++) this.h.h = !0, c += this.h.i.decode(w[h], { stream: !(F && h == L - 1) });
            w.length = 0, this.h.g += c, this.C = 0, Z = this.h.g;
          } else Z = this.g.oa();
          if (this.o = y == 200, Cr(this.i, this.u, this.A, this.l, this.R, rn, y), this.o) {
            if (this.T && !this.K) {
              t: {
                if (this.g) {
                  var ut, jt = this.g;
                  if ((ut = jt.g ? jt.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !C(ut)) {
                    var Ye = ut;
                    break t;
                  }
                }
                Ye = null;
              }
              if (y = Ye) On(this.i, this.l, y, "Initial handshake response via X-HTTP-Initial-Response"), this.K = !0, Y(this, y);
              else {
                this.o = !1, this.s = 3, ee(12), kr(this), Mn(this);
                break e;
              }
            }
            if (this.P) {
              y = !0;
              let Yn;
              for (; !this.J && this.C < Z.length; ) if (Yn = xn(this, Z), Yn == lt) {
                rn == 4 && (this.s = 4, ee(14), y = !1), On(this.i, this.l, null, "[Incomplete Response]");
                break;
              } else if (Yn == xt) {
                this.s = 4, ee(15), On(this.i, this.l, Z, "[Invalid Chunk]"), y = !1;
                break;
              } else On(this.i, this.l, Yn, null), Y(this, Yn);
              if (Pn(this) && this.C != 0 && (this.h.g = this.h.g.slice(this.C), this.C = 0), rn != 4 || Z.length != 0 || this.h.h || (this.s = 1, ee(16), y = !1), this.o = this.o && y, !y) On(this.i, this.l, Z, "[Invalid Chunked Response]"), kr(this), Mn(this);
              else if (0 < Z.length && !this.W) {
                this.W = !0;
                var nn = this.j;
                nn.g == this && nn.ba && !nn.M && (nn.j.info("Great, no buffering proxy detected. Bytes received: " + Z.length), Jl(nn), nn.M = !0, ee(11));
              }
            } else On(this.i, this.l, Z, null), Y(this, Z);
            rn == 4 && kr(this), this.o && !this.J && (rn == 4 ? qp(this.j, this) : (this.o = !1, Nt(this)));
          } else iI(this.g), y == 400 && 0 < Z.indexOf("Unknown SID") ? (this.s = 3, ee(12)) : (this.s = 0, ee(13)), kr(this), Mn(this);
        }
      }
    } catch {
    } finally {
    }
  };
  function Pn(c) {
    return c.g ? c.u == "GET" && c.L != 2 && c.j.Ca : !1;
  }
  function xn(c, h) {
    var y = c.C, w = h.indexOf(`
`, y);
    return w == -1 ? lt : (y = Number(h.substring(y, w)), isNaN(y) ? xt : (w += 1, w + y > h.length ? lt : (h = h.slice(w, w + y), c.C = w + y, h)));
  }
  ke.prototype.cancel = function() {
    this.J = !0, kr(this);
  };
  function Nt(c) {
    c.S = Date.now() + c.I, ni(c, c.I);
  }
  function ni(c, h) {
    if (c.B != null) throw Error("WatchDog timer not null");
    c.B = Ee(p(c.ba, c), h);
  }
  function Mi(c) {
    c.B && (a.clearTimeout(c.B), c.B = null);
  }
  ke.prototype.ba = function() {
    this.B = null;
    const c = Date.now();
    0 <= c - this.S ? (O(this.i, this.A), this.L != 2 && (Je(), ee(17)), kr(this), this.s = 2, Mn(this)) : ni(this, this.S - c);
  };
  function Mn(c) {
    c.j.G == 0 || c.J || qp(c.j, c);
  }
  function kr(c) {
    Mi(c);
    var h = c.M;
    h && typeof h.ma == "function" && h.ma(), c.M = null, Ar(c.U), c.g && (h = c.g, c.g = null, h.abort(), h.ma());
  }
  function Y(c, h) {
    try {
      var y = c.j;
      if (y.G != 0 && (y.g == c || fn(y.h, c))) {
        if (!c.K && fn(y.h, c) && y.G == 3) {
          try {
            var w = y.Da.g.parse(h);
          } catch {
            w = null;
          }
          if (Array.isArray(w) && w.length == 3) {
            var L = w;
            if (L[0] == 0) {
              e:
                if (!y.u) {
                  if (y.g) if (y.g.F + 3e3 < c.F) Ua(y), Da(y);
                  else break e;
                  Ql(y), ee(18);
                }
            } else y.za = L[1], 0 < y.za - y.T && 37500 > L[2] && y.F && y.v == 0 && !y.C && (y.C = Ee(p(y.Za, y), 6e3));
            if (1 >= It(y.h) && y.ca) {
              try {
                y.ca();
              } catch {
              }
              y.ca = void 0;
            }
          } else Li(y, 11);
        } else if ((c.K || y.g == c) && Ua(y), !C(h)) for (L = y.Da.g.parse(h), h = 0; h < L.length; h++) {
          let Ye = L[h];
          if (y.T = Ye[0], Ye = Ye[1], y.G == 2) if (Ye[0] == "c") {
            y.K = Ye[1], y.ia = Ye[2];
            const nn = Ye[3];
            nn != null && (y.la = nn, y.j.info("VER=" + y.la));
            const rn = Ye[4];
            rn != null && (y.Aa = rn, y.j.info("SVER=" + y.Aa));
            const ys = Ye[5];
            ys != null && typeof ys == "number" && 0 < ys && (w = 1.5 * ys, y.L = w, y.j.info("backChannelRequestTimeoutMs_=" + w)), w = y;
            const Yn = c.g;
            if (Yn) {
              const Va = Yn.g ? Yn.g.getResponseHeader("X-Client-Wire-Protocol") : null;
              if (Va) {
                var F = w.h;
                F.g || Va.indexOf("spdy") == -1 && Va.indexOf("quic") == -1 && Va.indexOf("h2") == -1 || (F.j = F.l, F.g = /* @__PURE__ */ new Set(), F.h && (Dn(F, F.h), F.h = null));
              }
              if (w.D) {
                const Zl = Yn.g ? Yn.g.getResponseHeader("X-HTTP-Session-Id") : null;
                Zl && (w.ya = Zl, je(w.I, w.D, Zl));
              }
            }
            y.G = 3, y.l && y.l.ua(), y.ba && (y.R = Date.now() - c.F, y.j.info("Handshake RTT: " + y.R + "ms")), w = y;
            var Z = c;
            if (w.qa = Gp(w, w.J ? w.ia : null, w.W), Z.K) {
              Di(w.h, Z);
              var ut = Z, jt = w.L;
              jt && (ut.I = jt), ut.B && (Mi(ut), Nt(ut)), w.g = Z;
            } else $p(w);
            0 < y.i.length && La(y);
          } else Ye[0] != "stop" && Ye[0] != "close" || Li(y, 7);
          else y.G == 3 && (Ye[0] == "stop" || Ye[0] == "close" ? Ye[0] == "stop" ? Li(y, 7) : Xl(y) : Ye[0] != "noop" && y.l && y.l.ta(Ye), y.v = 0);
        }
      }
      Je(4);
    } catch {
    }
  }
  var be = class {
    constructor(c, h) {
      this.g = c, this.map = h;
    }
  };
  function Ve(c) {
    this.l = c || 10, a.PerformanceNavigationTiming ? (c = a.performance.getEntriesByType("navigation"), c = 0 < c.length && (c[0].nextHopProtocol == "hq" || c[0].nextHopProtocol == "h2")) : c = !!(a.chrome && a.chrome.loadTimes && a.chrome.loadTimes() && a.chrome.loadTimes().wasFetchedViaSpdy), this.j = c ? this.l : 1, this.g = null, 1 < this.j && (this.g = /* @__PURE__ */ new Set()), this.h = null, this.i = [];
  }
  function rt(c) {
    return c.h ? !0 : c.g ? c.g.size >= c.j : !1;
  }
  function It(c) {
    return c.h ? 1 : c.g ? c.g.size : 0;
  }
  function fn(c, h) {
    return c.h ? c.h == h : c.g ? c.g.has(h) : !1;
  }
  function Dn(c, h) {
    c.g ? c.g.add(h) : c.h = h;
  }
  function Di(c, h) {
    c.h && c.h == h ? c.h = null : c.g && c.g.has(h) && c.g.delete(h);
  }
  Ve.prototype.cancel = function() {
    if (this.i = tn(this), this.h) this.h.cancel(), this.h = null;
    else if (this.g && this.g.size !== 0) {
      for (const c of this.g.values()) c.cancel();
      this.g.clear();
    }
  };
  function tn(c) {
    if (c.h != null) return c.i.concat(c.h.D);
    if (c.g != null && c.g.size !== 0) {
      let h = c.i;
      for (const y of c.g.values()) h = h.concat(y.D);
      return h;
    }
    return b(c.i);
  }
  function Ln(c) {
    if (c.V && typeof c.V == "function") return c.V();
    if (typeof Map < "u" && c instanceof Map || typeof Set < "u" && c instanceof Set) return Array.from(c.values());
    if (typeof c == "string") return c.split("");
    if (l(c)) {
      for (var h = [], y = c.length, w = 0; w < y; w++) h.push(c[w]);
      return h;
    }
    h = [], y = 0;
    for (w in c) h[y++] = c[w];
    return h;
  }
  function Na(c) {
    if (c.na && typeof c.na == "function") return c.na();
    if (!c.V || typeof c.V != "function") {
      if (typeof Map < "u" && c instanceof Map) return Array.from(c.keys());
      if (!(typeof Set < "u" && c instanceof Set)) {
        if (l(c) || typeof c == "string") {
          var h = [];
          c = c.length;
          for (var y = 0; y < c; y++) h.push(y);
          return h;
        }
        h = [], y = 0;
        for (const w in c) h[y++] = w;
        return h;
      }
    }
  }
  function go(c, h) {
    if (c.forEach && typeof c.forEach == "function") c.forEach(h, void 0);
    else if (l(c) || typeof c == "string") Array.prototype.forEach.call(c, h, void 0);
    else for (var y = Na(c), w = Ln(c), L = w.length, F = 0; F < L; F++) h.call(void 0, w[F], y && y[F], c);
  }
  var yo = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
  function Gl(c, h) {
    if (c) {
      c = c.split("&");
      for (var y = 0; y < c.length; y++) {
        var w = c[y].indexOf("="), L = null;
        if (0 <= w) {
          var F = c[y].substring(0, w);
          L = c[y].substring(w + 1);
        } else F = c[y];
        h(F, L ? decodeURIComponent(L.replace(/\+/g, " ")) : "");
      }
    }
  }
  function Nr(c) {
    if (this.g = this.o = this.j = "", this.s = null, this.m = this.l = "", this.h = !1, c instanceof Nr) {
      this.h = c.h, hs(this, c.j), this.o = c.o, this.g = c.g, Or(this, c.s), this.l = c.l;
      var h = c.i, y = new Mr();
      y.i = h.i, h.g && (y.g = new Map(h.g), y.h = h.h), _o(this, y), this.m = c.m;
    } else c && (h = String(c).match(yo)) ? (this.h = !1, hs(this, h[1] || "", !0), this.o = Pr(h[2] || ""), this.g = Pr(h[3] || "", !0), Or(this, h[4]), this.l = Pr(h[5] || "", !0), _o(this, h[6] || "", !0), this.m = Pr(h[7] || "")) : (this.h = !1, this.i = new Mr(null, this.h));
  }
  Nr.prototype.toString = function() {
    var c = [], h = this.j;
    h && c.push(Ce(h, Mt, !0), ":");
    var y = this.g;
    return (y || h == "file") && (c.push("//"), (h = this.o) && c.push(Ce(h, Mt, !0), "@"), c.push(encodeURIComponent(String(y)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), y = this.s, y != null && c.push(":", String(y))), (y = this.l) && (this.g && y.charAt(0) != "/" && c.push("/"), c.push(Ce(y, y.charAt(0) == "/" ? ms : ot, !0))), (y = this.i.toString()) && c.push("?", y), (y = this.m) && c.push("#", Ce(y, bo)), c.join("");
  };
  function Hn(c) {
    return new Nr(c);
  }
  function hs(c, h, y) {
    c.j = y ? Pr(h, !0) : h, c.j && (c.j = c.j.replace(/:$/, ""));
  }
  function Or(c, h) {
    if (h) {
      if (h = Number(h), isNaN(h) || 0 > h) throw Error("Bad port number " + h);
      c.s = h;
    } else c.s = null;
  }
  function _o(c, h, y) {
    h instanceof Mr ? (c.i = h, Kn(c.i, c.h)) : (y || (h = Ce(h, xr)), c.i = new Mr(h, c.h));
  }
  function je(c, h, y) {
    c.i.set(h, y);
  }
  function ps(c) {
    return je(c, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), c;
  }
  function Pr(c, h) {
    return c ? h ? decodeURI(c.replace(/%25/g, "%2525")) : decodeURIComponent(c) : "";
  }
  function Ce(c, h, y) {
    return typeof c == "string" ? (c = encodeURI(c).replace(h, Oa), y && (c = c.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c) : null;
  }
  function Oa(c) {
    return c = c.charCodeAt(0), "%" + (c >> 4 & 15).toString(16) + (c & 15).toString(16);
  }
  var Mt = /[#\/\?@]/g, ot = /[#\?:]/g, ms = /[#\?]/g, xr = /[#\?@]/g, bo = /#/g;
  function Mr(c, h) {
    this.h = this.g = null, this.i = c || null, this.j = !!h;
  }
  function J(c) {
    c.g || (c.g = /* @__PURE__ */ new Map(), c.h = 0, c.i && Gl(c.i, function(h, y) {
      c.add(decodeURIComponent(h.replace(/\+/g, " ")), y);
    }));
  }
  t = Mr.prototype, t.add = function(c, h) {
    J(this), this.i = null, c = wt(this, c);
    var y = this.g.get(c);
    return y || this.g.set(c, y = []), y.push(h), this.h += 1, this;
  };
  function me(c, h) {
    J(c), h = wt(c, h), c.g.has(h) && (c.i = null, c.h -= c.g.get(h).length, c.g.delete(h));
  }
  function De(c, h) {
    return J(c), h = wt(c, h), c.g.has(h);
  }
  t.forEach = function(c, h) {
    J(this), this.g.forEach(function(y, w) {
      y.forEach(function(L) {
        c.call(h, L, w, this);
      }, this);
    }, this);
  }, t.na = function() {
    J(this);
    const c = Array.from(this.g.values()), h = Array.from(this.g.keys()), y = [];
    for (let w = 0; w < h.length; w++) {
      const L = c[w];
      for (let F = 0; F < L.length; F++) y.push(h[w]);
    }
    return y;
  }, t.V = function(c) {
    J(this);
    let h = [];
    if (typeof c == "string") De(this, c) && (h = h.concat(this.g.get(wt(this, c))));
    else {
      c = Array.from(this.g.values());
      for (let y = 0; y < c.length; y++) h = h.concat(c[y]);
    }
    return h;
  }, t.set = function(c, h) {
    return J(this), this.i = null, c = wt(this, c), De(this, c) && (this.h -= this.g.get(c).length), this.g.set(c, [h]), this.h += 1, this;
  }, t.get = function(c, h) {
    return c ? (c = this.V(c), 0 < c.length ? String(c[0]) : h) : h;
  };
  function Ke(c, h, y) {
    me(c, h), 0 < y.length && (c.i = null, c.g.set(wt(c, h), b(y)), c.h += y.length);
  }
  t.toString = function() {
    if (this.i) return this.i;
    if (!this.g) return "";
    const c = [], h = Array.from(this.g.keys());
    for (var y = 0; y < h.length; y++) {
      var w = h[y];
      const F = encodeURIComponent(String(w)), Z = this.V(w);
      for (w = 0; w < Z.length; w++) {
        var L = F;
        Z[w] !== "" && (L += "=" + encodeURIComponent(String(Z[w]))), c.push(L);
      }
    }
    return this.i = c.join("&");
  };
  function wt(c, h) {
    return h = String(h), c.j && (h = h.toLowerCase()), h;
  }
  function Kn(c, h) {
    h && !c.j && (J(c), c.i = null, c.g.forEach(function(y, w) {
      var L = w.toLowerCase();
      w != L && (me(this, w), Ke(this, L, y));
    }, c)), c.j = h;
  }
  function Hl(c, h) {
    const y = new ft();
    if (a.Image) {
      const w = new Image();
      w.onload = g(ri, y, "TestLoadImage: loaded", !0, h, w), w.onerror = g(ri, y, "TestLoadImage: error", !1, h, w), w.onabort = g(ri, y, "TestLoadImage: abort", !1, h, w), w.ontimeout = g(ri, y, "TestLoadImage: timeout", !1, h, w), a.setTimeout(function() {
        w.ontimeout && w.ontimeout();
      }, 1e4), w.src = c;
    } else h(!1);
  }
  function Kl(c, h) {
    const y = new ft(), w = new AbortController(), L = setTimeout(() => {
      w.abort(), ri(y, "TestPingServer: timeout", !1, h);
    }, 1e4);
    fetch(c, { signal: w.signal }).then((F) => {
      clearTimeout(L), F.ok ? ri(y, "TestPingServer: ok", !0, h) : ri(y, "TestPingServer: server error", !1, h);
    }).catch(() => {
      clearTimeout(L), ri(y, "TestPingServer: error", !1, h);
    });
  }
  function ri(c, h, y, w, L) {
    try {
      L && (L.onload = null, L.onerror = null, L.onabort = null, L.ontimeout = null), w(y);
    } catch {
    }
  }
  function eI() {
    this.g = new xi();
  }
  function tI(c, h, y) {
    const w = y || "";
    try {
      go(c, function(L, F) {
        let Z = L;
        u(L) && (Z = Rr(L)), h.push(w + F + "=" + encodeURIComponent(Z));
      });
    } catch (L) {
      throw h.push(w + "type=" + encodeURIComponent("_badmap")), L;
    }
  }
  function Pa(c) {
    this.l = c.Ub || null, this.j = c.eb || !1;
  }
  _(Pa, wn), Pa.prototype.g = function() {
    return new xa(this.l, this.j);
  }, Pa.prototype.i = /* @__PURE__ */ function(c) {
    return function() {
      return c;
    };
  }({});
  function xa(c, h) {
    We.call(this), this.D = c, this.o = h, this.m = void 0, this.status = this.readyState = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.u = new Headers(), this.h = null, this.B = "GET", this.A = "", this.g = !1, this.v = this.j = this.l = null;
  }
  _(xa, We), t = xa.prototype, t.open = function(c, h) {
    if (this.readyState != 0) throw this.abort(), Error("Error reopening a connection");
    this.B = c, this.A = h, this.readyState = 1, Eo(this);
  }, t.send = function(c) {
    if (this.readyState != 1) throw this.abort(), Error("need to call open() first. ");
    this.g = !0;
    const h = { headers: this.u, method: this.B, credentials: this.m, cache: void 0 };
    c && (h.body = c), (this.D || a).fetch(new Request(this.A, h)).then(this.Sa.bind(this), this.ga.bind(this));
  }, t.abort = function() {
    this.response = this.responseText = "", this.u = new Headers(), this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => {
    }), 1 <= this.readyState && this.g && this.readyState != 4 && (this.g = !1, vo(this)), this.readyState = 0;
  }, t.Sa = function(c) {
    if (this.g && (this.l = c, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = c.headers, this.readyState = 2, Eo(this)), this.g && (this.readyState = 3, Eo(this), this.g))) if (this.responseType === "arraybuffer") c.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this));
    else if (typeof a.ReadableStream < "u" && "body" in c) {
      if (this.j = c.body.getReader(), this.o) {
        if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else this.response = this.responseText = "", this.v = new TextDecoder();
      Np(this);
    } else c.text().then(this.Ra.bind(this), this.ga.bind(this));
  };
  function Np(c) {
    c.j.read().then(c.Pa.bind(c)).catch(c.ga.bind(c));
  }
  t.Pa = function(c) {
    if (this.g) {
      if (this.o && c.value) this.response.push(c.value);
      else if (!this.o) {
        var h = c.value ? c.value : new Uint8Array(0);
        (h = this.v.decode(h, { stream: !c.done })) && (this.response = this.responseText += h);
      }
      c.done ? vo(this) : Eo(this), this.readyState == 3 && Np(this);
    }
  }, t.Ra = function(c) {
    this.g && (this.response = this.responseText = c, vo(this));
  }, t.Qa = function(c) {
    this.g && (this.response = c, vo(this));
  }, t.ga = function() {
    this.g && vo(this);
  };
  function vo(c) {
    c.readyState = 4, c.l = null, c.j = null, c.v = null, Eo(c);
  }
  t.setRequestHeader = function(c, h) {
    this.u.append(c, h);
  }, t.getResponseHeader = function(c) {
    return this.h && this.h.get(c.toLowerCase()) || "";
  }, t.getAllResponseHeaders = function() {
    if (!this.h) return "";
    const c = [], h = this.h.entries();
    for (var y = h.next(); !y.done; ) y = y.value, c.push(y[0] + ": " + y[1]), y = h.next();
    return c.join(`\r
`);
  };
  function Eo(c) {
    c.onreadystatechange && c.onreadystatechange.call(c);
  }
  Object.defineProperty(xa.prototype, "withCredentials", { get: function() {
    return this.m === "include";
  }, set: function(c) {
    this.m = c ? "include" : "same-origin";
  } });
  function Op(c) {
    let h = "";
    return U(c, function(y, w) {
      h += w, h += ":", h += y, h += `\r
`;
    }), h;
  }
  function Yl(c, h, y) {
    e: {
      for (w in y) {
        var w = !1;
        break e;
      }
      w = !0;
    }
    w || (y = Op(y), typeof c == "string" ? y != null && encodeURIComponent(String(y)) : je(c, h, y));
  }
  function St(c) {
    We.call(this), this.headers = /* @__PURE__ */ new Map(), this.o = c || null, this.h = !1, this.v = this.g = null, this.D = "", this.m = 0, this.l = "", this.j = this.B = this.u = this.A = !1, this.I = null, this.H = "", this.J = !1;
  }
  _(St, We);
  var nI = /^https?$/i, rI = ["POST", "PUT"];
  t = St.prototype, t.Ha = function(c) {
    this.J = c;
  }, t.ea = function(c, h, y, w) {
    if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + c);
    h = h ? h.toUpperCase() : "GET", this.D = c, this.l = "", this.m = 0, this.A = !1, this.h = !0, this.g = this.o ? this.o.g() : $e.g(), this.v = this.o ? lr(this.o) : lr($e), this.g.onreadystatechange = p(this.Ea, this);
    try {
      this.B = !0, this.g.open(h, String(c), !0), this.B = !1;
    } catch (F) {
      Pp(this, F);
      return;
    }
    if (c = y || "", y = new Map(this.headers), w) if (Object.getPrototypeOf(w) === Object.prototype) for (var L in w) y.set(L, w[L]);
    else if (typeof w.keys == "function" && typeof w.get == "function") for (const F of w.keys()) y.set(F, w.get(F));
    else throw Error("Unknown input type for opt_headers: " + String(w));
    w = Array.from(y.keys()).find((F) => F.toLowerCase() == "content-type"), L = a.FormData && c instanceof a.FormData, !(0 <= Array.prototype.indexOf.call(rI, h, void 0)) || w || L || y.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
    for (const [F, Z] of y) this.g.setRequestHeader(F, Z);
    this.H && (this.g.responseType = this.H), "withCredentials" in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J);
    try {
      Dp(this), this.u = !0, this.g.send(c), this.u = !1;
    } catch (F) {
      Pp(this, F);
    }
  };
  function Pp(c, h) {
    c.h = !1, c.g && (c.j = !0, c.g.abort(), c.j = !1), c.l = h, c.m = 5, xp(c), Ma(c);
  }
  function xp(c) {
    c.A || (c.A = !0, gt(c, "complete"), gt(c, "error"));
  }
  t.abort = function(c) {
    this.g && this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1, this.m = c || 7, gt(this, "complete"), gt(this, "abort"), Ma(this));
  }, t.N = function() {
    this.g && (this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1), Ma(this, !0)), St.aa.N.call(this);
  }, t.Ea = function() {
    this.s || (this.B || this.u || this.j ? Mp(this) : this.bb());
  }, t.bb = function() {
    Mp(this);
  };
  function Mp(c) {
    if (c.h && typeof o < "u" && (!c.v[1] || Dr(c) != 4 || c.Z() != 2)) {
      if (c.u && Dr(c) == 4) cr(c.Ea, 0, c);
      else if (gt(c, "readystatechange"), Dr(c) == 4) {
        c.h = !1;
        try {
          const Z = c.Z();
          e: switch (Z) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var h = !0;
              break e;
            default:
              h = !1;
          }
          var y;
          if (!(y = h)) {
            var w;
            if (w = Z === 0) {
              var L = String(c.D).match(yo)[1] || null;
              !L && a.self && a.self.location && (L = a.self.location.protocol.slice(0, -1)), w = !nI.test(L ? L.toLowerCase() : "");
            }
            y = w;
          }
          if (y) gt(c, "complete"), gt(c, "success");
          else {
            c.m = 6;
            try {
              var F = 2 < Dr(c) ? c.g.statusText : "";
            } catch {
              F = "";
            }
            c.l = F + " [" + c.Z() + "]", xp(c);
          }
        } finally {
          Ma(c);
        }
      }
    }
  }
  function Ma(c, h) {
    if (c.g) {
      Dp(c);
      const y = c.g, w = c.v[0] ? () => {
      } : null;
      c.g = null, c.v = null, h || gt(c, "ready");
      try {
        y.onreadystatechange = w;
      } catch {
      }
    }
  }
  function Dp(c) {
    c.I && (a.clearTimeout(c.I), c.I = null);
  }
  t.isActive = function() {
    return !!this.g;
  };
  function Dr(c) {
    return c.g ? c.g.readyState : 0;
  }
  t.Z = function() {
    try {
      return 2 < Dr(this) ? this.g.status : -1;
    } catch {
      return -1;
    }
  }, t.oa = function() {
    try {
      return this.g ? this.g.responseText : "";
    } catch {
      return "";
    }
  }, t.Oa = function(c) {
    if (this.g) {
      var h = this.g.responseText;
      return c && h.indexOf(c) == 0 && (h = h.substring(c.length)), Pi(h);
    }
  };
  function Lp(c) {
    try {
      if (!c.g) return null;
      if ("response" in c.g) return c.g.response;
      switch (c.H) {
        case "":
        case "text":
          return c.g.responseText;
        case "arraybuffer":
          if ("mozResponseArrayBuffer" in c.g) return c.g.mozResponseArrayBuffer;
      }
      return null;
    } catch {
      return null;
    }
  }
  function iI(c) {
    const h = {};
    c = (c.g && 2 <= Dr(c) && c.g.getAllResponseHeaders() || "").split(`\r
`);
    for (let w = 0; w < c.length; w++) {
      if (C(c[w])) continue;
      var y = R(c[w]);
      const L = y[0];
      if (y = y[1], typeof y != "string") continue;
      y = y.trim();
      const F = h[L] || [];
      h[L] = F, F.push(y);
    }
    I(h, function(w) {
      return w.join(", ");
    });
  }
  t.Ba = function() {
    return this.m;
  }, t.Ka = function() {
    return typeof this.l == "string" ? this.l : String(this.l);
  };
  function wo(c, h, y) {
    return y && y.internalChannelParams && y.internalChannelParams[c] || h;
  }
  function Up(c) {
    this.Aa = 0, this.i = [], this.j = new ft(), this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null, this.Ya = this.U = 0, this.Va = wo("failFast", !1, c), this.F = this.C = this.u = this.s = this.l = null, this.X = !0, this.za = this.T = -1, this.Y = this.v = this.B = 0, this.Ta = wo("baseRetryDelayMs", 5e3, c), this.cb = wo("retryDelaySeedMs", 1e4, c), this.Wa = wo("forwardChannelMaxRetries", 2, c), this.wa = wo("forwardChannelRequestTimeoutMs", 2e4, c), this.pa = c && c.xmlHttpFactory || void 0, this.Xa = c && c.Tb || void 0, this.Ca = c && c.useFetchStreams || !1, this.L = void 0, this.J = c && c.supportsCrossDomainXhr || !1, this.K = "", this.h = new Ve(c && c.concurrentRequestLimit), this.Da = new eI(), this.P = c && c.fastHandshake || !1, this.O = c && c.encodeInitMessageHeaders || !1, this.P && this.O && (this.O = !1), this.Ua = c && c.Rb || !1, c && c.xa && this.j.xa(), c && c.forceLongPolling && (this.X = !1), this.ba = !this.P && this.X && c && c.detectBufferingProxy || !1, this.ja = void 0, c && c.longPollingTimeout && 0 < c.longPollingTimeout && (this.ja = c.longPollingTimeout), this.ca = void 0, this.R = 0, this.M = !1, this.ka = this.A = null;
  }
  t = Up.prototype, t.la = 8, t.G = 1, t.connect = function(c, h, y, w) {
    ee(0), this.W = c, this.H = h || {}, y && w !== void 0 && (this.H.OSID = y, this.H.OAID = w), this.F = this.X, this.I = Gp(this, null, this.W), La(this);
  };
  function Xl(c) {
    if (Fp(c), c.G == 3) {
      var h = c.U++, y = Hn(c.I);
      if (je(y, "SID", c.K), je(y, "RID", h), je(y, "TYPE", "terminate"), To(c, y), h = new ke(c, c.j, h), h.L = 2, h.v = ps(Hn(y)), y = !1, a.navigator && a.navigator.sendBeacon) try {
        y = a.navigator.sendBeacon(h.v.toString(), "");
      } catch {
      }
      !y && a.Image && (new Image().src = h.v, y = !0), y || (h.g = Hp(h.j, null), h.g.ea(h.v)), h.F = Date.now(), Nt(h);
    }
    Wp(c);
  }
  function Da(c) {
    c.g && (Jl(c), c.g.cancel(), c.g = null);
  }
  function Fp(c) {
    Da(c), c.u && (a.clearTimeout(c.u), c.u = null), Ua(c), c.h.cancel(), c.s && (typeof c.s == "number" && a.clearTimeout(c.s), c.s = null);
  }
  function La(c) {
    if (!rt(c.h) && !c.s) {
      c.s = !0;
      var h = c.Ga;
      ge || B(), Te || (ge(), Te = !0), Ie.add(h, c), c.B = 0;
    }
  }
  function sI(c, h) {
    return It(c.h) >= c.h.j - (c.s ? 1 : 0) ? !1 : c.s ? (c.i = h.D.concat(c.i), !0) : c.G == 1 || c.G == 2 || c.B >= (c.Va ? 0 : c.Wa) ? !1 : (c.s = Ee(p(c.Ga, c, h), zp(c, c.B)), c.B++, !0);
  }
  t.Ga = function(c) {
    if (this.s) if (this.s = null, this.G == 1) {
      if (!c) {
        this.U = Math.floor(1e5 * Math.random()), c = this.U++;
        const L = new ke(this, this.j, c);
        let F = this.o;
        if (this.S && (F ? (F = E(F), A(F, this.S)) : F = this.S), this.m !== null || this.O || (L.H = F, F = null), this.P) e: {
          for (var h = 0, y = 0; y < this.i.length; y++) {
            t: {
              var w = this.i[y];
              if ("__data__" in w.map && (w = w.map.__data__, typeof w == "string")) {
                w = w.length;
                break t;
              }
              w = void 0;
            }
            if (w === void 0) break;
            if (h += w, 4096 < h) {
              h = y;
              break e;
            }
            if (h === 4096 || y === this.i.length - 1) {
              h = y + 1;
              break e;
            }
          }
          h = 1e3;
        }
        else h = 1e3;
        h = Bp(this, L, h), y = Hn(this.I), je(y, "RID", c), je(y, "CVER", 22), this.D && je(y, "X-HTTP-Session-Id", this.D), To(this, y), F && (this.O ? h = "headers=" + encodeURIComponent(String(Op(F))) + "&" + h : this.m && Yl(y, this.m, F)), Dn(this.h, L), this.Ua && je(y, "TYPE", "init"), this.P ? (je(y, "$req", h), je(y, "SID", "null"), L.T = !0, ht(L, y, null)) : ht(L, y, h), this.G = 2;
      }
    } else this.G == 3 && (c ? Vp(this, c) : this.i.length == 0 || rt(this.h) || Vp(this));
  };
  function Vp(c, h) {
    var y;
    h ? y = h.l : y = c.U++;
    const w = Hn(c.I);
    je(w, "SID", c.K), je(w, "RID", y), je(w, "AID", c.T), To(c, w), c.m && c.o && Yl(w, c.m, c.o), y = new ke(c, c.j, y, c.B + 1), c.m === null && (y.H = c.o), h && (c.i = h.D.concat(c.i)), h = Bp(c, y, 1e3), y.I = Math.round(0.5 * c.wa) + Math.round(0.5 * c.wa * Math.random()), Dn(c.h, y), ht(y, w, h);
  }
  function To(c, h) {
    c.H && U(c.H, function(y, w) {
      je(h, w, y);
    }), c.l && go({}, function(y, w) {
      je(h, w, y);
    });
  }
  function Bp(c, h, y) {
    y = Math.min(c.i.length, y);
    var w = c.l ? p(c.l.Na, c.l, c) : null;
    e: {
      var L = c.i;
      let F = -1;
      for (; ; ) {
        const Z = ["count=" + y];
        F == -1 ? 0 < y ? (F = L[0].g, Z.push("ofs=" + F)) : F = 0 : Z.push("ofs=" + F);
        let ut = !0;
        for (let jt = 0; jt < y; jt++) {
          let Ye = L[jt].g;
          const nn = L[jt].map;
          if (Ye -= F, 0 > Ye) F = Math.max(0, L[jt].g - 100), ut = !1;
          else try {
            tI(nn, Z, "req" + Ye + "_");
          } catch {
            w && w(nn);
          }
        }
        if (ut) {
          w = Z.join("&");
          break e;
        }
      }
    }
    return c = c.i.splice(0, y), h.D = c, w;
  }
  function $p(c) {
    if (!c.g && !c.u) {
      c.Y = 1;
      var h = c.Fa;
      ge || B(), Te || (ge(), Te = !0), Ie.add(h, c), c.v = 0;
    }
  }
  function Ql(c) {
    return c.g || c.u || 3 <= c.v ? !1 : (c.Y++, c.u = Ee(p(c.Fa, c), zp(c, c.v)), c.v++, !0);
  }
  t.Fa = function() {
    if (this.u = null, jp(this), this.ba && !(this.M || this.g == null || 0 >= this.R)) {
      var c = 2 * this.R;
      this.j.info("BP detection timer enabled: " + c), this.A = Ee(p(this.ab, this), c);
    }
  }, t.ab = function() {
    this.A && (this.A = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.F = !1, this.M = !0, ee(10), Da(this), jp(this));
  };
  function Jl(c) {
    c.A != null && (a.clearTimeout(c.A), c.A = null);
  }
  function jp(c) {
    c.g = new ke(c, c.j, "rpc", c.Y), c.m === null && (c.g.H = c.o), c.g.O = 0;
    var h = Hn(c.qa);
    je(h, "RID", "rpc"), je(h, "SID", c.K), je(h, "AID", c.T), je(h, "CI", c.F ? "0" : "1"), !c.F && c.ja && je(h, "TO", c.ja), je(h, "TYPE", "xmlhttp"), To(c, h), c.m && c.o && Yl(h, c.m, c.o), c.L && (c.g.I = c.L);
    var y = c.g;
    c = c.ia, y.L = 1, y.v = ps(Hn(h)), y.m = null, y.P = !0, bt(y, c);
  }
  t.Za = function() {
    this.C != null && (this.C = null, Da(this), Ql(this), ee(19));
  };
  function Ua(c) {
    c.C != null && (a.clearTimeout(c.C), c.C = null);
  }
  function qp(c, h) {
    var y = null;
    if (c.g == h) {
      Ua(c), Jl(c), c.g = null;
      var w = 2;
    } else if (fn(c.h, h)) y = h.D, Di(c.h, h), w = 1;
    else return;
    if (c.G != 0) {
      if (h.o) if (w == 1) {
        y = h.m ? h.m.length : 0, h = Date.now() - h.F;
        var L = c.B;
        w = Q(), gt(w, new oe(w, y)), La(c);
      } else $p(c);
      else if (L = h.s, L == 3 || L == 0 && 0 < h.X || !(w == 1 && sI(c, h) || w == 2 && Ql(c))) switch (y && 0 < y.length && (h = c.h, h.i = h.i.concat(y)), L) {
        case 1:
          Li(c, 5);
          break;
        case 4:
          Li(c, 10);
          break;
        case 3:
          Li(c, 6);
          break;
        default:
          Li(c, 2);
      }
    }
  }
  function zp(c, h) {
    let y = c.Ta + Math.floor(Math.random() * c.cb);
    return c.isActive() || (y *= 2), y * h;
  }
  function Li(c, h) {
    if (c.j.info("Error code " + h), h == 2) {
      var y = p(c.fb, c), w = c.Xa;
      const L = !w;
      w = new Nr(w || "//www.google.com/images/cleardot.gif"), a.location && a.location.protocol == "http" || hs(w, "https"), ps(w), L ? Hl(w.toString(), y) : Kl(w.toString(), y);
    } else ee(2);
    c.G = 0, c.l && c.l.sa(h), Wp(c), Fp(c);
  }
  t.fb = function(c) {
    c ? (this.j.info("Successfully pinged google.com"), ee(2)) : (this.j.info("Failed to ping google.com"), ee(1));
  };
  function Wp(c) {
    if (c.G = 0, c.ka = [], c.l) {
      const h = tn(c.h);
      (h.length != 0 || c.i.length != 0) && (m(c.ka, h), m(c.ka, c.i), c.h.i.length = 0, b(c.i), c.i.length = 0), c.l.ra();
    }
  }
  function Gp(c, h, y) {
    var w = y instanceof Nr ? Hn(y) : new Nr(y);
    if (w.g != "") h && (w.g = h + "." + w.g), Or(w, w.s);
    else {
      var L = a.location;
      w = L.protocol, h = h ? h + "." + L.hostname : L.hostname, L = +L.port;
      var F = new Nr(null);
      w && hs(F, w), h && (F.g = h), L && Or(F, L), y && (F.l = y), w = F;
    }
    return y = c.D, h = c.ya, y && h && je(w, y, h), je(w, "VER", c.la), To(c, w), w;
  }
  function Hp(c, h, y) {
    if (h && !c.J) throw Error("Can't create secondary domain capable XhrIo object.");
    return h = c.Ca && !c.pa ? new St(new Pa({ eb: y })) : new St(c.pa), h.Ha(c.J), h;
  }
  t.isActive = function() {
    return !!this.l && this.l.isActive(this);
  };
  function Kp() {
  }
  t = Kp.prototype, t.ua = function() {
  }, t.ta = function() {
  }, t.sa = function() {
  }, t.ra = function() {
  }, t.isActive = function() {
    return !0;
  }, t.Na = function() {
  };
  function Fa() {
  }
  Fa.prototype.g = function(c, h) {
    return new Tn(c, h);
  };
  function Tn(c, h) {
    We.call(this), this.g = new Up(h), this.l = c, this.h = h && h.messageUrlParams || null, c = h && h.messageHeaders || null, h && h.clientProtocolHeaderRequired && (c ? c["X-Client-Protocol"] = "webchannel" : c = { "X-Client-Protocol": "webchannel" }), this.g.o = c, c = h && h.initMessageHeaders || null, h && h.messageContentType && (c ? c["X-WebChannel-Content-Type"] = h.messageContentType : c = { "X-WebChannel-Content-Type": h.messageContentType }), h && h.va && (c ? c["X-WebChannel-Client-Profile"] = h.va : c = { "X-WebChannel-Client-Profile": h.va }), this.g.S = c, (c = h && h.Sb) && !C(c) && (this.g.m = c), this.v = h && h.supportsCrossDomainXhr || !1, this.u = h && h.sendRawJson || !1, (h = h && h.httpSessionIdParam) && !C(h) && (this.g.D = h, c = this.h, c !== null && h in c && (c = this.h, h in c && delete c[h])), this.j = new gs(this);
  }
  _(Tn, We), Tn.prototype.m = function() {
    this.g.l = this.j, this.v && (this.g.J = !0), this.g.connect(this.l, this.h || void 0);
  }, Tn.prototype.close = function() {
    Xl(this.g);
  }, Tn.prototype.o = function(c) {
    var h = this.g;
    if (typeof c == "string") {
      var y = {};
      y.__data__ = c, c = y;
    } else this.u && (y = {}, y.__data__ = Rr(c), c = y);
    h.i.push(new be(h.Ya++, c)), h.G == 3 && La(h);
  }, Tn.prototype.N = function() {
    this.g.l = null, delete this.j, Xl(this.g), delete this.g, Tn.aa.N.call(this);
  };
  function Yp(c) {
    en.call(this), c.__headers__ && (this.headers = c.__headers__, this.statusCode = c.__status__, delete c.__headers__, delete c.__status__);
    var h = c.__sm__;
    if (h) {
      e: {
        for (const y in h) {
          c = y;
          break e;
        }
        c = void 0;
      }
      (this.i = c) && (c = this.i, h = h !== null && c in h ? h[c] : void 0), this.data = h;
    } else this.data = c;
  }
  _(Yp, en);
  function Xp() {
    dn.call(this), this.status = 1;
  }
  _(Xp, dn);
  function gs(c) {
    this.g = c;
  }
  _(gs, Kp), gs.prototype.ua = function() {
    gt(this.g, "a");
  }, gs.prototype.ta = function(c) {
    gt(this.g, new Yp(c));
  }, gs.prototype.sa = function(c) {
    gt(this.g, new Xp());
  }, gs.prototype.ra = function() {
    gt(this.g, "b");
  }, Fa.prototype.createWebChannel = Fa.prototype.g, Tn.prototype.send = Tn.prototype.o, Tn.prototype.open = Tn.prototype.m, Tn.prototype.close = Tn.prototype.close, cE = function() {
    return new Fa();
  }, aE = function() {
    return Q();
  }, oE = N, $d = { mb: 0, pb: 1, qb: 2, Jb: 3, Ob: 4, Lb: 5, Mb: 6, Kb: 7, Ib: 8, Nb: 9, PROXY: 10, NOPROXY: 11, Gb: 12, Cb: 13, Db: 14, Bb: 15, Eb: 16, Fb: 17, ib: 18, hb: 19, jb: 20 }, te.NO_ERROR = 0, te.TIMEOUT = 8, te.HTTP_ERROR = 6, mc = te, Ae.COMPLETE = "complete", sE = Ae, Ue.EventType = Zt, Zt.OPEN = "a", Zt.CLOSE = "b", Zt.ERROR = "c", Zt.MESSAGE = "d", We.prototype.listen = We.prototype.K, xo = Ue, St.prototype.listenOnce = St.prototype.L, St.prototype.getLastError = St.prototype.Ka, St.prototype.getLastErrorCode = St.prototype.Ba, St.prototype.getStatus = St.prototype.Z, St.prototype.getResponseJson = St.prototype.Oa, St.prototype.getResponseText = St.prototype.oa, St.prototype.send = St.prototype.ea, St.prototype.setWithCredentials = St.prototype.Ha, iE = St;
}).apply(typeof Xa < "u" ? Xa : typeof self < "u" ? self : typeof window < "u" ? window : {});
const Rg = "@firebase/firestore";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class on {
  constructor(e) {
    this.uid = e;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(e) {
    return e.uid === this.uid;
  }
}
on.UNAUTHENTICATED = new on(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
on.GOOGLE_CREDENTIALS = new on("google-credentials-uid"), on.FIRST_PARTY = new on("first-party-uid"), on.MOCK_USER = new on("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let co = "10.14.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const es = new Qf("@firebase/firestore");
function Ao() {
  return es.logLevel;
}
function fe(t, ...e) {
  if (es.logLevel <= ze.DEBUG) {
    const n = e.map(uh);
    es.debug(`Firestore (${co}): ${t}`, ...n);
  }
}
function Yr(t, ...e) {
  if (es.logLevel <= ze.ERROR) {
    const n = e.map(uh);
    es.error(`Firestore (${co}): ${t}`, ...n);
  }
}
function Ks(t, ...e) {
  if (es.logLevel <= ze.WARN) {
    const n = e.map(uh);
    es.warn(`Firestore (${co}): ${t}`, ...n);
  }
}
function uh(t) {
  if (typeof t == "string") return t;
  try {
    /**
    * @license
    * Copyright 2020 Google LLC
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    return function(n) {
      return JSON.stringify(n);
    }(t);
  } catch {
    return t;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ne(t = "Unexpected state") {
  const e = `FIRESTORE (${co}) INTERNAL ASSERTION FAILED: ` + t;
  throw Yr(e), new Error(e);
}
function it(t, e) {
  t || Ne();
}
function xe(t, e) {
  return t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const j = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: "ok",
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: "cancelled",
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: "unknown",
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: "invalid-argument",
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: "deadline-exceeded",
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: "not-found",
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: "already-exists",
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller cannot be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: "permission-denied",
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: "unauthenticated",
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: "resource-exhausted",
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: "failed-precondition",
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: "aborted",
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: "out-of-range",
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: "unimplemented",
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: "internal",
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: "unavailable",
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: "data-loss"
};
class ne extends rr {
  /** @hideconstructor */
  constructor(e, n) {
    super(e, n), this.code = e, this.message = n, // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jr {
  constructor() {
    this.promise = new Promise((e, n) => {
      this.resolve = e, this.reject = n;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lE {
  constructor(e, n) {
    this.user = n, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${e}`);
  }
}
class pN {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, n) {
    e.enqueueRetryable(() => n(on.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class mN {
  constructor(e) {
    this.token = e, /**
    * Stores the listener registered with setChangeListener()
    * This isn't actually necessary since the UID never changes, but we use this
    * to verify the listen contract is adhered to in tests.
    */
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(e, n) {
    this.changeListener = n, // Fire with initial user.
    e.enqueueRetryable(() => n(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class gN {
  constructor(e) {
    this.t = e, /** Tracks the current User. */
    this.currentUser = on.UNAUTHENTICATED, /**
    * Counter used to detect if the token changed while a getToken request was
    * outstanding.
    */
    this.i = 0, this.forceRefresh = !1, this.auth = null;
  }
  start(e, n) {
    it(this.o === void 0);
    let r = this.i;
    const i = (l) => this.i !== r ? (r = this.i, n(l)) : Promise.resolve();
    let s = new jr();
    this.o = () => {
      this.i++, this.currentUser = this.u(), s.resolve(), s = new jr(), e.enqueueRetryable(() => i(this.currentUser));
    };
    const o = () => {
      const l = s;
      e.enqueueRetryable(async () => {
        await l.promise, await i(this.currentUser);
      });
    }, a = (l) => {
      fe("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = l, this.o && (this.auth.addAuthTokenListener(this.o), o());
    };
    this.t.onInit((l) => a(l)), // Our users can initialize Auth right after Firestore, so we give it
    // a chance to register itself with the component framework before we
    // determine whether to start up in unauthenticated mode.
    setTimeout(() => {
      if (!this.auth) {
        const l = this.t.getImmediate({
          optional: !0
        });
        l ? a(l) : (
          // If auth is still not available, proceed with `null` user
          (fe("FirebaseAuthCredentialsProvider", "Auth not yet detected"), s.resolve(), s = new jr())
        );
      }
    }, 0), o();
  }
  getToken() {
    const e = this.i, n = this.forceRefresh;
    return this.forceRefresh = !1, this.auth ? this.auth.getToken(n).then((r) => (
      // Cancel the request since the token changed while the request was
      // outstanding so the response is potentially for a previous user (which
      // user, we can't be sure).
      this.i !== e ? (fe("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : r ? (it(typeof r.accessToken == "string"), new lE(r.accessToken, this.currentUser)) : null
    )) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = !0;
  }
  shutdown() {
    this.auth && this.o && this.auth.removeAuthTokenListener(this.o), this.o = void 0;
  }
  // Auth.getUid() can return null even with a user logged in. It is because
  // getUid() is synchronous, but the auth code populating Uid is asynchronous.
  // This method should only be called in the AuthTokenListener callback
  // to guarantee to get the actual user.
  u() {
    const e = this.auth && this.auth.getUid();
    return it(e === null || typeof e == "string"), new on(e);
  }
}
class yN {
  constructor(e, n, r) {
    this.l = e, this.h = n, this.P = r, this.type = "FirstParty", this.user = on.FIRST_PARTY, this.I = /* @__PURE__ */ new Map();
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  T() {
    return this.P ? this.P() : null;
  }
  get headers() {
    this.I.set("X-Goog-AuthUser", this.l);
    const e = this.T();
    return e && this.I.set("Authorization", e), this.h && this.I.set("X-Goog-Iam-Authorization-Token", this.h), this.I;
  }
}
class _N {
  constructor(e, n, r) {
    this.l = e, this.h = n, this.P = r;
  }
  getToken() {
    return Promise.resolve(new yN(this.l, this.h, this.P));
  }
  start(e, n) {
    e.enqueueRetryable(() => n(on.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class bN {
  constructor(e) {
    this.value = e, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class vN {
  constructor(e) {
    this.A = e, this.forceRefresh = !1, this.appCheck = null, this.R = null;
  }
  start(e, n) {
    it(this.o === void 0);
    const r = (s) => {
      s.error != null && fe("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${s.error.message}`);
      const o = s.token !== this.R;
      return this.R = s.token, fe("FirebaseAppCheckTokenProvider", `Received ${o ? "new" : "existing"} token.`), o ? n(s.token) : Promise.resolve();
    };
    this.o = (s) => {
      e.enqueueRetryable(() => r(s));
    };
    const i = (s) => {
      fe("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = s, this.o && this.appCheck.addTokenListener(this.o);
    };
    this.A.onInit((s) => i(s)), // Our users can initialize AppCheck after Firestore, so we give it
    // a chance to register itself with the component framework.
    setTimeout(() => {
      if (!this.appCheck) {
        const s = this.A.getImmediate({
          optional: !0
        });
        s ? i(s) : (
          // If AppCheck is still not available, proceed without it.
          fe("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
        );
      }
    }, 0);
  }
  getToken() {
    const e = this.forceRefresh;
    return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then((n) => n ? (it(typeof n.token == "string"), this.R = n.token, new bN(n.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = !0;
  }
  shutdown() {
    this.appCheck && this.o && this.appCheck.removeTokenListener(this.o), this.o = void 0;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function EN(t) {
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof self < "u" && (self.crypto || self.msCrypto)
  ), n = new Uint8Array(t);
  if (e && typeof e.getRandomValues == "function") e.getRandomValues(n);
  else
    for (let r = 0; r < t; r++) n[r] = Math.floor(256 * Math.random());
  return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uE {
  static newId() {
    const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = Math.floor(256 / e.length) * e.length;
    let r = "";
    for (; r.length < 20; ) {
      const i = EN(40);
      for (let s = 0; s < i.length; ++s)
        r.length < 20 && i[s] < n && (r += e.charAt(i[s] % e.length));
    }
    return r;
  }
}
function Xe(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Ys(t, e, n) {
  return t.length === e.length && t.every((r, i) => n(r, e[i]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vt {
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(e, n) {
    if (this.seconds = e, this.nanoseconds = n, n < 0) throw new ne(j.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + n);
    if (n >= 1e9) throw new ne(j.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + n);
    if (e < -62135596800) throw new ne(j.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e);
    if (e >= 253402300800) throw new ne(j.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e);
  }
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return Vt.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(e) {
    return Vt.fromMillis(e.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(e) {
    const n = Math.floor(e / 1e3), r = Math.floor(1e6 * (e - 1e3 * n));
    return new Vt(n, r);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(e) {
    return this.seconds === e.seconds ? Xe(this.nanoseconds, e.nanoseconds) : Xe(this.seconds, e.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(e) {
    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const e = this.seconds - -62135596800;
    return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pe {
  constructor(e) {
    this.timestamp = e;
  }
  static fromTimestamp(e) {
    return new Pe(e);
  }
  static min() {
    return new Pe(new Vt(0, 0));
  }
  static max() {
    return new Pe(new Vt(253402300799, 999999999));
  }
  compareTo(e) {
    return this.timestamp._compareTo(e.timestamp);
  }
  isEqual(e) {
    return this.timestamp.isEqual(e.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ea {
  constructor(e, n, r) {
    n === void 0 ? n = 0 : n > e.length && Ne(), r === void 0 ? r = e.length - n : r > e.length - n && Ne(), this.segments = e, this.offset = n, this.len = r;
  }
  get length() {
    return this.len;
  }
  isEqual(e) {
    return ea.comparator(this, e) === 0;
  }
  child(e) {
    const n = this.segments.slice(this.offset, this.limit());
    return e instanceof ea ? e.forEach((r) => {
      n.push(r);
    }) : n.push(e), this.construct(n);
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(e) {
    return e = e === void 0 ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(e) {
    return this.segments[this.offset + e];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(e) {
    if (e.length < this.length) return !1;
    for (let n = 0; n < this.length; n++) if (this.get(n) !== e.get(n)) return !1;
    return !0;
  }
  isImmediateParentOf(e) {
    if (this.length + 1 !== e.length) return !1;
    for (let n = 0; n < this.length; n++) if (this.get(n) !== e.get(n)) return !1;
    return !0;
  }
  forEach(e) {
    for (let n = this.offset, r = this.limit(); n < r; n++) e(this.segments[n]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(e, n) {
    const r = Math.min(e.length, n.length);
    for (let i = 0; i < r; i++) {
      const s = e.get(i), o = n.get(i);
      if (s < o) return -1;
      if (s > o) return 1;
    }
    return e.length < n.length ? -1 : e.length > n.length ? 1 : 0;
  }
}
class mt extends ea {
  construct(e, n, r) {
    return new mt(e, n, r);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns a string representation of this path
   * where each path segment has been encoded with
   * `encodeURIComponent`.
   */
  toUriEncodedString() {
    return this.toArray().map(encodeURIComponent).join("/");
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...e) {
    const n = [];
    for (const r of e) {
      if (r.indexOf("//") >= 0) throw new ne(j.INVALID_ARGUMENT, `Invalid segment (${r}). Paths must not contain // in them.`);
      n.push(...r.split("/").filter((i) => i.length > 0));
    }
    return new mt(n);
  }
  static emptyPath() {
    return new mt([]);
  }
}
const wN = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class Ht extends ea {
  construct(e, n, r) {
    return new Ht(e, n, r);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(e) {
    return wN.test(e);
  }
  canonicalString() {
    return this.toArray().map((e) => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Ht.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new Ht(["__name__"]);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(e) {
    const n = [];
    let r = "", i = 0;
    const s = () => {
      if (r.length === 0) throw new ne(j.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      n.push(r), r = "";
    };
    let o = !1;
    for (; i < e.length; ) {
      const a = e[i];
      if (a === "\\") {
        if (i + 1 === e.length) throw new ne(j.INVALID_ARGUMENT, "Path has trailing escape character: " + e);
        const l = e[i + 1];
        if (l !== "\\" && l !== "." && l !== "`") throw new ne(j.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e);
        r += l, i += 2;
      } else a === "`" ? (o = !o, i++) : a !== "." || o ? (r += a, i++) : (s(), i++);
    }
    if (s(), o) throw new ne(j.INVALID_ARGUMENT, "Unterminated ` in path: " + e);
    return new Ht(n);
  }
  static emptyPath() {
    return new Ht([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ve {
  constructor(e) {
    this.path = e;
  }
  static fromPath(e) {
    return new ve(mt.fromString(e));
  }
  static fromName(e) {
    return new ve(mt.fromString(e).popFirst(5));
  }
  static empty() {
    return new ve(mt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(e) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(e) {
    return e !== null && mt.comparator(this.path, e.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(e, n) {
    return mt.comparator(e.path, n.path);
  }
  static isDocumentKey(e) {
    return e.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(e) {
    return new ve(new mt(e.slice()));
  }
}
function TN(t, e) {
  const n = t.toTimestamp().seconds, r = t.toTimestamp().nanoseconds + 1, i = Pe.fromTimestamp(r === 1e9 ? new Vt(n + 1, 0) : new Vt(n, r));
  return new Ei(i, ve.empty(), e);
}
function IN(t) {
  return new Ei(t.readTime, t.key, -1);
}
class Ei {
  constructor(e, n, r) {
    this.readTime = e, this.documentKey = n, this.largestBatchId = r;
  }
  /** Returns an offset that sorts before all regular offsets. */
  static min() {
    return new Ei(Pe.min(), ve.empty(), -1);
  }
  /** Returns an offset that sorts after all regular offsets. */
  static max() {
    return new Ei(Pe.max(), ve.empty(), -1);
  }
}
function SN(t, e) {
  let n = t.readTime.compareTo(e.readTime);
  return n !== 0 ? n : (n = ve.comparator(t.documentKey, e.documentKey), n !== 0 ? n : Xe(t.largestBatchId, e.largestBatchId));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const AN = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class RN {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(e) {
    this.onCommittedListeners.push(e);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((e) => e());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ba(t) {
  if (t.code !== j.FAILED_PRECONDITION || t.message !== AN) throw t;
  fe("LocalStore", "Unexpectedly lost primary lease");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class W {
  constructor(e) {
    this.nextCallback = null, this.catchCallback = null, // When the operation resolves, we'll set result or error and mark isDone.
    this.result = void 0, this.error = void 0, this.isDone = !1, // Set to true when .then() or .catch() are called and prevents additional
    // chaining.
    this.callbackAttached = !1, e((n) => {
      this.isDone = !0, this.result = n, this.nextCallback && // value should be defined unless T is Void, but we can't express
      // that in the type system.
      this.nextCallback(n);
    }, (n) => {
      this.isDone = !0, this.error = n, this.catchCallback && this.catchCallback(n);
    });
  }
  catch(e) {
    return this.next(void 0, e);
  }
  next(e, n) {
    return this.callbackAttached && Ne(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(n, this.error) : this.wrapSuccess(e, this.result) : new W((r, i) => {
      this.nextCallback = (s) => {
        this.wrapSuccess(e, s).next(r, i);
      }, this.catchCallback = (s) => {
        this.wrapFailure(n, s).next(r, i);
      };
    });
  }
  toPromise() {
    return new Promise((e, n) => {
      this.next(e, n);
    });
  }
  wrapUserFunction(e) {
    try {
      const n = e();
      return n instanceof W ? n : W.resolve(n);
    } catch (n) {
      return W.reject(n);
    }
  }
  wrapSuccess(e, n) {
    return e ? this.wrapUserFunction(() => e(n)) : W.resolve(n);
  }
  wrapFailure(e, n) {
    return e ? this.wrapUserFunction(() => e(n)) : W.reject(n);
  }
  static resolve(e) {
    return new W((n, r) => {
      n(e);
    });
  }
  static reject(e) {
    return new W((n, r) => {
      r(e);
    });
  }
  static waitFor(e) {
    return new W((n, r) => {
      let i = 0, s = 0, o = !1;
      e.forEach((a) => {
        ++i, a.next(() => {
          ++s, o && s === i && n();
        }, (l) => r(l));
      }), o = !0, s === i && n();
    });
  }
  /**
   * Given an array of predicate functions that asynchronously evaluate to a
   * boolean, implements a short-circuiting `or` between the results. Predicates
   * will be evaluated until one of them returns `true`, then stop. The final
   * result will be whether any of them returned `true`.
   */
  static or(e) {
    let n = W.resolve(!1);
    for (const r of e) n = n.next((i) => i ? W.resolve(i) : r());
    return n;
  }
  static forEach(e, n) {
    const r = [];
    return e.forEach((i, s) => {
      r.push(n.call(this, i, s));
    }), this.waitFor(r);
  }
  /**
   * Concurrently map all array elements through asynchronous function.
   */
  static mapArray(e, n) {
    return new W((r, i) => {
      const s = e.length, o = new Array(s);
      let a = 0;
      for (let l = 0; l < s; l++) {
        const u = l;
        n(e[u]).next((d) => {
          o[u] = d, ++a, a === s && r(o);
        }, (d) => i(d));
      }
    });
  }
  /**
   * An alternative to recursive PersistencePromise calls, that avoids
   * potential memory problems from unbounded chains of promises.
   *
   * The `action` will be called repeatedly while `condition` is true.
   */
  static doWhile(e, n) {
    return new W((r, i) => {
      const s = () => {
        e() === !0 ? n().next(() => {
          s();
        }, i) : r();
      };
      s();
    });
  }
}
function CN(t) {
  const e = t.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
  return Number(n);
}
function va(t) {
  return t.name === "IndexedDbTransactionError";
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dh {
  constructor(e, n) {
    this.previousValue = e, n && (n.sequenceNumberHandler = (r) => this.ie(r), this.se = (r) => n.writeSequenceNumber(r));
  }
  ie(e) {
    return this.previousValue = Math.max(e, this.previousValue), this.previousValue;
  }
  next() {
    const e = ++this.previousValue;
    return this.se && this.se(e), e;
  }
}
dh.oe = -1;
function yl(t) {
  return t == null;
}
function Fc(t) {
  return t === 0 && 1 / t == -1 / 0;
}
function kN(t) {
  return typeof t == "number" && Number.isInteger(t) && !Fc(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Cg(t) {
  let e = 0;
  for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e++;
  return e;
}
function lo(t, e) {
  for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);
}
function dE(t) {
  for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;
  return !0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Tt {
  constructor(e, n) {
    this.comparator = e, this.root = n || Wt.EMPTY;
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(e, n) {
    return new Tt(this.comparator, this.root.insert(e, n, this.comparator).copy(null, null, Wt.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(e) {
    return new Tt(this.comparator, this.root.remove(e, this.comparator).copy(null, null, Wt.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(e) {
    let n = this.root;
    for (; !n.isEmpty(); ) {
      const r = this.comparator(e, n.key);
      if (r === 0) return n.value;
      r < 0 ? n = n.left : r > 0 && (n = n.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(e) {
    let n = 0, r = this.root;
    for (; !r.isEmpty(); ) {
      const i = this.comparator(e, r.key);
      if (i === 0) return n + r.left.size;
      i < 0 ? r = r.left : (
        // Count all nodes left of the node plus the node itself
        (n += r.left.size + 1, r = r.right)
      );
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.root.inorderTraversal(e);
  }
  forEach(e) {
    this.inorderTraversal((n, r) => (e(n, r), !1));
  }
  toString() {
    const e = [];
    return this.inorderTraversal((n, r) => (e.push(`${n}:${r}`), !1)), `{${e.join(", ")}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.root.reverseTraversal(e);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new Qa(this.root, null, this.comparator, !1);
  }
  getIteratorFrom(e) {
    return new Qa(this.root, e, this.comparator, !1);
  }
  getReverseIterator() {
    return new Qa(this.root, null, this.comparator, !0);
  }
  getReverseIteratorFrom(e) {
    return new Qa(this.root, e, this.comparator, !0);
  }
}
class Qa {
  constructor(e, n, r, i) {
    this.isReverse = i, this.nodeStack = [];
    let s = 1;
    for (; !e.isEmpty(); ) if (s = n ? r(e.key, n) : 1, // flip the comparison if we're going in reverse
    n && i && (s *= -1), s < 0)
      e = this.isReverse ? e.left : e.right;
    else {
      if (s === 0) {
        this.nodeStack.push(e);
        break;
      }
      this.nodeStack.push(e), e = this.isReverse ? e.right : e.left;
    }
  }
  getNext() {
    let e = this.nodeStack.pop();
    const n = {
      key: e.key,
      value: e.value
    };
    if (this.isReverse) for (e = e.left; !e.isEmpty(); ) this.nodeStack.push(e), e = e.right;
    else for (e = e.right; !e.isEmpty(); ) this.nodeStack.push(e), e = e.left;
    return n;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0) return null;
    const e = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: e.key,
      value: e.value
    };
  }
}
class Wt {
  constructor(e, n, r, i, s) {
    this.key = e, this.value = n, this.color = r ?? Wt.RED, this.left = i ?? Wt.EMPTY, this.right = s ?? Wt.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(e, n, r, i, s) {
    return new Wt(e ?? this.key, n ?? this.value, r ?? this.color, i ?? this.left, s ?? this.right);
  }
  isEmpty() {
    return !1;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(e, n, r) {
    let i = this;
    const s = r(e, i.key);
    return i = s < 0 ? i.copy(null, null, null, i.left.insert(e, n, r), null) : s === 0 ? i.copy(null, n, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, n, r)), i.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty()) return Wt.EMPTY;
    let e = this;
    return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(e, n) {
    let r, i = this;
    if (n(e, i.key) < 0) i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()), i = i.copy(null, null, null, i.left.remove(e, n), null);
    else {
      if (i.left.isRed() && (i = i.rotateRight()), i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()), n(e, i.key) === 0) {
        if (i.right.isEmpty()) return Wt.EMPTY;
        r = i.right.min(), i = i.copy(r.key, r.value, null, null, i.right.removeMin());
      }
      i = i.copy(null, null, null, null, i.right.remove(e, n));
    }
    return i.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let e = this;
    return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e;
  }
  moveRedLeft() {
    let e = this.colorFlip();
    return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e;
  }
  moveRedRight() {
    let e = this.colorFlip();
    return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e;
  }
  rotateLeft() {
    const e = this.copy(null, null, Wt.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, e, null);
  }
  rotateRight() {
    const e = this.copy(null, null, Wt.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, e);
  }
  colorFlip() {
    const e = this.left.copy(null, null, !this.left.color, null, null), n = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, e, n);
  }
  // For testing.
  checkMaxDepth() {
    const e = this.check();
    return Math.pow(2, e) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if (this.isRed() && this.left.isRed() || this.right.isRed()) throw Ne();
    const e = this.left.check();
    if (e !== this.right.check()) throw Ne();
    return e + (this.isRed() ? 0 : 1);
  }
}
Wt.EMPTY = null, Wt.RED = !0, Wt.BLACK = !1;
Wt.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw Ne();
  }
  get value() {
    throw Ne();
  }
  get color() {
    throw Ne();
  }
  get left() {
    throw Ne();
  }
  get right() {
    throw Ne();
  }
  // Returns a copy of the current node.
  copy(e, n, r, i, s) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(e, n, r) {
    return new Wt(e, n);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(e, n) {
    return this;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(e) {
    return !1;
  }
  reverseTraversal(e) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return !1;
  }
  // For testing.
  checkMaxDepth() {
    return !0;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Kt {
  constructor(e) {
    this.comparator = e, this.data = new Tt(this.comparator);
  }
  has(e) {
    return this.data.get(e) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(e) {
    return this.data.indexOf(e);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(e) {
    this.data.inorderTraversal((n, r) => (e(n), !1));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(e, n) {
    const r = this.data.getIteratorFrom(e[0]);
    for (; r.hasNext(); ) {
      const i = r.getNext();
      if (this.comparator(i.key, e[1]) >= 0) return;
      n(i.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(e, n) {
    let r;
    for (r = n !== void 0 ? this.data.getIteratorFrom(n) : this.data.getIterator(); r.hasNext(); )
      if (!e(r.getNext().key)) return;
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(e) {
    const n = this.data.getIteratorFrom(e);
    return n.hasNext() ? n.getNext().key : null;
  }
  getIterator() {
    return new kg(this.data.getIterator());
  }
  getIteratorFrom(e) {
    return new kg(this.data.getIteratorFrom(e));
  }
  /** Inserts or updates an element */
  add(e) {
    return this.copy(this.data.remove(e).insert(e, !0));
  }
  /** Deletes an element */
  delete(e) {
    return this.has(e) ? this.copy(this.data.remove(e)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(e) {
    let n = this;
    return n.size < e.size && (n = e, e = this), e.forEach((r) => {
      n = n.add(r);
    }), n;
  }
  isEqual(e) {
    if (!(e instanceof Kt) || this.size !== e.size) return !1;
    const n = this.data.getIterator(), r = e.data.getIterator();
    for (; n.hasNext(); ) {
      const i = n.getNext().key, s = r.getNext().key;
      if (this.comparator(i, s) !== 0) return !1;
    }
    return !0;
  }
  toArray() {
    const e = [];
    return this.forEach((n) => {
      e.push(n);
    }), e;
  }
  toString() {
    const e = [];
    return this.forEach((n) => e.push(n)), "SortedSet(" + e.toString() + ")";
  }
  copy(e) {
    const n = new Kt(this.comparator);
    return n.data = e, n;
  }
}
class kg {
  constructor(e) {
    this.iter = e;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qn {
  constructor(e) {
    this.fields = e, // TODO(dimond): validation of FieldMask
    // Sort the field mask to support `FieldMask.isEqual()` and assert below.
    e.sort(Ht.comparator);
  }
  static empty() {
    return new Qn([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(e) {
    let n = new Kt(Ht.comparator);
    for (const r of this.fields) n = n.add(r);
    for (const r of e) n = n.add(r);
    return new Qn(n.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(e) {
    for (const n of this.fields) if (n.isPrefixOf(e)) return !0;
    return !1;
  }
  isEqual(e) {
    return Ys(this.fields, e.fields, (n, r) => n.isEqual(r));
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fE extends Error {
  constructor() {
    super(...arguments), this.name = "Base64DecodeError";
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qt {
  constructor(e) {
    this.binaryString = e;
  }
  static fromBase64String(e) {
    const n = function(i) {
      try {
        return atob(i);
      } catch (s) {
        throw typeof DOMException < "u" && s instanceof DOMException ? new fE("Invalid base64 string: " + s) : s;
      }
    }(e);
    return new Qt(n);
  }
  static fromUint8Array(e) {
    const n = (
      /**
      * Helper function to convert an Uint8array to a binary string.
      */
      function(i) {
        let s = "";
        for (let o = 0; o < i.length; ++o) s += String.fromCharCode(i[o]);
        return s;
      }(e)
    );
    return new Qt(n);
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(e++),
        done: !1
      } : {
        value: void 0,
        done: !0
      }
    };
  }
  toBase64() {
    return function(n) {
      return btoa(n);
    }(this.binaryString);
  }
  toUint8Array() {
    return function(n) {
      const r = new Uint8Array(n.length);
      for (let i = 0; i < n.length; i++) r[i] = n.charCodeAt(i);
      return r;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(e) {
    return Xe(this.binaryString, e.binaryString);
  }
  isEqual(e) {
    return this.binaryString === e.binaryString;
  }
}
Qt.EMPTY_BYTE_STRING = new Qt("");
const NN = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function wi(t) {
  if (it(!!t), typeof t == "string") {
    let e = 0;
    const n = NN.exec(t);
    if (it(!!n), n[1]) {
      let i = n[1];
      i = (i + "000000000").substr(0, 9), e = Number(i);
    }
    const r = new Date(t);
    return {
      seconds: Math.floor(r.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Pt(t.seconds),
    nanos: Pt(t.nanos)
  };
}
function Pt(t) {
  return typeof t == "number" ? t : typeof t == "string" ? Number(t) : 0;
}
function ts(t) {
  return typeof t == "string" ? Qt.fromBase64String(t) : Qt.fromUint8Array(t);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _l(t) {
  var e, n;
  return ((n = (((e = t == null ? void 0 : t.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function fh(t) {
  const e = t.mapValue.fields.__previous_value__;
  return _l(e) ? fh(e) : e;
}
function ta(t) {
  const e = wi(t.mapValue.fields.__local_write_time__.timestampValue);
  return new Vt(e.seconds, e.nanos);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ON {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param longPollingOptions Options that configure long-polling.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(e, n, r, i, s, o, a, l, u) {
    this.databaseId = e, this.appId = n, this.persistenceKey = r, this.host = i, this.ssl = s, this.forceLongPolling = o, this.autoDetectLongPolling = a, this.longPollingOptions = l, this.useFetchStreams = u;
  }
}
class na {
  constructor(e, n) {
    this.projectId = e, this.database = n || "(default)";
  }
  static empty() {
    return new na("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(e) {
    return e instanceof na && e.projectId === this.projectId && e.database === this.database;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ja = {
  mapValue: {}
};
function ns(t) {
  return "nullValue" in t ? 0 : "booleanValue" in t ? 1 : "integerValue" in t || "doubleValue" in t ? 2 : "timestampValue" in t ? 3 : "stringValue" in t ? 5 : "bytesValue" in t ? 6 : "referenceValue" in t ? 7 : "geoPointValue" in t ? 8 : "arrayValue" in t ? 9 : "mapValue" in t ? _l(t) ? 4 : xN(t) ? 9007199254740991 : PN(t) ? 10 : 11 : Ne();
}
function wr(t, e) {
  if (t === e) return !0;
  const n = ns(t);
  if (n !== ns(e)) return !1;
  switch (n) {
    case 0:
    case 9007199254740991:
      return !0;
    case 1:
      return t.booleanValue === e.booleanValue;
    case 4:
      return ta(t).isEqual(ta(e));
    case 3:
      return function(i, s) {
        if (typeof i.timestampValue == "string" && typeof s.timestampValue == "string" && i.timestampValue.length === s.timestampValue.length)
          return i.timestampValue === s.timestampValue;
        const o = wi(i.timestampValue), a = wi(s.timestampValue);
        return o.seconds === a.seconds && o.nanos === a.nanos;
      }(t, e);
    case 5:
      return t.stringValue === e.stringValue;
    case 6:
      return function(i, s) {
        return ts(i.bytesValue).isEqual(ts(s.bytesValue));
      }(t, e);
    case 7:
      return t.referenceValue === e.referenceValue;
    case 8:
      return function(i, s) {
        return Pt(i.geoPointValue.latitude) === Pt(s.geoPointValue.latitude) && Pt(i.geoPointValue.longitude) === Pt(s.geoPointValue.longitude);
      }(t, e);
    case 2:
      return function(i, s) {
        if ("integerValue" in i && "integerValue" in s) return Pt(i.integerValue) === Pt(s.integerValue);
        if ("doubleValue" in i && "doubleValue" in s) {
          const o = Pt(i.doubleValue), a = Pt(s.doubleValue);
          return o === a ? Fc(o) === Fc(a) : isNaN(o) && isNaN(a);
        }
        return !1;
      }(t, e);
    case 9:
      return Ys(t.arrayValue.values || [], e.arrayValue.values || [], wr);
    case 10:
    case 11:
      return function(i, s) {
        const o = i.mapValue.fields || {}, a = s.mapValue.fields || {};
        if (Cg(o) !== Cg(a)) return !1;
        for (const l in o) if (o.hasOwnProperty(l) && (a[l] === void 0 || !wr(o[l], a[l]))) return !1;
        return !0;
      }(t, e);
    default:
      return Ne();
  }
}
function ra(t, e) {
  return (t.values || []).find((n) => wr(n, e)) !== void 0;
}
function Xs(t, e) {
  if (t === e) return 0;
  const n = ns(t), r = ns(e);
  if (n !== r) return Xe(n, r);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return Xe(t.booleanValue, e.booleanValue);
    case 2:
      return function(s, o) {
        const a = Pt(s.integerValue || s.doubleValue), l = Pt(o.integerValue || o.doubleValue);
        return a < l ? -1 : a > l ? 1 : a === l ? 0 : (
          // one or both are NaN.
          isNaN(a) ? isNaN(l) ? 0 : -1 : 1
        );
      }(t, e);
    case 3:
      return Ng(t.timestampValue, e.timestampValue);
    case 4:
      return Ng(ta(t), ta(e));
    case 5:
      return Xe(t.stringValue, e.stringValue);
    case 6:
      return function(s, o) {
        const a = ts(s), l = ts(o);
        return a.compareTo(l);
      }(t.bytesValue, e.bytesValue);
    case 7:
      return function(s, o) {
        const a = s.split("/"), l = o.split("/");
        for (let u = 0; u < a.length && u < l.length; u++) {
          const d = Xe(a[u], l[u]);
          if (d !== 0) return d;
        }
        return Xe(a.length, l.length);
      }(t.referenceValue, e.referenceValue);
    case 8:
      return function(s, o) {
        const a = Xe(Pt(s.latitude), Pt(o.latitude));
        return a !== 0 ? a : Xe(Pt(s.longitude), Pt(o.longitude));
      }(t.geoPointValue, e.geoPointValue);
    case 9:
      return Og(t.arrayValue, e.arrayValue);
    case 10:
      return function(s, o) {
        var a, l, u, d;
        const f = s.fields || {}, p = o.fields || {}, g = (a = f.value) === null || a === void 0 ? void 0 : a.arrayValue, _ = (l = p.value) === null || l === void 0 ? void 0 : l.arrayValue, b = Xe(((u = g == null ? void 0 : g.values) === null || u === void 0 ? void 0 : u.length) || 0, ((d = _ == null ? void 0 : _.values) === null || d === void 0 ? void 0 : d.length) || 0);
        return b !== 0 ? b : Og(g, _);
      }(t.mapValue, e.mapValue);
    case 11:
      return function(s, o) {
        if (s === Ja.mapValue && o === Ja.mapValue) return 0;
        if (s === Ja.mapValue) return 1;
        if (o === Ja.mapValue) return -1;
        const a = s.fields || {}, l = Object.keys(a), u = o.fields || {}, d = Object.keys(u);
        l.sort(), d.sort();
        for (let f = 0; f < l.length && f < d.length; ++f) {
          const p = Xe(l[f], d[f]);
          if (p !== 0) return p;
          const g = Xs(a[l[f]], u[d[f]]);
          if (g !== 0) return g;
        }
        return Xe(l.length, d.length);
      }(t.mapValue, e.mapValue);
    default:
      throw Ne();
  }
}
function Ng(t, e) {
  if (typeof t == "string" && typeof e == "string" && t.length === e.length) return Xe(t, e);
  const n = wi(t), r = wi(e), i = Xe(n.seconds, r.seconds);
  return i !== 0 ? i : Xe(n.nanos, r.nanos);
}
function Og(t, e) {
  const n = t.values || [], r = e.values || [];
  for (let i = 0; i < n.length && i < r.length; ++i) {
    const s = Xs(n[i], r[i]);
    if (s) return s;
  }
  return Xe(n.length, r.length);
}
function Qs(t) {
  return jd(t);
}
function jd(t) {
  return "nullValue" in t ? "null" : "booleanValue" in t ? "" + t.booleanValue : "integerValue" in t ? "" + t.integerValue : "doubleValue" in t ? "" + t.doubleValue : "timestampValue" in t ? function(n) {
    const r = wi(n);
    return `time(${r.seconds},${r.nanos})`;
  }(t.timestampValue) : "stringValue" in t ? t.stringValue : "bytesValue" in t ? function(n) {
    return ts(n).toBase64();
  }(t.bytesValue) : "referenceValue" in t ? function(n) {
    return ve.fromName(n).toString();
  }(t.referenceValue) : "geoPointValue" in t ? function(n) {
    return `geo(${n.latitude},${n.longitude})`;
  }(t.geoPointValue) : "arrayValue" in t ? function(n) {
    let r = "[", i = !0;
    for (const s of n.values || []) i ? i = !1 : r += ",", r += jd(s);
    return r + "]";
  }(t.arrayValue) : "mapValue" in t ? function(n) {
    const r = Object.keys(n.fields || {}).sort();
    let i = "{", s = !0;
    for (const o of r) s ? s = !1 : i += ",", i += `${o}:${jd(n.fields[o])}`;
    return i + "}";
  }(t.mapValue) : Ne();
}
function Vc(t, e) {
  return {
    referenceValue: `projects/${t.projectId}/databases/${t.database}/documents/${e.path.canonicalString()}`
  };
}
function qd(t) {
  return !!t && "integerValue" in t;
}
function hh(t) {
  return !!t && "arrayValue" in t;
}
function Pg(t) {
  return !!t && "nullValue" in t;
}
function xg(t) {
  return !!t && "doubleValue" in t && isNaN(Number(t.doubleValue));
}
function gc(t) {
  return !!t && "mapValue" in t;
}
function PN(t) {
  var e, n;
  return ((n = (((e = t == null ? void 0 : t.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "__vector__";
}
function jo(t) {
  if (t.geoPointValue) return {
    geoPointValue: Object.assign({}, t.geoPointValue)
  };
  if (t.timestampValue && typeof t.timestampValue == "object") return {
    timestampValue: Object.assign({}, t.timestampValue)
  };
  if (t.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return lo(t.mapValue.fields, (n, r) => e.mapValue.fields[n] = jo(r)), e;
  }
  if (t.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t.arrayValue.values || []).length; ++n) e.arrayValue.values[n] = jo(t.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t);
}
function xN(t) {
  return (((t.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vn {
  constructor(e) {
    this.value = e;
  }
  static empty() {
    return new Vn({
      mapValue: {}
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(e) {
    if (e.isEmpty()) return this.value;
    {
      let n = this.value;
      for (let r = 0; r < e.length - 1; ++r) if (n = (n.mapValue.fields || {})[e.get(r)], !gc(n)) return null;
      return n = (n.mapValue.fields || {})[e.lastSegment()], n || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(e, n) {
    this.getFieldsMap(e.popLast())[e.lastSegment()] = jo(n);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(e) {
    let n = Ht.emptyPath(), r = {}, i = [];
    e.forEach((o, a) => {
      if (!n.isImmediateParentOf(a)) {
        const l = this.getFieldsMap(n);
        this.applyChanges(l, r, i), r = {}, i = [], n = a.popLast();
      }
      o ? r[a.lastSegment()] = jo(o) : i.push(a.lastSegment());
    });
    const s = this.getFieldsMap(n);
    this.applyChanges(s, r, i);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(e) {
    const n = this.field(e.popLast());
    gc(n) && n.mapValue.fields && delete n.mapValue.fields[e.lastSegment()];
  }
  isEqual(e) {
    return wr(this.value, e.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(e) {
    let n = this.value;
    n.mapValue.fields || (n.mapValue = {
      fields: {}
    });
    for (let r = 0; r < e.length; ++r) {
      let i = n.mapValue.fields[e.get(r)];
      gc(i) && i.mapValue.fields || (i = {
        mapValue: {
          fields: {}
        }
      }, n.mapValue.fields[e.get(r)] = i), n = i;
    }
    return n.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(e, n, r) {
    lo(n, (i, s) => e[i] = s);
    for (const i of r) delete e[i];
  }
  clone() {
    return new Vn(jo(this.value));
  }
}
function hE(t) {
  const e = [];
  return lo(t.fields, (n, r) => {
    const i = new Ht([n]);
    if (gc(r)) {
      const s = hE(r.mapValue).fields;
      if (s.length === 0)
        e.push(i);
      else
        for (const o of s) e.push(i.child(o));
    } else
      e.push(i);
  }), new Qn(e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class an {
  constructor(e, n, r, i, s, o, a) {
    this.key = e, this.documentType = n, this.version = r, this.readTime = i, this.createTime = s, this.data = o, this.documentState = a;
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(e) {
    return new an(
      e,
      0,
      /* version */
      Pe.min(),
      /* readTime */
      Pe.min(),
      /* createTime */
      Pe.min(),
      Vn.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(e, n, r, i) {
    return new an(
      e,
      1,
      /* version */
      n,
      /* readTime */
      Pe.min(),
      /* createTime */
      r,
      i,
      0
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(e, n) {
    return new an(
      e,
      2,
      /* version */
      n,
      /* readTime */
      Pe.min(),
      /* createTime */
      Pe.min(),
      Vn.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(e, n) {
    return new an(
      e,
      3,
      /* version */
      n,
      /* readTime */
      Pe.min(),
      /* createTime */
      Pe.min(),
      Vn.empty(),
      2
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(e, n) {
    return !this.createTime.isEqual(Pe.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = e), this.version = e, this.documentType = 1, this.data = n, this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(e) {
    return this.version = e, this.documentType = 2, this.data = Vn.empty(), this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(e) {
    return this.version = e, this.documentType = 3, this.data = Vn.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = Pe.min(), this;
  }
  setReadTime(e) {
    return this.readTime = e, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(e) {
    return e instanceof an && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data);
  }
  mutableCopy() {
    return new an(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Js {
  constructor(e, n) {
    this.position = e, this.inclusive = n;
  }
}
function Mg(t, e, n) {
  let r = 0;
  for (let i = 0; i < t.position.length; i++) {
    const s = e[i], o = t.position[i];
    if (s.field.isKeyField() ? r = ve.comparator(ve.fromName(o.referenceValue), n.key) : r = Xs(o, n.data.field(s.field)), s.dir === "desc" && (r *= -1), r !== 0) break;
  }
  return r;
}
function Dg(t, e) {
  if (t === null) return e === null;
  if (e === null || t.inclusive !== e.inclusive || t.position.length !== e.position.length) return !1;
  for (let n = 0; n < t.position.length; n++)
    if (!wr(t.position[n], e.position[n])) return !1;
  return !0;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ia {
  constructor(e, n = "asc") {
    this.field = e, this.dir = n;
  }
}
function MN(t, e) {
  return t.dir === e.dir && t.field.isEqual(e.field);
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pE {
}
class Lt extends pE {
  constructor(e, n, r) {
    super(), this.field = e, this.op = n, this.value = r;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, n, r) {
    return e.isKeyField() ? n === "in" || n === "not-in" ? this.createKeyFieldInFilter(e, n, r) : new LN(e, n, r) : n === "array-contains" ? new VN(e, r) : n === "in" ? new BN(e, r) : n === "not-in" ? new $N(e, r) : n === "array-contains-any" ? new jN(e, r) : new Lt(e, n, r);
  }
  static createKeyFieldInFilter(e, n, r) {
    return n === "in" ? new UN(e, r) : new FN(e, r);
  }
  matches(e) {
    const n = e.data.field(this.field);
    return this.op === "!=" ? n !== null && this.matchesComparison(Xs(n, this.value)) : n !== null && ns(this.value) === ns(n) && this.matchesComparison(Xs(n, this.value));
  }
  matchesComparison(e) {
    switch (this.op) {
      case "<":
        return e < 0;
      case "<=":
        return e <= 0;
      case "==":
        return e === 0;
      case "!=":
        return e !== 0;
      case ">":
        return e > 0;
      case ">=":
        return e >= 0;
      default:
        return Ne();
    }
  }
  isInequality() {
    return [
      "<",
      "<=",
      ">",
      ">=",
      "!=",
      "not-in"
      /* Operator.NOT_IN */
    ].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
}
class nr extends pE {
  constructor(e, n) {
    super(), this.filters = e, this.op = n, this.ae = null;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, n) {
    return new nr(e, n);
  }
  matches(e) {
    return mE(this) ? this.filters.find((n) => !n.matches(e)) === void 0 : this.filters.find((n) => n.matches(e)) !== void 0;
  }
  getFlattenedFilters() {
    return this.ae !== null || (this.ae = this.filters.reduce((e, n) => e.concat(n.getFlattenedFilters()), [])), this.ae;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
}
function mE(t) {
  return t.op === "and";
}
function gE(t) {
  return DN(t) && mE(t);
}
function DN(t) {
  for (const e of t.filters) if (e instanceof nr) return !1;
  return !0;
}
function zd(t) {
  if (t instanceof Lt)
    return t.field.canonicalString() + t.op.toString() + Qs(t.value);
  if (gE(t))
    return t.filters.map((e) => zd(e)).join(",");
  {
    const e = t.filters.map((n) => zd(n)).join(",");
    return `${t.op}(${e})`;
  }
}
function yE(t, e) {
  return t instanceof Lt ? function(r, i) {
    return i instanceof Lt && r.op === i.op && r.field.isEqual(i.field) && wr(r.value, i.value);
  }(t, e) : t instanceof nr ? function(r, i) {
    return i instanceof nr && r.op === i.op && r.filters.length === i.filters.length ? r.filters.reduce((s, o, a) => s && yE(o, i.filters[a]), !0) : !1;
  }(t, e) : void Ne();
}
function _E(t) {
  return t instanceof Lt ? function(n) {
    return `${n.field.canonicalString()} ${n.op} ${Qs(n.value)}`;
  }(t) : t instanceof nr ? function(n) {
    return n.op.toString() + " {" + n.getFilters().map(_E).join(" ,") + "}";
  }(t) : "Filter";
}
class LN extends Lt {
  constructor(e, n, r) {
    super(e, n, r), this.key = ve.fromName(r.referenceValue);
  }
  matches(e) {
    const n = ve.comparator(e.key, this.key);
    return this.matchesComparison(n);
  }
}
class UN extends Lt {
  constructor(e, n) {
    super(e, "in", n), this.keys = bE("in", n);
  }
  matches(e) {
    return this.keys.some((n) => n.isEqual(e.key));
  }
}
class FN extends Lt {
  constructor(e, n) {
    super(e, "not-in", n), this.keys = bE("not-in", n);
  }
  matches(e) {
    return !this.keys.some((n) => n.isEqual(e.key));
  }
}
function bE(t, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((r) => ve.fromName(r.referenceValue));
}
class VN extends Lt {
  constructor(e, n) {
    super(e, "array-contains", n);
  }
  matches(e) {
    const n = e.data.field(this.field);
    return hh(n) && ra(n.arrayValue, this.value);
  }
}
class BN extends Lt {
  constructor(e, n) {
    super(e, "in", n);
  }
  matches(e) {
    const n = e.data.field(this.field);
    return n !== null && ra(this.value.arrayValue, n);
  }
}
class $N extends Lt {
  constructor(e, n) {
    super(e, "not-in", n);
  }
  matches(e) {
    if (ra(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    })) return !1;
    const n = e.data.field(this.field);
    return n !== null && !ra(this.value.arrayValue, n);
  }
}
class jN extends Lt {
  constructor(e, n) {
    super(e, "array-contains-any", n);
  }
  matches(e) {
    const n = e.data.field(this.field);
    return !(!hh(n) || !n.arrayValue.values) && n.arrayValue.values.some((r) => ra(this.value.arrayValue, r));
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qN {
  constructor(e, n = null, r = [], i = [], s = null, o = null, a = null) {
    this.path = e, this.collectionGroup = n, this.orderBy = r, this.filters = i, this.limit = s, this.startAt = o, this.endAt = a, this.ue = null;
  }
}
function Lg(t, e = null, n = [], r = [], i = null, s = null, o = null) {
  return new qN(t, e, n, r, i, s, o);
}
function ph(t) {
  const e = xe(t);
  if (e.ue === null) {
    let n = e.path.canonicalString();
    e.collectionGroup !== null && (n += "|cg:" + e.collectionGroup), n += "|f:", n += e.filters.map((r) => zd(r)).join(","), n += "|ob:", n += e.orderBy.map((r) => function(s) {
      return s.field.canonicalString() + s.dir;
    }(r)).join(","), yl(e.limit) || (n += "|l:", n += e.limit), e.startAt && (n += "|lb:", n += e.startAt.inclusive ? "b:" : "a:", n += e.startAt.position.map((r) => Qs(r)).join(",")), e.endAt && (n += "|ub:", n += e.endAt.inclusive ? "a:" : "b:", n += e.endAt.position.map((r) => Qs(r)).join(",")), e.ue = n;
  }
  return e.ue;
}
function mh(t, e) {
  if (t.limit !== e.limit || t.orderBy.length !== e.orderBy.length) return !1;
  for (let n = 0; n < t.orderBy.length; n++) if (!MN(t.orderBy[n], e.orderBy[n])) return !1;
  if (t.filters.length !== e.filters.length) return !1;
  for (let n = 0; n < t.filters.length; n++) if (!yE(t.filters[n], e.filters[n])) return !1;
  return t.collectionGroup === e.collectionGroup && !!t.path.isEqual(e.path) && !!Dg(t.startAt, e.startAt) && Dg(t.endAt, e.endAt);
}
function Wd(t) {
  return ve.isDocumentKey(t.path) && t.collectionGroup === null && t.filters.length === 0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class us {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(e, n = null, r = [], i = [], s = null, o = "F", a = null, l = null) {
    this.path = e, this.collectionGroup = n, this.explicitOrderBy = r, this.filters = i, this.limit = s, this.limitType = o, this.startAt = a, this.endAt = l, this.ce = null, // The corresponding `Target` of this `Query` instance, for use with
    // non-aggregate queries.
    this.le = null, // The corresponding `Target` of this `Query` instance, for use with
    // aggregate queries. Unlike targets for non-aggregate queries,
    // aggregate query targets do not contain normalized order-bys, they only
    // contain explicit order-bys.
    this.he = null, this.startAt, this.endAt;
  }
}
function zN(t, e, n, r, i, s, o, a) {
  return new us(t, e, n, r, i, s, o, a);
}
function bl(t) {
  return new us(t);
}
function Ug(t) {
  return t.filters.length === 0 && t.limit === null && t.startAt == null && t.endAt == null && (t.explicitOrderBy.length === 0 || t.explicitOrderBy.length === 1 && t.explicitOrderBy[0].field.isKeyField());
}
function gh(t) {
  return t.collectionGroup !== null;
}
function Ls(t) {
  const e = xe(t);
  if (e.ce === null) {
    e.ce = [];
    const n = /* @__PURE__ */ new Set();
    for (const s of e.explicitOrderBy) e.ce.push(s), n.add(s.field.canonicalString());
    const r = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
    (function(o) {
      let a = new Kt(Ht.comparator);
      return o.filters.forEach((l) => {
        l.getFlattenedFilters().forEach((u) => {
          u.isInequality() && (a = a.add(u.field));
        });
      }), a;
    })(e).forEach((s) => {
      n.has(s.canonicalString()) || s.isKeyField() || e.ce.push(new ia(s, r));
    }), // Add the document key field to the last if it is not explicitly ordered.
    n.has(Ht.keyField().canonicalString()) || e.ce.push(new ia(Ht.keyField(), r));
  }
  return e.ce;
}
function yr(t) {
  const e = xe(t);
  return e.le || (e.le = WN(e, Ls(t))), e.le;
}
function WN(t, e) {
  if (t.limitType === "F") return Lg(t.path, t.collectionGroup, e, t.filters, t.limit, t.startAt, t.endAt);
  {
    e = e.map((i) => {
      const s = i.dir === "desc" ? "asc" : "desc";
      return new ia(i.field, s);
    });
    const n = t.endAt ? new Js(t.endAt.position, t.endAt.inclusive) : null, r = t.startAt ? new Js(t.startAt.position, t.startAt.inclusive) : null;
    return Lg(t.path, t.collectionGroup, e, t.filters, t.limit, n, r);
  }
}
function Gd(t, e) {
  const n = t.filters.concat([e]);
  return new us(t.path, t.collectionGroup, t.explicitOrderBy.slice(), n, t.limit, t.limitType, t.startAt, t.endAt);
}
function Bc(t, e, n) {
  return new us(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), e, n, t.startAt, t.endAt);
}
function vl(t, e) {
  return mh(yr(t), yr(e)) && t.limitType === e.limitType;
}
function vE(t) {
  return `${ph(yr(t))}|lt:${t.limitType}`;
}
function ws(t) {
  return `Query(target=${function(n) {
    let r = n.path.canonicalString();
    return n.collectionGroup !== null && (r += " collectionGroup=" + n.collectionGroup), n.filters.length > 0 && (r += `, filters: [${n.filters.map((i) => _E(i)).join(", ")}]`), yl(n.limit) || (r += ", limit: " + n.limit), n.orderBy.length > 0 && (r += `, orderBy: [${n.orderBy.map((i) => function(o) {
      return `${o.field.canonicalString()} (${o.dir})`;
    }(i)).join(", ")}]`), n.startAt && (r += ", startAt: ", r += n.startAt.inclusive ? "b:" : "a:", r += n.startAt.position.map((i) => Qs(i)).join(",")), n.endAt && (r += ", endAt: ", r += n.endAt.inclusive ? "a:" : "b:", r += n.endAt.position.map((i) => Qs(i)).join(",")), `Target(${r})`;
  }(yr(t))}; limitType=${t.limitType})`;
}
function El(t, e) {
  return e.isFoundDocument() && function(r, i) {
    const s = i.key.path;
    return r.collectionGroup !== null ? i.key.hasCollectionId(r.collectionGroup) && r.path.isPrefixOf(s) : ve.isDocumentKey(r.path) ? r.path.isEqual(s) : r.path.isImmediateParentOf(s);
  }(t, e) && function(r, i) {
    for (const s of Ls(r))
      if (!s.field.isKeyField() && i.data.field(s.field) === null) return !1;
    return !0;
  }(t, e) && function(r, i) {
    for (const s of r.filters) if (!s.matches(i)) return !1;
    return !0;
  }(t, e) && function(r, i) {
    return !(r.startAt && !/**
    * Returns true if a document sorts before a bound using the provided sort
    * order.
    */
    function(o, a, l) {
      const u = Mg(o, a, l);
      return o.inclusive ? u <= 0 : u < 0;
    }(r.startAt, Ls(r), i) || r.endAt && !function(o, a, l) {
      const u = Mg(o, a, l);
      return o.inclusive ? u >= 0 : u > 0;
    }(r.endAt, Ls(r), i));
  }(t, e);
}
function GN(t) {
  return t.collectionGroup || (t.path.length % 2 == 1 ? t.path.lastSegment() : t.path.get(t.path.length - 2));
}
function EE(t) {
  return (e, n) => {
    let r = !1;
    for (const i of Ls(t)) {
      const s = HN(i, e, n);
      if (s !== 0) return s;
      r = r || i.field.isKeyField();
    }
    return 0;
  };
}
function HN(t, e, n) {
  const r = t.field.isKeyField() ? ve.comparator(e.key, n.key) : function(s, o, a) {
    const l = o.data.field(s), u = a.data.field(s);
    return l !== null && u !== null ? Xs(l, u) : Ne();
  }(t.field, e, n);
  switch (t.dir) {
    case "asc":
      return r;
    case "desc":
      return -1 * r;
    default:
      return Ne();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uo {
  constructor(e, n) {
    this.mapKeyFn = e, this.equalsFn = n, /**
    * The inner map for a key/value pair. Due to the possibility of collisions we
    * keep a list of entries that we do a linear search through to find an actual
    * match. Note that collisions should be rare, so we still expect near
    * constant time lookups in practice.
    */
    this.inner = {}, /** The number of entries stored in the map */
    this.innerSize = 0;
  }
  /** Get a value for this key, or undefined if it does not exist. */
  get(e) {
    const n = this.mapKeyFn(e), r = this.inner[n];
    if (r !== void 0) {
      for (const [i, s] of r) if (this.equalsFn(i, e)) return s;
    }
  }
  has(e) {
    return this.get(e) !== void 0;
  }
  /** Put this key and value in the map. */
  set(e, n) {
    const r = this.mapKeyFn(e), i = this.inner[r];
    if (i === void 0) return this.inner[r] = [[e, n]], void this.innerSize++;
    for (let s = 0; s < i.length; s++) if (this.equalsFn(i[s][0], e))
      return void (i[s] = [e, n]);
    i.push([e, n]), this.innerSize++;
  }
  /**
   * Remove this key from the map. Returns a boolean if anything was deleted.
   */
  delete(e) {
    const n = this.mapKeyFn(e), r = this.inner[n];
    if (r === void 0) return !1;
    for (let i = 0; i < r.length; i++) if (this.equalsFn(r[i][0], e)) return r.length === 1 ? delete this.inner[n] : r.splice(i, 1), this.innerSize--, !0;
    return !1;
  }
  forEach(e) {
    lo(this.inner, (n, r) => {
      for (const [i, s] of r) e(i, s);
    });
  }
  isEmpty() {
    return dE(this.inner);
  }
  size() {
    return this.innerSize;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const KN = new Tt(ve.comparator);
function Xr() {
  return KN;
}
const wE = new Tt(ve.comparator);
function Mo(...t) {
  let e = wE;
  for (const n of t) e = e.insert(n.key, n);
  return e;
}
function TE(t) {
  let e = wE;
  return t.forEach((n, r) => e = e.insert(n, r.overlayedDocument)), e;
}
function zi() {
  return qo();
}
function IE() {
  return qo();
}
function qo() {
  return new uo((t) => t.toString(), (t, e) => t.isEqual(e));
}
const YN = new Tt(ve.comparator), XN = new Kt(ve.comparator);
function qe(...t) {
  let e = XN;
  for (const n of t) e = e.add(n);
  return e;
}
const QN = new Kt(Xe);
function JN() {
  return QN;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function yh(t, e) {
  if (t.useProto3Json) {
    if (isNaN(e)) return {
      doubleValue: "NaN"
    };
    if (e === 1 / 0) return {
      doubleValue: "Infinity"
    };
    if (e === -1 / 0) return {
      doubleValue: "-Infinity"
    };
  }
  return {
    doubleValue: Fc(e) ? "-0" : e
  };
}
function SE(t) {
  return {
    integerValue: "" + t
  };
}
function ZN(t, e) {
  return kN(e) ? SE(e) : yh(t, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wl {
  constructor() {
    this._ = void 0;
  }
}
function eO(t, e, n) {
  return t instanceof $c ? function(i, s) {
    const o = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: i.seconds,
            nanos: i.nanoseconds
          }
        }
      }
    };
    return s && _l(s) && (s = fh(s)), s && (o.fields.__previous_value__ = s), {
      mapValue: o
    };
  }(n, e) : t instanceof sa ? RE(t, e) : t instanceof oa ? CE(t, e) : function(i, s) {
    const o = AE(i, s), a = Fg(o) + Fg(i.Pe);
    return qd(o) && qd(i.Pe) ? SE(a) : yh(i.serializer, a);
  }(t, e);
}
function tO(t, e, n) {
  return t instanceof sa ? RE(t, e) : t instanceof oa ? CE(t, e) : n;
}
function AE(t, e) {
  return t instanceof jc ? (
    /** Returns true if `value` is either an IntegerValue or a DoubleValue. */
    function(r) {
      return qd(r) || function(s) {
        return !!s && "doubleValue" in s;
      }(r);
    }(e) ? e : {
      integerValue: 0
    }
  ) : null;
}
class $c extends wl {
}
class sa extends wl {
  constructor(e) {
    super(), this.elements = e;
  }
}
function RE(t, e) {
  const n = kE(e);
  for (const r of t.elements) n.some((i) => wr(i, r)) || n.push(r);
  return {
    arrayValue: {
      values: n
    }
  };
}
class oa extends wl {
  constructor(e) {
    super(), this.elements = e;
  }
}
function CE(t, e) {
  let n = kE(e);
  for (const r of t.elements) n = n.filter((i) => !wr(i, r));
  return {
    arrayValue: {
      values: n
    }
  };
}
class jc extends wl {
  constructor(e, n) {
    super(), this.serializer = e, this.Pe = n;
  }
}
function Fg(t) {
  return Pt(t.integerValue || t.doubleValue);
}
function kE(t) {
  return hh(t) && t.arrayValue.values ? t.arrayValue.values.slice() : [];
}
function nO(t, e) {
  return t.field.isEqual(e.field) && function(r, i) {
    return r instanceof sa && i instanceof sa || r instanceof oa && i instanceof oa ? Ys(r.elements, i.elements, wr) : r instanceof jc && i instanceof jc ? wr(r.Pe, i.Pe) : r instanceof $c && i instanceof $c;
  }(t.transform, e.transform);
}
class rO {
  constructor(e, n) {
    this.version = e, this.transformResults = n;
  }
}
class _r {
  constructor(e, n) {
    this.updateTime = e, this.exists = n;
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new _r();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(e) {
    return new _r(void 0, e);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(e) {
    return new _r(e);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(e) {
    return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
  }
}
function yc(t, e) {
  return t.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t.updateTime) : t.exists === void 0 || t.exists === e.isFoundDocument();
}
class Tl {
}
function NE(t, e) {
  if (!t.hasLocalMutations || e && e.fields.length === 0) return null;
  if (e === null) return t.isNoDocument() ? new _h(t.key, _r.none()) : new Ea(t.key, t.data, _r.none());
  {
    const n = t.data, r = Vn.empty();
    let i = new Kt(Ht.comparator);
    for (let s of e.fields) if (!i.has(s)) {
      let o = n.field(s);
      o === null && s.length > 1 && (s = s.popLast(), o = n.field(s)), o === null ? r.delete(s) : r.set(s, o), i = i.add(s);
    }
    return new ds(t.key, r, new Qn(i.toArray()), _r.none());
  }
}
function iO(t, e, n) {
  t instanceof Ea ? function(i, s, o) {
    const a = i.value.clone(), l = Bg(i.fieldTransforms, s, o.transformResults);
    a.setAll(l), s.convertToFoundDocument(o.version, a).setHasCommittedMutations();
  }(t, e, n) : t instanceof ds ? function(i, s, o) {
    if (!yc(i.precondition, s))
      return void s.convertToUnknownDocument(o.version);
    const a = Bg(i.fieldTransforms, s, o.transformResults), l = s.data;
    l.setAll(OE(i)), l.setAll(a), s.convertToFoundDocument(o.version, l).setHasCommittedMutations();
  }(t, e, n) : function(i, s, o) {
    s.convertToNoDocument(o.version).setHasCommittedMutations();
  }(0, e, n);
}
function zo(t, e, n, r) {
  return t instanceof Ea ? function(s, o, a, l) {
    if (!yc(s.precondition, o))
      return a;
    const u = s.value.clone(), d = $g(s.fieldTransforms, l, o);
    return u.setAll(d), o.convertToFoundDocument(o.version, u).setHasLocalMutations(), null;
  }(t, e, n, r) : t instanceof ds ? function(s, o, a, l) {
    if (!yc(s.precondition, o)) return a;
    const u = $g(s.fieldTransforms, l, o), d = o.data;
    return d.setAll(OE(s)), d.setAll(u), o.convertToFoundDocument(o.version, d).setHasLocalMutations(), a === null ? null : a.unionWith(s.fieldMask.fields).unionWith(s.fieldTransforms.map((f) => f.field));
  }(t, e, n, r) : function(s, o, a) {
    return yc(s.precondition, o) ? (o.convertToNoDocument(o.version).setHasLocalMutations(), null) : a;
  }(t, e, n);
}
function sO(t, e) {
  let n = null;
  for (const r of t.fieldTransforms) {
    const i = e.data.field(r.field), s = AE(r.transform, i || null);
    s != null && (n === null && (n = Vn.empty()), n.set(r.field, s));
  }
  return n || null;
}
function Vg(t, e) {
  return t.type === e.type && !!t.key.isEqual(e.key) && !!t.precondition.isEqual(e.precondition) && !!function(r, i) {
    return r === void 0 && i === void 0 || !(!r || !i) && Ys(r, i, (s, o) => nO(s, o));
  }(t.fieldTransforms, e.fieldTransforms) && (t.type === 0 ? t.value.isEqual(e.value) : t.type !== 1 || t.data.isEqual(e.data) && t.fieldMask.isEqual(e.fieldMask));
}
class Ea extends Tl {
  constructor(e, n, r, i = []) {
    super(), this.key = e, this.value = n, this.precondition = r, this.fieldTransforms = i, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
}
class ds extends Tl {
  constructor(e, n, r, i, s = []) {
    super(), this.key = e, this.data = n, this.fieldMask = r, this.precondition = i, this.fieldTransforms = s, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
function OE(t) {
  const e = /* @__PURE__ */ new Map();
  return t.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const r = t.data.field(n);
      e.set(n, r);
    }
  }), e;
}
function Bg(t, e, n) {
  const r = /* @__PURE__ */ new Map();
  it(t.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const s = t[i], o = s.transform, a = e.data.field(s.field);
    r.set(s.field, tO(o, a, n[i]));
  }
  return r;
}
function $g(t, e, n) {
  const r = /* @__PURE__ */ new Map();
  for (const i of t) {
    const s = i.transform, o = n.data.field(i.field);
    r.set(i.field, eO(s, o, e));
  }
  return r;
}
class _h extends Tl {
  constructor(e, n) {
    super(), this.key = e, this.precondition = n, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
class oO extends Tl {
  constructor(e, n) {
    super(), this.key = e, this.precondition = n, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aO {
  /**
   * @param batchId - The unique ID of this mutation batch.
   * @param localWriteTime - The original write time of this mutation.
   * @param baseMutations - Mutations that are used to populate the base
   * values when this mutation is applied locally. This can be used to locally
   * overwrite values that are persisted in the remote document cache. Base
   * mutations are never sent to the backend.
   * @param mutations - The user-provided mutations in this mutation batch.
   * User-provided mutations are applied both locally and remotely on the
   * backend.
   */
  constructor(e, n, r, i) {
    this.batchId = e, this.localWriteTime = n, this.baseMutations = r, this.mutations = i;
  }
  /**
   * Applies all the mutations in this MutationBatch to the specified document
   * to compute the state of the remote document
   *
   * @param document - The document to apply mutations to.
   * @param batchResult - The result of applying the MutationBatch to the
   * backend.
   */
  applyToRemoteDocument(e, n) {
    const r = n.mutationResults;
    for (let i = 0; i < this.mutations.length; i++) {
      const s = this.mutations[i];
      s.key.isEqual(e.key) && iO(s, e, r[i]);
    }
  }
  /**
   * Computes the local view of a document given all the mutations in this
   * batch.
   *
   * @param document - The document to apply mutations to.
   * @param mutatedFields - Fields that have been updated before applying this mutation batch.
   * @returns A `FieldMask` representing all the fields that are mutated.
   */
  applyToLocalView(e, n) {
    for (const r of this.baseMutations) r.key.isEqual(e.key) && (n = zo(r, e, n, this.localWriteTime));
    for (const r of this.mutations) r.key.isEqual(e.key) && (n = zo(r, e, n, this.localWriteTime));
    return n;
  }
  /**
   * Computes the local view for all provided documents given the mutations in
   * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to
   * replace all the mutation applications.
   */
  applyToLocalDocumentSet(e, n) {
    const r = IE();
    return this.mutations.forEach((i) => {
      const s = e.get(i.key), o = s.overlayedDocument;
      let a = this.applyToLocalView(o, s.mutatedFields);
      a = n.has(i.key) ? null : a;
      const l = NE(o, a);
      l !== null && r.set(i.key, l), o.isValidDocument() || o.convertToNoDocument(Pe.min());
    }), r;
  }
  keys() {
    return this.mutations.reduce((e, n) => e.add(n.key), qe());
  }
  isEqual(e) {
    return this.batchId === e.batchId && Ys(this.mutations, e.mutations, (n, r) => Vg(n, r)) && Ys(this.baseMutations, e.baseMutations, (n, r) => Vg(n, r));
  }
}
class bh {
  constructor(e, n, r, i) {
    this.batch = e, this.commitVersion = n, this.mutationResults = r, this.docVersions = i;
  }
  /**
   * Creates a new MutationBatchResult for the given batch and results. There
   * must be one result for each mutation in the batch. This static factory
   * caches a document=&gt;version mapping (docVersions).
   */
  static from(e, n, r) {
    it(e.mutations.length === r.length);
    let i = /* @__PURE__ */ function() {
      return YN;
    }();
    const s = e.mutations;
    for (let o = 0; o < s.length; o++) i = i.insert(s[o].key, r[o].version);
    return new bh(e, n, r, i);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cO {
  constructor(e, n) {
    this.largestBatchId = e, this.mutation = n;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(e) {
    return e !== null && this.mutation === e.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lO {
  constructor(e, n) {
    this.count = e, this.unchangedNames = n;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Dt, He;
function uO(t) {
  switch (t) {
    default:
      return Ne();
    case j.CANCELLED:
    case j.UNKNOWN:
    case j.DEADLINE_EXCEEDED:
    case j.RESOURCE_EXHAUSTED:
    case j.INTERNAL:
    case j.UNAVAILABLE:
    // Unauthenticated means something went wrong with our token and we need
    // to retry with new credentials which will happen automatically.
    case j.UNAUTHENTICATED:
      return !1;
    case j.INVALID_ARGUMENT:
    case j.NOT_FOUND:
    case j.ALREADY_EXISTS:
    case j.PERMISSION_DENIED:
    case j.FAILED_PRECONDITION:
    // Aborted might be retried in some scenarios, but that is dependent on
    // the context and should handled individually by the calling code.
    // See https://cloud.google.com/apis/design/errors.
    case j.ABORTED:
    case j.OUT_OF_RANGE:
    case j.UNIMPLEMENTED:
    case j.DATA_LOSS:
      return !0;
  }
}
function PE(t) {
  if (t === void 0)
    return Yr("GRPC error has no .code"), j.UNKNOWN;
  switch (t) {
    case Dt.OK:
      return j.OK;
    case Dt.CANCELLED:
      return j.CANCELLED;
    case Dt.UNKNOWN:
      return j.UNKNOWN;
    case Dt.DEADLINE_EXCEEDED:
      return j.DEADLINE_EXCEEDED;
    case Dt.RESOURCE_EXHAUSTED:
      return j.RESOURCE_EXHAUSTED;
    case Dt.INTERNAL:
      return j.INTERNAL;
    case Dt.UNAVAILABLE:
      return j.UNAVAILABLE;
    case Dt.UNAUTHENTICATED:
      return j.UNAUTHENTICATED;
    case Dt.INVALID_ARGUMENT:
      return j.INVALID_ARGUMENT;
    case Dt.NOT_FOUND:
      return j.NOT_FOUND;
    case Dt.ALREADY_EXISTS:
      return j.ALREADY_EXISTS;
    case Dt.PERMISSION_DENIED:
      return j.PERMISSION_DENIED;
    case Dt.FAILED_PRECONDITION:
      return j.FAILED_PRECONDITION;
    case Dt.ABORTED:
      return j.ABORTED;
    case Dt.OUT_OF_RANGE:
      return j.OUT_OF_RANGE;
    case Dt.UNIMPLEMENTED:
      return j.UNIMPLEMENTED;
    case Dt.DATA_LOSS:
      return j.DATA_LOSS;
    default:
      return Ne();
  }
}
(He = Dt || (Dt = {}))[He.OK = 0] = "OK", He[He.CANCELLED = 1] = "CANCELLED", He[He.UNKNOWN = 2] = "UNKNOWN", He[He.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", He[He.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", He[He.NOT_FOUND = 5] = "NOT_FOUND", He[He.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", He[He.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", He[He.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", He[He.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", He[He.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", He[He.ABORTED = 10] = "ABORTED", He[He.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", He[He.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", He[He.INTERNAL = 13] = "INTERNAL", He[He.UNAVAILABLE = 14] = "UNAVAILABLE", He[He.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function dO() {
  return new TextEncoder();
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fO = new Yi([4294967295, 4294967295], 0);
function jg(t) {
  const e = dO().encode(t), n = new rE();
  return n.update(e), new Uint8Array(n.digest());
}
function qg(t) {
  const e = new DataView(t.buffer), n = e.getUint32(
    0,
    /* littleEndian= */
    !0
  ), r = e.getUint32(
    4,
    /* littleEndian= */
    !0
  ), i = e.getUint32(
    8,
    /* littleEndian= */
    !0
  ), s = e.getUint32(
    12,
    /* littleEndian= */
    !0
  );
  return [new Yi([n, r], 0), new Yi([i, s], 0)];
}
class vh {
  constructor(e, n, r) {
    if (this.bitmap = e, this.padding = n, this.hashCount = r, n < 0 || n >= 8) throw new Do(`Invalid padding: ${n}`);
    if (r < 0) throw new Do(`Invalid hash count: ${r}`);
    if (e.length > 0 && this.hashCount === 0)
      throw new Do(`Invalid hash count: ${r}`);
    if (e.length === 0 && n !== 0)
      throw new Do(`Invalid padding when bitmap length is 0: ${n}`);
    this.Ie = 8 * e.length - n, // Set the bit count in Integer to avoid repetition in mightContain().
    this.Te = Yi.fromNumber(this.Ie);
  }
  // Calculate the ith hash value based on the hashed 64bit integers,
  // and calculate its corresponding bit index in the bitmap to be checked.
  Ee(e, n, r) {
    let i = e.add(n.multiply(Yi.fromNumber(r)));
    return i.compare(fO) === 1 && (i = new Yi([i.getBits(0), i.getBits(1)], 0)), i.modulo(this.Te).toNumber();
  }
  // Return whether the bit on the given index in the bitmap is set to 1.
  de(e) {
    return (this.bitmap[Math.floor(e / 8)] & 1 << e % 8) != 0;
  }
  mightContain(e) {
    if (this.Ie === 0) return !1;
    const n = jg(e), [r, i] = qg(n);
    for (let s = 0; s < this.hashCount; s++) {
      const o = this.Ee(r, i, s);
      if (!this.de(o)) return !1;
    }
    return !0;
  }
  /** Create bloom filter for testing purposes only. */
  static create(e, n, r) {
    const i = e % 8 == 0 ? 0 : 8 - e % 8, s = new Uint8Array(Math.ceil(e / 8)), o = new vh(s, i, n);
    return r.forEach((a) => o.insert(a)), o;
  }
  insert(e) {
    if (this.Ie === 0) return;
    const n = jg(e), [r, i] = qg(n);
    for (let s = 0; s < this.hashCount; s++) {
      const o = this.Ee(r, i, s);
      this.Ae(o);
    }
  }
  Ae(e) {
    const n = Math.floor(e / 8), r = e % 8;
    this.bitmap[n] |= 1 << r;
  }
}
class Do extends Error {
  constructor() {
    super(...arguments), this.name = "BloomFilterError";
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Il {
  constructor(e, n, r, i, s) {
    this.snapshotVersion = e, this.targetChanges = n, this.targetMismatches = r, this.documentUpdates = i, this.resolvedLimboDocuments = s;
  }
  /**
   * HACK: Views require RemoteEvents in order to determine whether the view is
   * CURRENT, but secondary tabs don't receive remote events. So this method is
   * used to create a synthesized RemoteEvent that can be used to apply a
   * CURRENT status change to a View, for queries executed in a different tab.
   */
  // PORTING NOTE: Multi-tab only
  static createSynthesizedRemoteEventForCurrentChange(e, n, r) {
    const i = /* @__PURE__ */ new Map();
    return i.set(e, wa.createSynthesizedTargetChangeForCurrentChange(e, n, r)), new Il(Pe.min(), i, new Tt(Xe), Xr(), qe());
  }
}
class wa {
  constructor(e, n, r, i, s) {
    this.resumeToken = e, this.current = n, this.addedDocuments = r, this.modifiedDocuments = i, this.removedDocuments = s;
  }
  /**
   * This method is used to create a synthesized TargetChanges that can be used to
   * apply a CURRENT status change to a View (for queries executed in a different
   * tab) or for new queries (to raise snapshots with correct CURRENT status).
   */
  static createSynthesizedTargetChangeForCurrentChange(e, n, r) {
    return new wa(r, n, qe(), qe(), qe());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _c {
  constructor(e, n, r, i) {
    this.Re = e, this.removedTargetIds = n, this.key = r, this.Ve = i;
  }
}
class xE {
  constructor(e, n) {
    this.targetId = e, this.me = n;
  }
}
class ME {
  constructor(e, n, r = Qt.EMPTY_BYTE_STRING, i = null) {
    this.state = e, this.targetIds = n, this.resumeToken = r, this.cause = i;
  }
}
class zg {
  constructor() {
    this.fe = 0, /**
    * Keeps track of the document changes since the last raised snapshot.
    *
    * These changes are continuously updated as we receive document updates and
    * always reflect the current set of changes against the last issued snapshot.
    */
    this.ge = Gg(), /** See public getters for explanations of these fields. */
    this.pe = Qt.EMPTY_BYTE_STRING, this.ye = !1, /**
    * Whether this target state should be included in the next snapshot. We
    * initialize to true so that newly-added targets are included in the next
    * RemoteEvent.
    */
    this.we = !0;
  }
  /**
   * Whether this target has been marked 'current'.
   *
   * 'Current' has special meaning in the RPC protocol: It implies that the
   * Watch backend has sent us all changes up to the point at which the target
   * was added and that the target is consistent with the rest of the watch
   * stream.
   */
  get current() {
    return this.ye;
  }
  /** The last resume token sent to us for this target. */
  get resumeToken() {
    return this.pe;
  }
  /** Whether this target has pending target adds or target removes. */
  get Se() {
    return this.fe !== 0;
  }
  /** Whether we have modified any state that should trigger a snapshot. */
  get be() {
    return this.we;
  }
  /**
   * Applies the resume token to the TargetChange, but only when it has a new
   * value. Empty resumeTokens are discarded.
   */
  De(e) {
    e.approximateByteSize() > 0 && (this.we = !0, this.pe = e);
  }
  /**
   * Creates a target change from the current set of changes.
   *
   * To reset the document changes after raising this snapshot, call
   * `clearPendingChanges()`.
   */
  ve() {
    let e = qe(), n = qe(), r = qe();
    return this.ge.forEach((i, s) => {
      switch (s) {
        case 0:
          e = e.add(i);
          break;
        case 2:
          n = n.add(i);
          break;
        case 1:
          r = r.add(i);
          break;
        default:
          Ne();
      }
    }), new wa(this.pe, this.ye, e, n, r);
  }
  /**
   * Resets the document changes and sets `hasPendingChanges` to false.
   */
  Ce() {
    this.we = !1, this.ge = Gg();
  }
  Fe(e, n) {
    this.we = !0, this.ge = this.ge.insert(e, n);
  }
  Me(e) {
    this.we = !0, this.ge = this.ge.remove(e);
  }
  xe() {
    this.fe += 1;
  }
  Oe() {
    this.fe -= 1, it(this.fe >= 0);
  }
  Ne() {
    this.we = !0, this.ye = !0;
  }
}
class hO {
  constructor(e) {
    this.Le = e, /** The internal state of all tracked targets. */
    this.Be = /* @__PURE__ */ new Map(), /** Keeps track of the documents to update since the last raised snapshot. */
    this.ke = Xr(), /** A mapping of document keys to their set of target IDs. */
    this.qe = Wg(), /**
    * A map of targets with existence filter mismatches. These targets are
    * known to be inconsistent and their listens needs to be re-established by
    * RemoteStore.
    */
    this.Qe = new Tt(Xe);
  }
  /**
   * Processes and adds the DocumentWatchChange to the current set of changes.
   */
  Ke(e) {
    for (const n of e.Re) e.Ve && e.Ve.isFoundDocument() ? this.$e(n, e.Ve) : this.Ue(n, e.key, e.Ve);
    for (const n of e.removedTargetIds) this.Ue(n, e.key, e.Ve);
  }
  /** Processes and adds the WatchTargetChange to the current set of changes. */
  We(e) {
    this.forEachTarget(e, (n) => {
      const r = this.Ge(n);
      switch (e.state) {
        case 0:
          this.ze(n) && r.De(e.resumeToken);
          break;
        case 1:
          r.Oe(), r.Se || // We have a freshly added target, so we need to reset any state
          // that we had previously. This can happen e.g. when remove and add
          // back a target for existence filter mismatches.
          r.Ce(), r.De(e.resumeToken);
          break;
        case 2:
          r.Oe(), r.Se || this.removeTarget(n);
          break;
        case 3:
          this.ze(n) && (r.Ne(), r.De(e.resumeToken));
          break;
        case 4:
          this.ze(n) && // Reset the target and synthesizes removes for all existing
          // documents. The backend will re-add any documents that still
          // match the target before it sends the next global snapshot.
          (this.je(n), r.De(e.resumeToken));
          break;
        default:
          Ne();
      }
    });
  }
  /**
   * Iterates over all targetIds that the watch change applies to: either the
   * targetIds explicitly listed in the change or the targetIds of all currently
   * active targets.
   */
  forEachTarget(e, n) {
    e.targetIds.length > 0 ? e.targetIds.forEach(n) : this.Be.forEach((r, i) => {
      this.ze(i) && n(i);
    });
  }
  /**
   * Handles existence filters and synthesizes deletes for filter mismatches.
   * Targets that are invalidated by filter mismatches are added to
   * `pendingTargetResets`.
   */
  He(e) {
    const n = e.targetId, r = e.me.count, i = this.Je(n);
    if (i) {
      const s = i.target;
      if (Wd(s)) if (r === 0) {
        const o = new ve(s.path);
        this.Ue(n, o, an.newNoDocument(o, Pe.min()));
      } else it(r === 1);
      else {
        const o = this.Ye(n);
        if (o !== r) {
          const a = this.Ze(e), l = a ? this.Xe(a, e, o) : 1;
          if (l !== 0) {
            this.je(n);
            const u = l === 2 ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch";
            this.Qe = this.Qe.insert(n, u);
          }
        }
      }
    }
  }
  /**
   * Parse the bloom filter from the "unchanged_names" field of an existence
   * filter.
   */
  Ze(e) {
    const n = e.me.unchangedNames;
    if (!n || !n.bits) return null;
    const { bits: { bitmap: r = "", padding: i = 0 }, hashCount: s = 0 } = n;
    let o, a;
    try {
      o = ts(r).toUint8Array();
    } catch (l) {
      if (l instanceof fE) return Ks("Decoding the base64 bloom filter in existence filter failed (" + l.message + "); ignoring the bloom filter and falling back to full re-query."), null;
      throw l;
    }
    try {
      a = new vh(o, i, s);
    } catch (l) {
      return Ks(l instanceof Do ? "BloomFilter error: " : "Applying bloom filter failed: ", l), null;
    }
    return a.Ie === 0 ? null : a;
  }
  /**
   * Apply bloom filter to remove the deleted documents, and return the
   * application status.
   */
  Xe(e, n, r) {
    return n.me.count === r - this.nt(e, n.targetId) ? 0 : 2;
  }
  /**
   * Filter out removed documents based on bloom filter membership result and
   * return number of documents removed.
   */
  nt(e, n) {
    const r = this.Le.getRemoteKeysForTarget(n);
    let i = 0;
    return r.forEach((s) => {
      const o = this.Le.tt(), a = `projects/${o.projectId}/databases/${o.database}/documents/${s.path.canonicalString()}`;
      e.mightContain(a) || (this.Ue(
        n,
        s,
        /*updatedDocument=*/
        null
      ), i++);
    }), i;
  }
  /**
   * Converts the currently accumulated state into a remote event at the
   * provided snapshot version. Resets the accumulated changes before returning.
   */
  rt(e) {
    const n = /* @__PURE__ */ new Map();
    this.Be.forEach((s, o) => {
      const a = this.Je(o);
      if (a) {
        if (s.current && Wd(a.target)) {
          const l = new ve(a.target.path);
          this.ke.get(l) !== null || this.it(o, l) || this.Ue(o, l, an.newNoDocument(l, e));
        }
        s.be && (n.set(o, s.ve()), s.Ce());
      }
    });
    let r = qe();
    this.qe.forEach((s, o) => {
      let a = !0;
      o.forEachWhile((l) => {
        const u = this.Je(l);
        return !u || u.purpose === "TargetPurposeLimboResolution" || (a = !1, !1);
      }), a && (r = r.add(s));
    }), this.ke.forEach((s, o) => o.setReadTime(e));
    const i = new Il(e, n, this.Qe, this.ke, r);
    return this.ke = Xr(), this.qe = Wg(), this.Qe = new Tt(Xe), i;
  }
  /**
   * Adds the provided document to the internal list of document updates and
   * its document key to the given target's mapping.
   */
  // Visible for testing.
  $e(e, n) {
    if (!this.ze(e)) return;
    const r = this.it(e, n.key) ? 2 : 0;
    this.Ge(e).Fe(n.key, r), this.ke = this.ke.insert(n.key, n), this.qe = this.qe.insert(n.key, this.st(n.key).add(e));
  }
  /**
   * Removes the provided document from the target mapping. If the
   * document no longer matches the target, but the document's state is still
   * known (e.g. we know that the document was deleted or we received the change
   * that caused the filter mismatch), the new document can be provided
   * to update the remote document cache.
   */
  // Visible for testing.
  Ue(e, n, r) {
    if (!this.ze(e)) return;
    const i = this.Ge(e);
    this.it(e, n) ? i.Fe(
      n,
      1
      /* ChangeType.Removed */
    ) : (
      // The document may have entered and left the target before we raised a
      // snapshot, so we can just ignore the change.
      i.Me(n)
    ), this.qe = this.qe.insert(n, this.st(n).delete(e)), r && (this.ke = this.ke.insert(n, r));
  }
  removeTarget(e) {
    this.Be.delete(e);
  }
  /**
   * Returns the current count of documents in the target. This includes both
   * the number of documents that the LocalStore considers to be part of the
   * target as well as any accumulated changes.
   */
  Ye(e) {
    const n = this.Ge(e).ve();
    return this.Le.getRemoteKeysForTarget(e).size + n.addedDocuments.size - n.removedDocuments.size;
  }
  /**
   * Increment the number of acks needed from watch before we can consider the
   * server to be 'in-sync' with the client's active targets.
   */
  xe(e) {
    this.Ge(e).xe();
  }
  Ge(e) {
    let n = this.Be.get(e);
    return n || (n = new zg(), this.Be.set(e, n)), n;
  }
  st(e) {
    let n = this.qe.get(e);
    return n || (n = new Kt(Xe), this.qe = this.qe.insert(e, n)), n;
  }
  /**
   * Verifies that the user is still interested in this target (by calling
   * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs
   * from watch.
   */
  ze(e) {
    const n = this.Je(e) !== null;
    return n || fe("WatchChangeAggregator", "Detected inactive target", e), n;
  }
  /**
   * Returns the TargetData for an active target (i.e. a target that the user
   * is still interested in that has no outstanding target change requests).
   */
  Je(e) {
    const n = this.Be.get(e);
    return n && n.Se ? null : this.Le.ot(e);
  }
  /**
   * Resets the state of a Watch target to its initial state (e.g. sets
   * 'current' to false, clears the resume token and removes its target mapping
   * from all documents).
   */
  je(e) {
    this.Be.set(e, new zg()), this.Le.getRemoteKeysForTarget(e).forEach((n) => {
      this.Ue(
        e,
        n,
        /*updatedDocument=*/
        null
      );
    });
  }
  /**
   * Returns whether the LocalStore considers the document to be part of the
   * specified target.
   */
  it(e, n) {
    return this.Le.getRemoteKeysForTarget(e).has(n);
  }
}
function Wg() {
  return new Tt(ve.comparator);
}
function Gg() {
  return new Tt(ve.comparator);
}
const pO = {
  asc: "ASCENDING",
  desc: "DESCENDING"
}, mO = {
  "<": "LESS_THAN",
  "<=": "LESS_THAN_OR_EQUAL",
  ">": "GREATER_THAN",
  ">=": "GREATER_THAN_OR_EQUAL",
  "==": "EQUAL",
  "!=": "NOT_EQUAL",
  "array-contains": "ARRAY_CONTAINS",
  in: "IN",
  "not-in": "NOT_IN",
  "array-contains-any": "ARRAY_CONTAINS_ANY"
}, gO = {
  and: "AND",
  or: "OR"
};
class yO {
  constructor(e, n) {
    this.databaseId = e, this.useProto3Json = n;
  }
}
function Hd(t, e) {
  return t.useProto3Json || yl(e) ? e : {
    value: e
  };
}
function qc(t, e) {
  return t.useProto3Json ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z` : {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function DE(t, e) {
  return t.useProto3Json ? e.toBase64() : e.toUint8Array();
}
function _O(t, e) {
  return qc(t, e.toTimestamp());
}
function br(t) {
  return it(!!t), Pe.fromTimestamp(function(n) {
    const r = wi(n);
    return new Vt(r.seconds, r.nanos);
  }(t));
}
function Eh(t, e) {
  return Kd(t, e).canonicalString();
}
function Kd(t, e) {
  const n = function(i) {
    return new mt(["projects", i.projectId, "databases", i.database]);
  }(t).child("documents");
  return e === void 0 ? n : n.child(e);
}
function LE(t) {
  const e = mt.fromString(t);
  return it($E(e)), e;
}
function Yd(t, e) {
  return Eh(t.databaseId, e.path);
}
function mu(t, e) {
  const n = LE(e);
  if (n.get(1) !== t.databaseId.projectId) throw new ne(j.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t.databaseId.projectId);
  if (n.get(3) !== t.databaseId.database) throw new ne(j.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t.databaseId.database);
  return new ve(FE(n));
}
function UE(t, e) {
  return Eh(t.databaseId, e);
}
function bO(t) {
  const e = LE(t);
  return e.length === 4 ? mt.emptyPath() : FE(e);
}
function Xd(t) {
  return new mt(["projects", t.databaseId.projectId, "databases", t.databaseId.database]).canonicalString();
}
function FE(t) {
  return it(t.length > 4 && t.get(4) === "documents"), t.popFirst(5);
}
function Hg(t, e, n) {
  return {
    name: Yd(t, e),
    fields: n.value.mapValue.fields
  };
}
function vO(t, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const r = function(u) {
      return u === "NO_CHANGE" ? 0 : u === "ADD" ? 1 : u === "REMOVE" ? 2 : u === "CURRENT" ? 3 : u === "RESET" ? 4 : Ne();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], s = function(u, d) {
      return u.useProto3Json ? (it(d === void 0 || typeof d == "string"), Qt.fromBase64String(d || "")) : (it(d === void 0 || // Check if the value is an instance of both Buffer and Uint8Array,
      // despite the fact that Buffer extends Uint8Array. In some
      // environments, such as jsdom, the prototype chain of Buffer
      // does not indicate that it extends Uint8Array.
      d instanceof Buffer || d instanceof Uint8Array), Qt.fromUint8Array(d || new Uint8Array()));
    }(t, e.targetChange.resumeToken), o = e.targetChange.cause, a = o && function(u) {
      const d = u.code === void 0 ? j.UNKNOWN : PE(u.code);
      return new ne(d, u.message || "");
    }(o);
    n = new ME(r, i, s, a || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const r = e.documentChange;
    r.document, r.document.name, r.document.updateTime;
    const i = mu(t, r.document.name), s = br(r.document.updateTime), o = r.document.createTime ? br(r.document.createTime) : Pe.min(), a = new Vn({
      mapValue: {
        fields: r.document.fields
      }
    }), l = an.newFoundDocument(i, s, o, a), u = r.targetIds || [], d = r.removedTargetIds || [];
    n = new _c(u, d, l.key, l);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const r = e.documentDelete;
    r.document;
    const i = mu(t, r.document), s = r.readTime ? br(r.readTime) : Pe.min(), o = an.newNoDocument(i, s), a = r.removedTargetIds || [];
    n = new _c([], a, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const r = e.documentRemove;
    r.document;
    const i = mu(t, r.document), s = r.removedTargetIds || [];
    n = new _c([], s, i, null);
  } else {
    if (!("filter" in e)) return Ne();
    {
      e.filter;
      const r = e.filter;
      r.targetId;
      const { count: i = 0, unchangedNames: s } = r, o = new lO(i, s), a = r.targetId;
      n = new xE(a, o);
    }
  }
  return n;
}
function EO(t, e) {
  let n;
  if (e instanceof Ea) n = {
    update: Hg(t, e.key, e.value)
  };
  else if (e instanceof _h) n = {
    delete: Yd(t, e.key)
  };
  else if (e instanceof ds) n = {
    update: Hg(t, e.key, e.data),
    updateMask: NO(e.fieldMask)
  };
  else {
    if (!(e instanceof oO)) return Ne();
    n = {
      verify: Yd(t, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((r) => function(s, o) {
    const a = o.transform;
    if (a instanceof $c) return {
      fieldPath: o.field.canonicalString(),
      setToServerValue: "REQUEST_TIME"
    };
    if (a instanceof sa) return {
      fieldPath: o.field.canonicalString(),
      appendMissingElements: {
        values: a.elements
      }
    };
    if (a instanceof oa) return {
      fieldPath: o.field.canonicalString(),
      removeAllFromArray: {
        values: a.elements
      }
    };
    if (a instanceof jc) return {
      fieldPath: o.field.canonicalString(),
      increment: a.Pe
    };
    throw Ne();
  }(0, r))), e.precondition.isNone || (n.currentDocument = function(i, s) {
    return s.updateTime !== void 0 ? {
      updateTime: _O(i, s.updateTime)
    } : s.exists !== void 0 ? {
      exists: s.exists
    } : Ne();
  }(t, e.precondition)), n;
}
function wO(t, e) {
  return t && t.length > 0 ? (it(e !== void 0), t.map((n) => function(i, s) {
    let o = i.updateTime ? br(i.updateTime) : br(s);
    return o.isEqual(Pe.min()) && // The Firestore Emulator currently returns an update time of 0 for
    // deletes of non-existing documents (rather than null). This breaks the
    // test "get deleted doc while offline with source=cache" as NoDocuments
    // with version 0 are filtered by IndexedDb's RemoteDocumentCache.
    // TODO(#2149): Remove this when Emulator is fixed
    (o = br(s)), new rO(o, i.transformResults || []);
  }(n, e))) : [];
}
function TO(t, e) {
  return {
    documents: [UE(t, e.path)]
  };
}
function IO(t, e) {
  const n = {
    structuredQuery: {}
  }, r = e.path;
  let i;
  e.collectionGroup !== null ? (i = r, n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: !0
  }]) : (i = r.popLast(), n.structuredQuery.from = [{
    collectionId: r.lastSegment()
  }]), n.parent = UE(t, i);
  const s = function(u) {
    if (u.length !== 0)
      return BE(nr.create(
        u,
        "and"
        /* CompositeOperator.AND */
      ));
  }(e.filters);
  s && (n.structuredQuery.where = s);
  const o = function(u) {
    if (u.length !== 0)
      return u.map((d) => (
        // visible for testing
        function(p) {
          return {
            field: Ts(p.field),
            direction: RO(p.dir)
          };
        }(d)
      ));
  }(e.orderBy);
  o && (n.structuredQuery.orderBy = o);
  const a = Hd(t, e.limit);
  return a !== null && (n.structuredQuery.limit = a), e.startAt && (n.structuredQuery.startAt = function(u) {
    return {
      before: u.inclusive,
      values: u.position
    };
  }(e.startAt)), e.endAt && (n.structuredQuery.endAt = function(u) {
    return {
      before: !u.inclusive,
      values: u.position
    };
  }(e.endAt)), {
    _t: n,
    parent: i
  };
}
function SO(t) {
  let e = bO(t.parent);
  const n = t.structuredQuery, r = n.from ? n.from.length : 0;
  let i = null;
  if (r > 0) {
    it(r === 1);
    const d = n.from[0];
    d.allDescendants ? i = d.collectionId : e = e.child(d.collectionId);
  }
  let s = [];
  n.where && (s = function(f) {
    const p = VE(f);
    return p instanceof nr && gE(p) ? p.getFilters() : [p];
  }(n.where));
  let o = [];
  n.orderBy && (o = function(f) {
    return f.map((p) => function(_) {
      return new ia(
        Is(_.field),
        // visible for testing
        function(m) {
          switch (m) {
            case "ASCENDING":
              return "asc";
            case "DESCENDING":
              return "desc";
            default:
              return;
          }
        }(_.direction)
      );
    }(p));
  }(n.orderBy));
  let a = null;
  n.limit && (a = function(f) {
    let p;
    return p = typeof f == "object" ? f.value : f, yl(p) ? null : p;
  }(n.limit));
  let l = null;
  n.startAt && (l = function(f) {
    const p = !!f.before, g = f.values || [];
    return new Js(g, p);
  }(n.startAt));
  let u = null;
  return n.endAt && (u = function(f) {
    const p = !f.before, g = f.values || [];
    return new Js(g, p);
  }(n.endAt)), zN(e, i, o, s, a, "F", l, u);
}
function AO(t, e) {
  const n = function(i) {
    switch (i) {
      case "TargetPurposeListen":
        return null;
      case "TargetPurposeExistenceFilterMismatch":
        return "existence-filter-mismatch";
      case "TargetPurposeExistenceFilterMismatchBloom":
        return "existence-filter-mismatch-bloom";
      case "TargetPurposeLimboResolution":
        return "limbo-document";
      default:
        return Ne();
    }
  }(e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function VE(t) {
  return t.unaryFilter !== void 0 ? function(n) {
    switch (n.unaryFilter.op) {
      case "IS_NAN":
        const r = Is(n.unaryFilter.field);
        return Lt.create(r, "==", {
          doubleValue: NaN
        });
      case "IS_NULL":
        const i = Is(n.unaryFilter.field);
        return Lt.create(i, "==", {
          nullValue: "NULL_VALUE"
        });
      case "IS_NOT_NAN":
        const s = Is(n.unaryFilter.field);
        return Lt.create(s, "!=", {
          doubleValue: NaN
        });
      case "IS_NOT_NULL":
        const o = Is(n.unaryFilter.field);
        return Lt.create(o, "!=", {
          nullValue: "NULL_VALUE"
        });
      default:
        return Ne();
    }
  }(t) : t.fieldFilter !== void 0 ? function(n) {
    return Lt.create(Is(n.fieldFilter.field), function(i) {
      switch (i) {
        case "EQUAL":
          return "==";
        case "NOT_EQUAL":
          return "!=";
        case "GREATER_THAN":
          return ">";
        case "GREATER_THAN_OR_EQUAL":
          return ">=";
        case "LESS_THAN":
          return "<";
        case "LESS_THAN_OR_EQUAL":
          return "<=";
        case "ARRAY_CONTAINS":
          return "array-contains";
        case "IN":
          return "in";
        case "NOT_IN":
          return "not-in";
        case "ARRAY_CONTAINS_ANY":
          return "array-contains-any";
        default:
          return Ne();
      }
    }(n.fieldFilter.op), n.fieldFilter.value);
  }(t) : t.compositeFilter !== void 0 ? function(n) {
    return nr.create(n.compositeFilter.filters.map((r) => VE(r)), function(i) {
      switch (i) {
        case "AND":
          return "and";
        case "OR":
          return "or";
        default:
          return Ne();
      }
    }(n.compositeFilter.op));
  }(t) : Ne();
}
function RO(t) {
  return pO[t];
}
function CO(t) {
  return mO[t];
}
function kO(t) {
  return gO[t];
}
function Ts(t) {
  return {
    fieldPath: t.canonicalString()
  };
}
function Is(t) {
  return Ht.fromServerFormat(t.fieldPath);
}
function BE(t) {
  return t instanceof Lt ? function(n) {
    if (n.op === "==") {
      if (xg(n.value)) return {
        unaryFilter: {
          field: Ts(n.field),
          op: "IS_NAN"
        }
      };
      if (Pg(n.value)) return {
        unaryFilter: {
          field: Ts(n.field),
          op: "IS_NULL"
        }
      };
    } else if (n.op === "!=") {
      if (xg(n.value)) return {
        unaryFilter: {
          field: Ts(n.field),
          op: "IS_NOT_NAN"
        }
      };
      if (Pg(n.value)) return {
        unaryFilter: {
          field: Ts(n.field),
          op: "IS_NOT_NULL"
        }
      };
    }
    return {
      fieldFilter: {
        field: Ts(n.field),
        op: CO(n.op),
        value: n.value
      }
    };
  }(t) : t instanceof nr ? function(n) {
    const r = n.getFilters().map((i) => BE(i));
    return r.length === 1 ? r[0] : {
      compositeFilter: {
        op: kO(n.op),
        filters: r
      }
    };
  }(t) : Ne();
}
function NO(t) {
  const e = [];
  return t.fields.forEach((n) => e.push(n.canonicalString())), {
    fieldPaths: e
  };
}
function $E(t) {
  return t.length >= 4 && t.get(0) === "projects" && t.get(2) === "databases";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pi {
  constructor(e, n, r, i, s = Pe.min(), o = Pe.min(), a = Qt.EMPTY_BYTE_STRING, l = null) {
    this.target = e, this.targetId = n, this.purpose = r, this.sequenceNumber = i, this.snapshotVersion = s, this.lastLimboFreeSnapshotVersion = o, this.resumeToken = a, this.expectedCount = l;
  }
  /** Creates a new target data instance with an updated sequence number. */
  withSequenceNumber(e) {
    return new pi(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);
  }
  /**
   * Creates a new target data instance with an updated resume token and
   * snapshot version.
   */
  withResumeToken(e, n) {
    return new pi(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      n,
      this.lastLimboFreeSnapshotVersion,
      e,
      /* expectedCount= */
      null
    );
  }
  /**
   * Creates a new target data instance with an updated expected count.
   */
  withExpectedCount(e) {
    return new pi(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, e);
  }
  /**
   * Creates a new target data instance with an updated last limbo free
   * snapshot version number.
   */
  withLastLimboFreeSnapshotVersion(e) {
    return new pi(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OO {
  constructor(e) {
    this.ct = e;
  }
}
function PO(t) {
  const e = SO({
    parent: t.parent,
    structuredQuery: t.structuredQuery
  });
  return t.limitType === "LAST" ? Bc(
    e,
    e.limit,
    "L"
    /* LimitType.Last */
  ) : e;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xO {
  constructor() {
    this.un = new MO();
  }
  addToCollectionParentIndex(e, n) {
    return this.un.add(n), W.resolve();
  }
  getCollectionParents(e, n) {
    return W.resolve(this.un.getEntries(n));
  }
  addFieldIndex(e, n) {
    return W.resolve();
  }
  deleteFieldIndex(e, n) {
    return W.resolve();
  }
  deleteAllFieldIndexes(e) {
    return W.resolve();
  }
  createTargetIndexes(e, n) {
    return W.resolve();
  }
  getDocumentsMatchingTarget(e, n) {
    return W.resolve(null);
  }
  getIndexType(e, n) {
    return W.resolve(
      0
      /* IndexType.NONE */
    );
  }
  getFieldIndexes(e, n) {
    return W.resolve([]);
  }
  getNextCollectionGroupToUpdate(e) {
    return W.resolve(null);
  }
  getMinOffset(e, n) {
    return W.resolve(Ei.min());
  }
  getMinOffsetFromCollectionGroup(e, n) {
    return W.resolve(Ei.min());
  }
  updateCollectionGroup(e, n, r) {
    return W.resolve();
  }
  updateIndexEntries(e, n) {
    return W.resolve();
  }
}
class MO {
  constructor() {
    this.index = {};
  }
  // Returns false if the entry already existed.
  add(e) {
    const n = e.lastSegment(), r = e.popLast(), i = this.index[n] || new Kt(mt.comparator), s = !i.has(r);
    return this.index[n] = i.add(r), s;
  }
  has(e) {
    const n = e.lastSegment(), r = e.popLast(), i = this.index[n];
    return i && i.has(r);
  }
  getEntries(e) {
    return (this.index[e] || new Kt(mt.comparator)).toArray();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zs {
  constructor(e) {
    this.Ln = e;
  }
  next() {
    return this.Ln += 2, this.Ln;
  }
  static Bn() {
    return new Zs(0);
  }
  static kn() {
    return new Zs(-1);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DO {
  constructor() {
    this.changes = new uo((e) => e.toString(), (e, n) => e.isEqual(n)), this.changesApplied = !1;
  }
  /**
   * Buffers a `RemoteDocumentCache.addEntry()` call.
   *
   * You can only modify documents that have already been retrieved via
   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
   */
  addEntry(e) {
    this.assertNotApplied(), this.changes.set(e.key, e);
  }
  /**
   * Buffers a `RemoteDocumentCache.removeEntry()` call.
   *
   * You can only remove documents that have already been retrieved via
   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
   */
  removeEntry(e, n) {
    this.assertNotApplied(), this.changes.set(e, an.newInvalidDocument(e).setReadTime(n));
  }
  /**
   * Looks up an entry in the cache. The buffered changes will first be checked,
   * and if no buffered change applies, this will forward to
   * `RemoteDocumentCache.getEntry()`.
   *
   * @param transaction - The transaction in which to perform any persistence
   *     operations.
   * @param documentKey - The key of the entry to look up.
   * @returns The cached document or an invalid document if we have nothing
   * cached.
   */
  getEntry(e, n) {
    this.assertNotApplied();
    const r = this.changes.get(n);
    return r !== void 0 ? W.resolve(r) : this.getFromCache(e, n);
  }
  /**
   * Looks up several entries in the cache, forwarding to
   * `RemoteDocumentCache.getEntry()`.
   *
   * @param transaction - The transaction in which to perform any persistence
   *     operations.
   * @param documentKeys - The keys of the entries to look up.
   * @returns A map of cached documents, indexed by key. If an entry cannot be
   *     found, the corresponding key will be mapped to an invalid document.
   */
  getEntries(e, n) {
    return this.getAllFromCache(e, n);
  }
  /**
   * Applies buffered changes to the underlying RemoteDocumentCache, using
   * the provided transaction.
   */
  apply(e) {
    return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(e);
  }
  /** Helper to assert this.changes is not null  */
  assertNotApplied() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LO {
  constructor(e, n) {
    this.overlayedDocument = e, this.mutatedFields = n;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UO {
  constructor(e, n, r, i) {
    this.remoteDocumentCache = e, this.mutationQueue = n, this.documentOverlayCache = r, this.indexManager = i;
  }
  /**
   * Get the local view of the document identified by `key`.
   *
   * @returns Local view of the document or null if we don't have any cached
   * state for it.
   */
  getDocument(e, n) {
    let r = null;
    return this.documentOverlayCache.getOverlay(e, n).next((i) => (r = i, this.remoteDocumentCache.getEntry(e, n))).next((i) => (r !== null && zo(r.mutation, i, Qn.empty(), Vt.now()), i));
  }
  /**
   * Gets the local view of the documents identified by `keys`.
   *
   * If we don't have cached state for a document in `keys`, a NoDocument will
   * be stored for that key in the resulting set.
   */
  getDocuments(e, n) {
    return this.remoteDocumentCache.getEntries(e, n).next((r) => this.getLocalViewOfDocuments(e, r, qe()).next(() => r));
  }
  /**
   * Similar to `getDocuments`, but creates the local view from the given
   * `baseDocs` without retrieving documents from the local store.
   *
   * @param transaction - The transaction this operation is scoped to.
   * @param docs - The documents to apply local mutations to get the local views.
   * @param existenceStateChanged - The set of document keys whose existence state
   *   is changed. This is useful to determine if some documents overlay needs
   *   to be recalculated.
   */
  getLocalViewOfDocuments(e, n, r = qe()) {
    const i = zi();
    return this.populateOverlays(e, i, n).next(() => this.computeViews(e, n, i, r).next((s) => {
      let o = Mo();
      return s.forEach((a, l) => {
        o = o.insert(a, l.overlayedDocument);
      }), o;
    }));
  }
  /**
   * Gets the overlayed documents for the given document map, which will include
   * the local view of those documents and a `FieldMask` indicating which fields
   * are mutated locally, `null` if overlay is a Set or Delete mutation.
   */
  getOverlayedDocuments(e, n) {
    const r = zi();
    return this.populateOverlays(e, r, n).next(() => this.computeViews(e, n, r, qe()));
  }
  /**
   * Fetches the overlays for {@code docs} and adds them to provided overlay map
   * if the map does not already contain an entry for the given document key.
   */
  populateOverlays(e, n, r) {
    const i = [];
    return r.forEach((s) => {
      n.has(s) || i.push(s);
    }), this.documentOverlayCache.getOverlays(e, i).next((s) => {
      s.forEach((o, a) => {
        n.set(o, a);
      });
    });
  }
  /**
   * Computes the local view for the given documents.
   *
   * @param docs - The documents to compute views for. It also has the base
   *   version of the documents.
   * @param overlays - The overlays that need to be applied to the given base
   *   version of the documents.
   * @param existenceStateChanged - A set of documents whose existence states
   *   might have changed. This is used to determine if we need to re-calculate
   *   overlays from mutation queues.
   * @return A map represents the local documents view.
   */
  computeViews(e, n, r, i) {
    let s = Xr();
    const o = qo(), a = function() {
      return qo();
    }();
    return n.forEach((l, u) => {
      const d = r.get(u.key);
      i.has(u.key) && (d === void 0 || d.mutation instanceof ds) ? s = s.insert(u.key, u) : d !== void 0 ? (o.set(u.key, d.mutation.getFieldMask()), zo(d.mutation, u, d.mutation.getFieldMask(), Vt.now())) : (
        // no overlay exists
        // Using EMPTY to indicate there is no overlay for the document.
        o.set(u.key, Qn.empty())
      );
    }), this.recalculateAndSaveOverlays(e, s).next((l) => (l.forEach((u, d) => o.set(u, d)), n.forEach((u, d) => {
      var f;
      return a.set(u, new LO(d, (f = o.get(u)) !== null && f !== void 0 ? f : null));
    }), a));
  }
  recalculateAndSaveOverlays(e, n) {
    const r = qo();
    let i = new Tt((o, a) => o - a), s = qe();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, n).next((o) => {
      for (const a of o) a.keys().forEach((l) => {
        const u = n.get(l);
        if (u === null) return;
        let d = r.get(l) || Qn.empty();
        d = a.applyToLocalView(u, d), r.set(l, d);
        const f = (i.get(a.batchId) || qe()).add(l);
        i = i.insert(a.batchId, f);
      });
    }).next(() => {
      const o = [], a = i.getReverseIterator();
      for (; a.hasNext(); ) {
        const l = a.getNext(), u = l.key, d = l.value, f = IE();
        d.forEach((p) => {
          if (!s.has(p)) {
            const g = NE(n.get(p), r.get(p));
            g !== null && f.set(p, g), s = s.add(p);
          }
        }), o.push(this.documentOverlayCache.saveOverlays(e, u, f));
      }
      return W.waitFor(o);
    }).next(() => r);
  }
  /**
   * Recalculates overlays by reading the documents from remote document cache
   * first, and saves them after they are calculated.
   */
  recalculateAndSaveOverlaysForDocumentKeys(e, n) {
    return this.remoteDocumentCache.getEntries(e, n).next((r) => this.recalculateAndSaveOverlays(e, r));
  }
  /**
   * Performs a query against the local view of all documents.
   *
   * @param transaction - The persistence transaction.
   * @param query - The query to match documents against.
   * @param offset - Read time and key to start scanning by (exclusive).
   * @param context - A optional tracker to keep a record of important details
   *   during database local query execution.
   */
  getDocumentsMatchingQuery(e, n, r, i) {
    return function(o) {
      return ve.isDocumentKey(o.path) && o.collectionGroup === null && o.filters.length === 0;
    }(n) ? this.getDocumentsMatchingDocumentQuery(e, n.path) : gh(n) ? this.getDocumentsMatchingCollectionGroupQuery(e, n, r, i) : this.getDocumentsMatchingCollectionQuery(e, n, r, i);
  }
  /**
   * Given a collection group, returns the next documents that follow the provided offset, along
   * with an updated batch ID.
   *
   * <p>The documents returned by this method are ordered by remote version from the provided
   * offset. If there are no more remote documents after the provided offset, documents with
   * mutations in order of batch id from the offset are returned. Since all documents in a batch are
   * returned together, the total number of documents returned can exceed {@code count}.
   *
   * @param transaction
   * @param collectionGroup The collection group for the documents.
   * @param offset The offset to index into.
   * @param count The number of documents to return
   * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.
   */
  getNextDocuments(e, n, r, i) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(e, n, r, i).next((s) => {
      const o = i - s.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, n, r.largestBatchId, i - s.size) : W.resolve(zi());
      let a = -1, l = s;
      return o.next((u) => W.forEach(u, (d, f) => (a < f.largestBatchId && (a = f.largestBatchId), s.get(d) ? W.resolve() : this.remoteDocumentCache.getEntry(e, d).next((p) => {
        l = l.insert(d, p);
      }))).next(() => this.populateOverlays(e, u, s)).next(() => this.computeViews(e, l, u, qe())).next((d) => ({
        batchId: a,
        changes: TE(d)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(e, n) {
    return this.getDocument(e, new ve(n)).next((r) => {
      let i = Mo();
      return r.isFoundDocument() && (i = i.insert(r.key, r)), i;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(e, n, r, i) {
    const s = n.collectionGroup;
    let o = Mo();
    return this.indexManager.getCollectionParents(e, s).next((a) => W.forEach(a, (l) => {
      const u = function(f, p) {
        return new us(
          p,
          /*collectionGroup=*/
          null,
          f.explicitOrderBy.slice(),
          f.filters.slice(),
          f.limit,
          f.limitType,
          f.startAt,
          f.endAt
        );
      }(n, l.child(s));
      return this.getDocumentsMatchingCollectionQuery(e, u, r, i).next((d) => {
        d.forEach((f, p) => {
          o = o.insert(f, p);
        });
      });
    }).next(() => o));
  }
  getDocumentsMatchingCollectionQuery(e, n, r, i) {
    let s;
    return this.documentOverlayCache.getOverlaysForCollection(e, n.path, r.largestBatchId).next((o) => (s = o, this.remoteDocumentCache.getDocumentsMatchingQuery(e, n, r, s, i))).next((o) => {
      s.forEach((l, u) => {
        const d = u.getKey();
        o.get(d) === null && (o = o.insert(d, an.newInvalidDocument(d)));
      });
      let a = Mo();
      return o.forEach((l, u) => {
        const d = s.get(l);
        d !== void 0 && zo(d.mutation, u, Qn.empty(), Vt.now()), // Finally, insert the documents that still match the query
        El(n, u) && (a = a.insert(l, u));
      }), a;
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FO {
  constructor(e) {
    this.serializer = e, this.hr = /* @__PURE__ */ new Map(), this.Pr = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(e, n) {
    return W.resolve(this.hr.get(n));
  }
  saveBundleMetadata(e, n) {
    return this.hr.set(
      n.id,
      /** Decodes a BundleMetadata proto into a BundleMetadata object. */
      function(i) {
        return {
          id: i.id,
          version: i.version,
          createTime: br(i.createTime)
        };
      }(n)
    ), W.resolve();
  }
  getNamedQuery(e, n) {
    return W.resolve(this.Pr.get(n));
  }
  saveNamedQuery(e, n) {
    return this.Pr.set(n.name, function(i) {
      return {
        name: i.name,
        query: PO(i.bundledQuery),
        readTime: br(i.readTime)
      };
    }(n)), W.resolve();
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VO {
  constructor() {
    this.overlays = new Tt(ve.comparator), this.Ir = /* @__PURE__ */ new Map();
  }
  getOverlay(e, n) {
    return W.resolve(this.overlays.get(n));
  }
  getOverlays(e, n) {
    const r = zi();
    return W.forEach(n, (i) => this.getOverlay(e, i).next((s) => {
      s !== null && r.set(i, s);
    })).next(() => r);
  }
  saveOverlays(e, n, r) {
    return r.forEach((i, s) => {
      this.ht(e, n, s);
    }), W.resolve();
  }
  removeOverlaysForBatchId(e, n, r) {
    const i = this.Ir.get(r);
    return i !== void 0 && (i.forEach((s) => this.overlays = this.overlays.remove(s)), this.Ir.delete(r)), W.resolve();
  }
  getOverlaysForCollection(e, n, r) {
    const i = zi(), s = n.length + 1, o = new ve(n.child("")), a = this.overlays.getIteratorFrom(o);
    for (; a.hasNext(); ) {
      const l = a.getNext().value, u = l.getKey();
      if (!n.isPrefixOf(u.path)) break;
      u.path.length === s && l.largestBatchId > r && i.set(l.getKey(), l);
    }
    return W.resolve(i);
  }
  getOverlaysForCollectionGroup(e, n, r, i) {
    let s = new Tt((u, d) => u - d);
    const o = this.overlays.getIterator();
    for (; o.hasNext(); ) {
      const u = o.getNext().value;
      if (u.getKey().getCollectionGroup() === n && u.largestBatchId > r) {
        let d = s.get(u.largestBatchId);
        d === null && (d = zi(), s = s.insert(u.largestBatchId, d)), d.set(u.getKey(), u);
      }
    }
    const a = zi(), l = s.getIterator();
    for (; l.hasNext() && (l.getNext().value.forEach((u, d) => a.set(u, d)), !(a.size() >= i)); )
      ;
    return W.resolve(a);
  }
  ht(e, n, r) {
    const i = this.overlays.get(r.key);
    if (i !== null) {
      const o = this.Ir.get(i.largestBatchId).delete(r.key);
      this.Ir.set(i.largestBatchId, o);
    }
    this.overlays = this.overlays.insert(r.key, new cO(n, r));
    let s = this.Ir.get(n);
    s === void 0 && (s = qe(), this.Ir.set(n, s)), this.Ir.set(n, s.add(r.key));
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BO {
  constructor() {
    this.sessionToken = Qt.EMPTY_BYTE_STRING;
  }
  getSessionToken(e) {
    return W.resolve(this.sessionToken);
  }
  setSessionToken(e, n) {
    return this.sessionToken = n, W.resolve();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wh {
  constructor() {
    this.Tr = new Kt(Bt.Er), // A set of outstanding references to a document sorted by target id.
    this.dr = new Kt(Bt.Ar);
  }
  /** Returns true if the reference set contains no references. */
  isEmpty() {
    return this.Tr.isEmpty();
  }
  /** Adds a reference to the given document key for the given ID. */
  addReference(e, n) {
    const r = new Bt(e, n);
    this.Tr = this.Tr.add(r), this.dr = this.dr.add(r);
  }
  /** Add references to the given document keys for the given ID. */
  Rr(e, n) {
    e.forEach((r) => this.addReference(r, n));
  }
  /**
   * Removes a reference to the given document key for the given
   * ID.
   */
  removeReference(e, n) {
    this.Vr(new Bt(e, n));
  }
  mr(e, n) {
    e.forEach((r) => this.removeReference(r, n));
  }
  /**
   * Clears all references with a given ID. Calls removeRef() for each key
   * removed.
   */
  gr(e) {
    const n = new ve(new mt([])), r = new Bt(n, e), i = new Bt(n, e + 1), s = [];
    return this.dr.forEachInRange([r, i], (o) => {
      this.Vr(o), s.push(o.key);
    }), s;
  }
  pr() {
    this.Tr.forEach((e) => this.Vr(e));
  }
  Vr(e) {
    this.Tr = this.Tr.delete(e), this.dr = this.dr.delete(e);
  }
  yr(e) {
    const n = new ve(new mt([])), r = new Bt(n, e), i = new Bt(n, e + 1);
    let s = qe();
    return this.dr.forEachInRange([r, i], (o) => {
      s = s.add(o.key);
    }), s;
  }
  containsKey(e) {
    const n = new Bt(e, 0), r = this.Tr.firstAfterOrEqual(n);
    return r !== null && e.isEqual(r.key);
  }
}
class Bt {
  constructor(e, n) {
    this.key = e, this.wr = n;
  }
  /** Compare by key then by ID */
  static Er(e, n) {
    return ve.comparator(e.key, n.key) || Xe(e.wr, n.wr);
  }
  /** Compare by ID then by key */
  static Ar(e, n) {
    return Xe(e.wr, n.wr) || ve.comparator(e.key, n.key);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $O {
  constructor(e, n) {
    this.indexManager = e, this.referenceDelegate = n, /**
    * The set of all mutations that have been sent but not yet been applied to
    * the backend.
    */
    this.mutationQueue = [], /** Next value to use when assigning sequential IDs to each mutation batch. */
    this.Sr = 1, /** An ordered mapping between documents and the mutations batch IDs. */
    this.br = new Kt(Bt.Er);
  }
  checkEmpty(e) {
    return W.resolve(this.mutationQueue.length === 0);
  }
  addMutationBatch(e, n, r, i) {
    const s = this.Sr;
    this.Sr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const o = new aO(s, n, r, i);
    this.mutationQueue.push(o);
    for (const a of i) this.br = this.br.add(new Bt(a.key, s)), this.indexManager.addToCollectionParentIndex(e, a.key.path.popLast());
    return W.resolve(o);
  }
  lookupMutationBatch(e, n) {
    return W.resolve(this.Dr(n));
  }
  getNextMutationBatchAfterBatchId(e, n) {
    const r = n + 1, i = this.vr(r), s = i < 0 ? 0 : i;
    return W.resolve(this.mutationQueue.length > s ? this.mutationQueue[s] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return W.resolve(this.mutationQueue.length === 0 ? -1 : this.Sr - 1);
  }
  getAllMutationBatches(e) {
    return W.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(e, n) {
    const r = new Bt(n, 0), i = new Bt(n, Number.POSITIVE_INFINITY), s = [];
    return this.br.forEachInRange([r, i], (o) => {
      const a = this.Dr(o.wr);
      s.push(a);
    }), W.resolve(s);
  }
  getAllMutationBatchesAffectingDocumentKeys(e, n) {
    let r = new Kt(Xe);
    return n.forEach((i) => {
      const s = new Bt(i, 0), o = new Bt(i, Number.POSITIVE_INFINITY);
      this.br.forEachInRange([s, o], (a) => {
        r = r.add(a.wr);
      });
    }), W.resolve(this.Cr(r));
  }
  getAllMutationBatchesAffectingQuery(e, n) {
    const r = n.path, i = r.length + 1;
    let s = r;
    ve.isDocumentKey(s) || (s = s.child(""));
    const o = new Bt(new ve(s), 0);
    let a = new Kt(Xe);
    return this.br.forEachWhile((l) => {
      const u = l.key.path;
      return !!r.isPrefixOf(u) && // Rows with document keys more than one segment longer than the query
      // path can't be matches. For example, a query on 'rooms' can't match
      // the document /rooms/abc/messages/xyx.
      // TODO(mcg): we'll need a different scanner when we implement
      // ancestor queries.
      (u.length === i && (a = a.add(l.wr)), !0);
    }, o), W.resolve(this.Cr(a));
  }
  Cr(e) {
    const n = [];
    return e.forEach((r) => {
      const i = this.Dr(r);
      i !== null && n.push(i);
    }), n;
  }
  removeMutationBatch(e, n) {
    it(this.Fr(n.batchId, "removed") === 0), this.mutationQueue.shift();
    let r = this.br;
    return W.forEach(n.mutations, (i) => {
      const s = new Bt(i.key, n.batchId);
      return r = r.delete(s), this.referenceDelegate.markPotentiallyOrphaned(e, i.key);
    }).next(() => {
      this.br = r;
    });
  }
  On(e) {
  }
  containsKey(e, n) {
    const r = new Bt(n, 0), i = this.br.firstAfterOrEqual(r);
    return W.resolve(n.isEqual(i && i.key));
  }
  performConsistencyCheck(e) {
    return this.mutationQueue.length, W.resolve();
  }
  /**
   * Finds the index of the given batchId in the mutation queue and asserts that
   * the resulting index is within the bounds of the queue.
   *
   * @param batchId - The batchId to search for
   * @param action - A description of what the caller is doing, phrased in passive
   * form (e.g. "acknowledged" in a routine that acknowledges batches).
   */
  Fr(e, n) {
    return this.vr(e);
  }
  /**
   * Finds the index of the given batchId in the mutation queue. This operation
   * is O(1).
   *
   * @returns The computed index of the batch with the given batchId, based on
   * the state of the queue. Note this index can be negative if the requested
   * batchId has already been removed from the queue or past the end of the
   * queue if the batchId is larger than the last added batch.
   */
  vr(e) {
    return this.mutationQueue.length === 0 ? 0 : e - this.mutationQueue[0].batchId;
  }
  /**
   * A version of lookupMutationBatch that doesn't return a promise, this makes
   * other functions that uses this code easier to read and more efficient.
   */
  Dr(e) {
    const n = this.vr(e);
    return n < 0 || n >= this.mutationQueue.length ? null : this.mutationQueue[n];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jO {
  /**
   * @param sizer - Used to assess the size of a document. For eager GC, this is
   * expected to just return 0 to avoid unnecessarily doing the work of
   * calculating the size.
   */
  constructor(e) {
    this.Mr = e, /** Underlying cache of documents and their read times. */
    this.docs = function() {
      return new Tt(ve.comparator);
    }(), /** Size of all cached documents. */
    this.size = 0;
  }
  setIndexManager(e) {
    this.indexManager = e;
  }
  /**
   * Adds the supplied entry to the cache and updates the cache size as appropriate.
   *
   * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer
   * returned by `newChangeBuffer()`.
   */
  addEntry(e, n) {
    const r = n.key, i = this.docs.get(r), s = i ? i.size : 0, o = this.Mr(n);
    return this.docs = this.docs.insert(r, {
      document: n.mutableCopy(),
      size: o
    }), this.size += o - s, this.indexManager.addToCollectionParentIndex(e, r.path.popLast());
  }
  /**
   * Removes the specified entry from the cache and updates the cache size as appropriate.
   *
   * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer
   * returned by `newChangeBuffer()`.
   */
  removeEntry(e) {
    const n = this.docs.get(e);
    n && (this.docs = this.docs.remove(e), this.size -= n.size);
  }
  getEntry(e, n) {
    const r = this.docs.get(n);
    return W.resolve(r ? r.document.mutableCopy() : an.newInvalidDocument(n));
  }
  getEntries(e, n) {
    let r = Xr();
    return n.forEach((i) => {
      const s = this.docs.get(i);
      r = r.insert(i, s ? s.document.mutableCopy() : an.newInvalidDocument(i));
    }), W.resolve(r);
  }
  getDocumentsMatchingQuery(e, n, r, i) {
    let s = Xr();
    const o = n.path, a = new ve(o.child("")), l = this.docs.getIteratorFrom(a);
    for (; l.hasNext(); ) {
      const { key: u, value: { document: d } } = l.getNext();
      if (!o.isPrefixOf(u.path)) break;
      u.path.length > o.length + 1 || SN(IN(d), r) <= 0 || (i.has(d.key) || El(n, d)) && (s = s.insert(d.key, d.mutableCopy()));
    }
    return W.resolve(s);
  }
  getAllFromCollectionGroup(e, n, r, i) {
    Ne();
  }
  Or(e, n) {
    return W.forEach(this.docs, (r) => n(r));
  }
  newChangeBuffer(e) {
    return new qO(this);
  }
  getSize(e) {
    return W.resolve(this.size);
  }
}
class qO extends DO {
  constructor(e) {
    super(), this.cr = e;
  }
  applyChanges(e) {
    const n = [];
    return this.changes.forEach((r, i) => {
      i.isValidDocument() ? n.push(this.cr.addEntry(e, i)) : this.cr.removeEntry(r);
    }), W.waitFor(n);
  }
  getFromCache(e, n) {
    return this.cr.getEntry(e, n);
  }
  getAllFromCache(e, n) {
    return this.cr.getEntries(e, n);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zO {
  constructor(e) {
    this.persistence = e, /**
    * Maps a target to the data about that target
    */
    this.Nr = new uo((n) => ph(n), mh), /** The last received snapshot version. */
    this.lastRemoteSnapshotVersion = Pe.min(), /** The highest numbered target ID encountered. */
    this.highestTargetId = 0, /** The highest sequence number encountered. */
    this.Lr = 0, /**
    * A ordered bidirectional mapping between documents and the remote target
    * IDs.
    */
    this.Br = new wh(), this.targetCount = 0, this.kr = Zs.Bn();
  }
  forEachTarget(e, n) {
    return this.Nr.forEach((r, i) => n(i)), W.resolve();
  }
  getLastRemoteSnapshotVersion(e) {
    return W.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(e) {
    return W.resolve(this.Lr);
  }
  allocateTargetId(e) {
    return this.highestTargetId = this.kr.next(), W.resolve(this.highestTargetId);
  }
  setTargetsMetadata(e, n, r) {
    return r && (this.lastRemoteSnapshotVersion = r), n > this.Lr && (this.Lr = n), W.resolve();
  }
  Kn(e) {
    this.Nr.set(e.target, e);
    const n = e.targetId;
    n > this.highestTargetId && (this.kr = new Zs(n), this.highestTargetId = n), e.sequenceNumber > this.Lr && (this.Lr = e.sequenceNumber);
  }
  addTargetData(e, n) {
    return this.Kn(n), this.targetCount += 1, W.resolve();
  }
  updateTargetData(e, n) {
    return this.Kn(n), W.resolve();
  }
  removeTargetData(e, n) {
    return this.Nr.delete(n.target), this.Br.gr(n.targetId), this.targetCount -= 1, W.resolve();
  }
  removeTargets(e, n, r) {
    let i = 0;
    const s = [];
    return this.Nr.forEach((o, a) => {
      a.sequenceNumber <= n && r.get(a.targetId) === null && (this.Nr.delete(o), s.push(this.removeMatchingKeysForTargetId(e, a.targetId)), i++);
    }), W.waitFor(s).next(() => i);
  }
  getTargetCount(e) {
    return W.resolve(this.targetCount);
  }
  getTargetData(e, n) {
    const r = this.Nr.get(n) || null;
    return W.resolve(r);
  }
  addMatchingKeys(e, n, r) {
    return this.Br.Rr(n, r), W.resolve();
  }
  removeMatchingKeys(e, n, r) {
    this.Br.mr(n, r);
    const i = this.persistence.referenceDelegate, s = [];
    return i && n.forEach((o) => {
      s.push(i.markPotentiallyOrphaned(e, o));
    }), W.waitFor(s);
  }
  removeMatchingKeysForTargetId(e, n) {
    return this.Br.gr(n), W.resolve();
  }
  getMatchingKeysForTargetId(e, n) {
    const r = this.Br.yr(n);
    return W.resolve(r);
  }
  containsKey(e, n) {
    return W.resolve(this.Br.containsKey(n));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WO {
  /**
   * The constructor accepts a factory for creating a reference delegate. This
   * allows both the delegate and this instance to have strong references to
   * each other without having nullable fields that would then need to be
   * checked or asserted on every access.
   */
  constructor(e, n) {
    this.qr = {}, this.overlays = {}, this.Qr = new dh(0), this.Kr = !1, this.Kr = !0, this.$r = new BO(), this.referenceDelegate = e(this), this.Ur = new zO(this), this.indexManager = new xO(), this.remoteDocumentCache = function(i) {
      return new jO(i);
    }((r) => this.referenceDelegate.Wr(r)), this.serializer = new OO(n), this.Gr = new FO(this.serializer);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Kr = !1, Promise.resolve();
  }
  get started() {
    return this.Kr;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(e) {
    return this.indexManager;
  }
  getDocumentOverlayCache(e) {
    let n = this.overlays[e.toKey()];
    return n || (n = new VO(), this.overlays[e.toKey()] = n), n;
  }
  getMutationQueue(e, n) {
    let r = this.qr[e.toKey()];
    return r || (r = new $O(n, this.referenceDelegate), this.qr[e.toKey()] = r), r;
  }
  getGlobalsCache() {
    return this.$r;
  }
  getTargetCache() {
    return this.Ur;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.Gr;
  }
  runTransaction(e, n, r) {
    fe("MemoryPersistence", "Starting transaction:", e);
    const i = new GO(this.Qr.next());
    return this.referenceDelegate.zr(), r(i).next((s) => this.referenceDelegate.jr(i).next(() => s)).toPromise().then((s) => (i.raiseOnCommittedEvent(), s));
  }
  Hr(e, n) {
    return W.or(Object.values(this.qr).map((r) => () => r.containsKey(e, n)));
  }
}
class GO extends RN {
  constructor(e) {
    super(), this.currentSequenceNumber = e;
  }
}
class Th {
  constructor(e) {
    this.persistence = e, /** Tracks all documents that are active in Query views. */
    this.Jr = new wh(), /** The list of documents that are potentially GCed after each transaction. */
    this.Yr = null;
  }
  static Zr(e) {
    return new Th(e);
  }
  get Xr() {
    if (this.Yr) return this.Yr;
    throw Ne();
  }
  addReference(e, n, r) {
    return this.Jr.addReference(r, n), this.Xr.delete(r.toString()), W.resolve();
  }
  removeReference(e, n, r) {
    return this.Jr.removeReference(r, n), this.Xr.add(r.toString()), W.resolve();
  }
  markPotentiallyOrphaned(e, n) {
    return this.Xr.add(n.toString()), W.resolve();
  }
  removeTarget(e, n) {
    this.Jr.gr(n.targetId).forEach((i) => this.Xr.add(i.toString()));
    const r = this.persistence.getTargetCache();
    return r.getMatchingKeysForTargetId(e, n.targetId).next((i) => {
      i.forEach((s) => this.Xr.add(s.toString()));
    }).next(() => r.removeTargetData(e, n));
  }
  zr() {
    this.Yr = /* @__PURE__ */ new Set();
  }
  jr(e) {
    const n = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return W.forEach(this.Xr, (r) => {
      const i = ve.fromPath(r);
      return this.ei(e, i).next((s) => {
        s || n.removeEntry(i, Pe.min());
      });
    }).next(() => (this.Yr = null, n.apply(e)));
  }
  updateLimboDocument(e, n) {
    return this.ei(e, n).next((r) => {
      r ? this.Xr.delete(n.toString()) : this.Xr.add(n.toString());
    });
  }
  Wr(e) {
    return 0;
  }
  ei(e, n) {
    return W.or([() => W.resolve(this.Jr.containsKey(n)), () => this.persistence.getTargetCache().containsKey(e, n), () => this.persistence.Hr(e, n)]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ih {
  constructor(e, n, r, i) {
    this.targetId = e, this.fromCache = n, this.$i = r, this.Ui = i;
  }
  static Wi(e, n) {
    let r = qe(), i = qe();
    for (const s of n.docChanges) switch (s.type) {
      case 0:
        r = r.add(s.doc.key);
        break;
      case 1:
        i = i.add(s.doc.key);
    }
    return new Ih(e, n.fromCache, r, i);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HO {
  constructor() {
    this._documentReadCount = 0;
  }
  get documentReadCount() {
    return this._documentReadCount;
  }
  incrementDocumentReadCount(e) {
    this._documentReadCount += e;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class KO {
  constructor() {
    this.Gi = !1, this.zi = !1, /**
    * SDK only decides whether it should create index when collection size is
    * larger than this.
    */
    this.ji = 100, this.Hi = /**
    * This cost represents the evaluation result of
    * (([index, docKey] + [docKey, docContent]) per document in the result set)
    * / ([docKey, docContent] per documents in full collection scan) coming from
    * experiment [enter PR experiment URL here].
    */
    function() {
      return RA() ? 8 : CN(cn()) > 0 ? 6 : 4;
    }();
  }
  /** Sets the document view to query against. */
  initialize(e, n) {
    this.Ji = e, this.indexManager = n, this.Gi = !0;
  }
  /** Returns all local documents matching the specified query. */
  getDocumentsMatchingQuery(e, n, r, i) {
    const s = {
      result: null
    };
    return this.Yi(e, n).next((o) => {
      s.result = o;
    }).next(() => {
      if (!s.result) return this.Zi(e, n, i, r).next((o) => {
        s.result = o;
      });
    }).next(() => {
      if (s.result) return;
      const o = new HO();
      return this.Xi(e, n, o).next((a) => {
        if (s.result = a, this.zi) return this.es(e, n, o, a.size);
      });
    }).next(() => s.result);
  }
  es(e, n, r, i) {
    return r.documentReadCount < this.ji ? (Ao() <= ze.DEBUG && fe("QueryEngine", "SDK will not create cache indexes for query:", ws(n), "since it only creates cache indexes for collection contains", "more than or equal to", this.ji, "documents"), W.resolve()) : (Ao() <= ze.DEBUG && fe("QueryEngine", "Query:", ws(n), "scans", r.documentReadCount, "local documents and returns", i, "documents as results."), r.documentReadCount > this.Hi * i ? (Ao() <= ze.DEBUG && fe("QueryEngine", "The SDK decides to create cache indexes for query:", ws(n), "as using cache indexes may help improve performance."), this.indexManager.createTargetIndexes(e, yr(n))) : W.resolve());
  }
  /**
   * Performs an indexed query that evaluates the query based on a collection's
   * persisted index values. Returns `null` if an index is not available.
   */
  Yi(e, n) {
    if (Ug(n))
      return W.resolve(null);
    let r = yr(n);
    return this.indexManager.getIndexType(e, r).next((i) => i === 0 ? null : (n.limit !== null && i === 1 && // We cannot apply a limit for targets that are served using a partial
    // index. If a partial index will be used to serve the target, the
    // query may return a superset of documents that match the target
    // (e.g. if the index doesn't include all the target's filters), or
    // may return the correct set of documents in the wrong order (e.g. if
    // the index doesn't include a segment for one of the orderBys).
    // Therefore, a limit should not be applied in such cases.
    (n = Bc(
      n,
      null,
      "F"
      /* LimitType.First */
    ), r = yr(n)), this.indexManager.getDocumentsMatchingTarget(e, r).next((s) => {
      const o = qe(...s);
      return this.Ji.getDocuments(e, o).next((a) => this.indexManager.getMinOffset(e, r).next((l) => {
        const u = this.ts(n, a);
        return this.ns(n, u, o, l.readTime) ? this.Yi(e, Bc(
          n,
          null,
          "F"
          /* LimitType.First */
        )) : this.rs(e, u, n, l);
      }));
    })));
  }
  /**
   * Performs a query based on the target's persisted query mapping. Returns
   * `null` if the mapping is not available or cannot be used.
   */
  Zi(e, n, r, i) {
    return Ug(n) || i.isEqual(Pe.min()) ? W.resolve(null) : this.Ji.getDocuments(e, r).next((s) => {
      const o = this.ts(n, s);
      return this.ns(n, o, r, i) ? W.resolve(null) : (Ao() <= ze.DEBUG && fe("QueryEngine", "Re-using previous result from %s to execute query: %s", i.toString(), ws(n)), this.rs(e, o, n, TN(i, -1)).next((a) => a));
    });
  }
  /** Applies the query filter and sorting to the provided documents.  */
  ts(e, n) {
    let r = new Kt(EE(e));
    return n.forEach((i, s) => {
      El(e, s) && (r = r.add(s));
    }), r;
  }
  /**
   * Determines if a limit query needs to be refilled from cache, making it
   * ineligible for index-free execution.
   *
   * @param query - The query.
   * @param sortedPreviousResults - The documents that matched the query when it
   * was last synchronized, sorted by the query's comparator.
   * @param remoteKeys - The document keys that matched the query at the last
   * snapshot.
   * @param limboFreeSnapshotVersion - The version of the snapshot when the
   * query was last synchronized.
   */
  ns(e, n, r, i) {
    if (e.limit === null)
      return !1;
    if (r.size !== n.size)
      return !0;
    const s = e.limitType === "F" ? n.last() : n.first();
    return !!s && (s.hasPendingWrites || s.version.compareTo(i) > 0);
  }
  Xi(e, n, r) {
    return Ao() <= ze.DEBUG && fe("QueryEngine", "Using full collection scan to execute query:", ws(n)), this.Ji.getDocumentsMatchingQuery(e, n, Ei.min(), r);
  }
  /**
   * Combines the results from an indexed execution with the remaining documents
   * that have not yet been indexed.
   */
  rs(e, n, r, i) {
    return this.Ji.getDocumentsMatchingQuery(e, r, i).next((s) => (
      // Merge with existing results
      (n.forEach((o) => {
        s = s.insert(o.key, o);
      }), s)
    ));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class YO {
  constructor(e, n, r, i) {
    this.persistence = e, this.ss = n, this.serializer = i, /**
    * Maps a targetID to data about its target.
    *
    * PORTING NOTE: We are using an immutable data structure on Web to make re-runs
    * of `applyRemoteEvent()` idempotent.
    */
    this.os = new Tt(Xe), /** Maps a target to its targetID. */
    // TODO(wuandy): Evaluate if TargetId can be part of Target.
    this._s = new uo((s) => ph(s), mh), /**
    * A per collection group index of the last read time processed by
    * `getNewDocumentChanges()`.
    *
    * PORTING NOTE: This is only used for multi-tab synchronization.
    */
    this.us = /* @__PURE__ */ new Map(), this.cs = e.getRemoteDocumentCache(), this.Ur = e.getTargetCache(), this.Gr = e.getBundleCache(), this.ls(r);
  }
  ls(e) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e), this.indexManager = this.persistence.getIndexManager(e), this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager), this.localDocuments = new UO(this.cs, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.cs.setIndexManager(this.indexManager), this.ss.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(e) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (n) => e.collect(n, this.os));
  }
}
function XO(t, e, n, r) {
  return new YO(t, e, n, r);
}
async function jE(t, e) {
  const n = xe(t);
  return await n.persistence.runTransaction("Handle user change", "readonly", (r) => {
    let i;
    return n.mutationQueue.getAllMutationBatches(r).next((s) => (i = s, n.ls(e), n.mutationQueue.getAllMutationBatches(r))).next((s) => {
      const o = [], a = [];
      let l = qe();
      for (const u of i) {
        o.push(u.batchId);
        for (const d of u.mutations) l = l.add(d.key);
      }
      for (const u of s) {
        a.push(u.batchId);
        for (const d of u.mutations) l = l.add(d.key);
      }
      return n.localDocuments.getDocuments(r, l).next((u) => ({
        hs: u,
        removedBatchIds: o,
        addedBatchIds: a
      }));
    });
  });
}
function QO(t, e) {
  const n = xe(t);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (r) => {
    const i = e.batch.keys(), s = n.cs.newChangeBuffer({
      trackRemovals: !0
    });
    return function(a, l, u, d) {
      const f = u.batch, p = f.keys();
      let g = W.resolve();
      return p.forEach((_) => {
        g = g.next(() => d.getEntry(l, _)).next((b) => {
          const m = u.docVersions.get(_);
          it(m !== null), b.version.compareTo(m) < 0 && (f.applyToRemoteDocument(b, u), b.isValidDocument() && // We use the commitVersion as the readTime rather than the
          // document's updateTime since the updateTime is not advanced
          // for updates that do not modify the underlying document.
          (b.setReadTime(u.commitVersion), d.addEntry(b)));
        });
      }), g.next(() => a.mutationQueue.removeMutationBatch(l, f));
    }(n, r, e, s).next(() => s.apply(r)).next(() => n.mutationQueue.performConsistencyCheck(r)).next(() => n.documentOverlayCache.removeOverlaysForBatchId(r, i, e.batch.batchId)).next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(r, function(a) {
      let l = qe();
      for (let u = 0; u < a.mutationResults.length; ++u)
        a.mutationResults[u].transformResults.length > 0 && (l = l.add(a.batch.mutations[u].key));
      return l;
    }(e))).next(() => n.localDocuments.getDocuments(r, i));
  });
}
function qE(t) {
  const e = xe(t);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (n) => e.Ur.getLastRemoteSnapshotVersion(n));
}
function JO(t, e) {
  const n = xe(t), r = e.snapshotVersion;
  let i = n.os;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (s) => {
    const o = n.cs.newChangeBuffer({
      trackRemovals: !0
    });
    i = n.os;
    const a = [];
    e.targetChanges.forEach((d, f) => {
      const p = i.get(f);
      if (!p) return;
      a.push(n.Ur.removeMatchingKeys(s, d.removedDocuments, f).next(() => n.Ur.addMatchingKeys(s, d.addedDocuments, f)));
      let g = p.withSequenceNumber(s.currentSequenceNumber);
      e.targetMismatches.get(f) !== null ? g = g.withResumeToken(Qt.EMPTY_BYTE_STRING, Pe.min()).withLastLimboFreeSnapshotVersion(Pe.min()) : d.resumeToken.approximateByteSize() > 0 && (g = g.withResumeToken(d.resumeToken, r)), i = i.insert(f, g), // Update the target data if there are target changes (or if
      // sufficient time has passed since the last update).
      /**
      * Returns true if the newTargetData should be persisted during an update of
      * an active target. TargetData should always be persisted when a target is
      * being released and should not call this function.
      *
      * While the target is active, TargetData updates can be omitted when nothing
      * about the target has changed except metadata like the resume token or
      * snapshot version. Occasionally it's worth the extra write to prevent these
      * values from getting too stale after a crash, but this doesn't have to be
      * too frequent.
      */
      function(b, m, v) {
        return b.resumeToken.approximateByteSize() === 0 || m.snapshotVersion.toMicroseconds() - b.snapshotVersion.toMicroseconds() >= 3e8 ? !0 : v.addedDocuments.size + v.modifiedDocuments.size + v.removedDocuments.size > 0;
      }(p, g, d) && a.push(n.Ur.updateTargetData(s, g));
    });
    let l = Xr(), u = qe();
    if (e.documentUpdates.forEach((d) => {
      e.resolvedLimboDocuments.has(d) && a.push(n.persistence.referenceDelegate.updateLimboDocument(s, d));
    }), // Each loop iteration only affects its "own" doc, so it's safe to get all
    // the remote documents in advance in a single call.
    a.push(ZO(s, o, e.documentUpdates).next((d) => {
      l = d.Ps, u = d.Is;
    })), !r.isEqual(Pe.min())) {
      const d = n.Ur.getLastRemoteSnapshotVersion(s).next((f) => n.Ur.setTargetsMetadata(s, s.currentSequenceNumber, r));
      a.push(d);
    }
    return W.waitFor(a).next(() => o.apply(s)).next(() => n.localDocuments.getLocalViewOfDocuments(s, l, u)).next(() => l);
  }).then((s) => (n.os = i, s));
}
function ZO(t, e, n) {
  let r = qe(), i = qe();
  return n.forEach((s) => r = r.add(s)), e.getEntries(t, r).next((s) => {
    let o = Xr();
    return n.forEach((a, l) => {
      const u = s.get(a);
      l.isFoundDocument() !== u.isFoundDocument() && (i = i.add(a)), // Note: The order of the steps below is important, since we want
      // to ensure that rejected limbo resolutions (which fabricate
      // NoDocuments with SnapshotVersion.min()) never add documents to
      // cache.
      l.isNoDocument() && l.version.isEqual(Pe.min()) ? (
        // NoDocuments with SnapshotVersion.min() are used in manufactured
        // events. We remove these documents from cache since we lost
        // access.
        (e.removeEntry(a, l.readTime), o = o.insert(a, l))
      ) : !u.isValidDocument() || l.version.compareTo(u.version) > 0 || l.version.compareTo(u.version) === 0 && u.hasPendingWrites ? (e.addEntry(l), o = o.insert(a, l)) : fe("LocalStore", "Ignoring outdated watch update for ", a, ". Current version:", u.version, " Watch version:", l.version);
    }), {
      Ps: o,
      Is: i
    };
  });
}
function eP(t, e) {
  const n = xe(t);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (r) => (e === void 0 && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(r, e)));
}
function tP(t, e) {
  const n = xe(t);
  return n.persistence.runTransaction("Allocate target", "readwrite", (r) => {
    let i;
    return n.Ur.getTargetData(r, e).next((s) => s ? (
      // This target has been listened to previously, so reuse the
      // previous targetID.
      // TODO(mcg): freshen last accessed date?
      (i = s, W.resolve(i))
    ) : n.Ur.allocateTargetId(r).next((o) => (i = new pi(e, o, "TargetPurposeListen", r.currentSequenceNumber), n.Ur.addTargetData(r, i).next(() => i))));
  }).then((r) => {
    const i = n.os.get(r.targetId);
    return (i === null || r.snapshotVersion.compareTo(i.snapshotVersion) > 0) && (n.os = n.os.insert(r.targetId, r), n._s.set(e, r.targetId)), r;
  });
}
async function Qd(t, e, n) {
  const r = xe(t), i = r.os.get(e), s = n ? "readwrite" : "readwrite-primary";
  try {
    n || await r.persistence.runTransaction("Release target", s, (o) => r.persistence.referenceDelegate.removeTarget(o, i));
  } catch (o) {
    if (!va(o)) throw o;
    fe("LocalStore", `Failed to update sequence numbers for target ${e}: ${o}`);
  }
  r.os = r.os.remove(e), r._s.delete(i.target);
}
function Kg(t, e, n) {
  const r = xe(t);
  let i = Pe.min(), s = qe();
  return r.persistence.runTransaction(
    "Execute query",
    "readwrite",
    // Use readwrite instead of readonly so indexes can be created
    // Use readwrite instead of readonly so indexes can be created
    (o) => function(l, u, d) {
      const f = xe(l), p = f._s.get(d);
      return p !== void 0 ? W.resolve(f.os.get(p)) : f.Ur.getTargetData(u, d);
    }(r, o, yr(e)).next((a) => {
      if (a) return i = a.lastLimboFreeSnapshotVersion, r.Ur.getMatchingKeysForTargetId(o, a.targetId).next((l) => {
        s = l;
      });
    }).next(() => r.ss.getDocumentsMatchingQuery(o, e, n ? i : Pe.min(), n ? s : qe())).next((a) => (nP(r, GN(e), a), {
      documents: a,
      Ts: s
    }))
  );
}
function nP(t, e, n) {
  let r = t.us.get(e) || Pe.min();
  n.forEach((i, s) => {
    s.readTime.compareTo(r) > 0 && (r = s.readTime);
  }), t.us.set(e, r);
}
class Yg {
  constructor() {
    this.activeTargetIds = JN();
  }
  fs(e) {
    this.activeTargetIds = this.activeTargetIds.add(e);
  }
  gs(e) {
    this.activeTargetIds = this.activeTargetIds.delete(e);
  }
  /**
   * Converts this entry into a JSON-encoded format we can use for WebStorage.
   * Does not encode `clientId` as it is part of the key in WebStorage.
   */
  Vs() {
    const e = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(e);
  }
}
class rP {
  constructor() {
    this.so = new Yg(), this.oo = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(e) {
  }
  updateMutationState(e, n, r) {
  }
  addLocalQueryTarget(e, n = !0) {
    return n && this.so.fs(e), this.oo[e] || "not-current";
  }
  updateQueryState(e, n, r) {
    this.oo[e] = n;
  }
  removeLocalQueryTarget(e) {
    this.so.gs(e);
  }
  isLocalQueryTarget(e) {
    return this.so.activeTargetIds.has(e);
  }
  clearQueryState(e) {
    delete this.oo[e];
  }
  getAllActiveQueryTargets() {
    return this.so.activeTargetIds;
  }
  isActiveQueryTarget(e) {
    return this.so.activeTargetIds.has(e);
  }
  start() {
    return this.so = new Yg(), Promise.resolve();
  }
  handleUserChange(e, n, r) {
  }
  setOnlineState(e) {
  }
  shutdown() {
  }
  writeSequenceNumber(e) {
  }
  notifyBundleLoaded(e) {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class iP {
  _o(e) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xg {
  constructor() {
    this.ao = () => this.uo(), this.co = () => this.lo(), this.ho = [], this.Po();
  }
  _o(e) {
    this.ho.push(e);
  }
  shutdown() {
    window.removeEventListener("online", this.ao), window.removeEventListener("offline", this.co);
  }
  Po() {
    window.addEventListener("online", this.ao), window.addEventListener("offline", this.co);
  }
  uo() {
    fe("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const e of this.ho) e(
      0
      /* NetworkStatus.AVAILABLE */
    );
  }
  lo() {
    fe("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const e of this.ho) e(
      1
      /* NetworkStatus.UNAVAILABLE */
    );
  }
  // TODO(chenbrian): Consider passing in window either into this component or
  // here for testing via FakeWindow.
  /** Checks that all used attributes of window are available. */
  static D() {
    return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Za = null;
function gu() {
  return Za === null ? Za = function() {
    return 268435456 + Math.round(2147483648 * Math.random());
  }() : Za++, "0x" + Za.toString(16);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sP = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oP {
  constructor(e) {
    this.Io = e.Io, this.To = e.To;
  }
  Eo(e) {
    this.Ao = e;
  }
  Ro(e) {
    this.Vo = e;
  }
  mo(e) {
    this.fo = e;
  }
  onMessage(e) {
    this.po = e;
  }
  close() {
    this.To();
  }
  send(e) {
    this.Io(e);
  }
  yo() {
    this.Ao();
  }
  wo() {
    this.Vo();
  }
  So(e) {
    this.fo(e);
  }
  bo(e) {
    this.po(e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sn = "WebChannelConnection";
class aP extends /**
* Base class for all Rest-based connections to the backend (WebChannel and
* HTTP).
*/
class {
  constructor(n) {
    this.databaseInfo = n, this.databaseId = n.databaseId;
    const r = n.ssl ? "https" : "http", i = encodeURIComponent(this.databaseId.projectId), s = encodeURIComponent(this.databaseId.database);
    this.Do = r + "://" + n.host, this.vo = `projects/${i}/databases/${s}`, this.Co = this.databaseId.database === "(default)" ? `project_id=${i}` : `project_id=${i}&database_id=${s}`;
  }
  get Fo() {
    return !1;
  }
  Mo(n, r, i, s, o) {
    const a = gu(), l = this.xo(n, r.toUriEncodedString());
    fe("RestConnection", `Sending RPC '${n}' ${a}:`, l, i);
    const u = {
      "google-cloud-resource-prefix": this.vo,
      "x-goog-request-params": this.Co
    };
    return this.Oo(u, s, o), this.No(n, l, u, i).then((d) => (fe("RestConnection", `Received RPC '${n}' ${a}: `, d), d), (d) => {
      throw Ks("RestConnection", `RPC '${n}' ${a} failed with error: `, d, "url: ", l, "request:", i), d;
    });
  }
  Lo(n, r, i, s, o, a) {
    return this.Mo(n, r, i, s, o);
  }
  /**
   * Modifies the headers for a request, adding any authorization token if
   * present and any additional headers for the request.
   */
  Oo(n, r, i) {
    n["X-Goog-Api-Client"] = // SDK_VERSION is updated to different value at runtime depending on the entry point,
    // so we need to get its value when we need it in a function.
    function() {
      return "gl-js/ fire/" + co;
    }(), // Content-Type: text/plain will avoid preflight requests which might
    // mess with CORS and redirects by proxies. If we add custom headers
    // we will need to change this code to potentially use the $httpOverwrite
    // parameter supported by ESF to avoid triggering preflight requests.
    n["Content-Type"] = "text/plain", this.databaseInfo.appId && (n["X-Firebase-GMPID"] = this.databaseInfo.appId), r && r.headers.forEach((s, o) => n[o] = s), i && i.headers.forEach((s, o) => n[o] = s);
  }
  xo(n, r) {
    const i = sP[n];
    return `${this.Do}/v1/${r}:${i}`;
  }
  /**
   * Closes and cleans up any resources associated with the connection. This
   * implementation is a no-op because there are no resources associated
   * with the RestConnection that need to be cleaned up.
   */
  terminate() {
  }
} {
  constructor(e) {
    super(e), this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams, this.longPollingOptions = e.longPollingOptions;
  }
  No(e, n, r, i) {
    const s = gu();
    return new Promise((o, a) => {
      const l = new iE();
      l.setWithCredentials(!0), l.listenOnce(sE.COMPLETE, () => {
        try {
          switch (l.getLastErrorCode()) {
            case mc.NO_ERROR:
              const d = l.getResponseJson();
              fe(sn, `XHR for RPC '${e}' ${s} received:`, JSON.stringify(d)), o(d);
              break;
            case mc.TIMEOUT:
              fe(sn, `RPC '${e}' ${s} timed out`), a(new ne(j.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case mc.HTTP_ERROR:
              const f = l.getStatus();
              if (fe(sn, `RPC '${e}' ${s} failed with status:`, f, "response text:", l.getResponseText()), f > 0) {
                let p = l.getResponseJson();
                Array.isArray(p) && (p = p[0]);
                const g = p == null ? void 0 : p.error;
                if (g && g.status && g.message) {
                  const _ = function(m) {
                    const v = m.toLowerCase().replace(/_/g, "-");
                    return Object.values(j).indexOf(v) >= 0 ? v : j.UNKNOWN;
                  }(g.status);
                  a(new ne(_, g.message));
                } else a(new ne(j.UNKNOWN, "Server responded with status " + l.getStatus()));
              } else
                a(new ne(j.UNAVAILABLE, "Connection failed."));
              break;
            default:
              Ne();
          }
        } finally {
          fe(sn, `RPC '${e}' ${s} completed.`);
        }
      });
      const u = JSON.stringify(i);
      fe(sn, `RPC '${e}' ${s} sending request:`, i), l.send(n, "POST", u, r, 15);
    });
  }
  Bo(e, n, r) {
    const i = gu(), s = [this.Do, "/", "google.firestore.v1.Firestore", "/", e, "/channel"], o = cE(), a = aE(), l = {
      // Required for backend stickiness, routing behavior is based on this
      // parameter.
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        // This param is used to improve routing and project isolation by the
        // backend and must be included in every request.
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: !0,
      supportsCrossDomainXhr: !0,
      internalChannelParams: {
        // Override the default timeout (randomized between 10-20 seconds) since
        // a large write batch on a slow internet connection may take a long
        // time to send to the backend. Rather than have WebChannel impose a
        // tight timeout which could lead to infinite timeouts and retries, we
        // set it very large (5-10 minutes) and rely on the browser's builtin
        // timeouts to kick in if the request isn't working.
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    }, u = this.longPollingOptions.timeoutSeconds;
    u !== void 0 && (l.longPollingTimeout = Math.round(1e3 * u)), this.useFetchStreams && (l.useFetchStreams = !0), this.Oo(l.initMessageHeaders, n, r), // Sending the custom headers we just added to request.initMessageHeaders
    // (Authorization, etc.) will trigger the browser to make a CORS preflight
    // request because the XHR will no longer meet the criteria for a "simple"
    // CORS request:
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests
    // Therefore to avoid the CORS preflight request (an extra network
    // roundtrip), we use the encodeInitMessageHeaders option to specify that
    // the headers should instead be encoded in the request's POST payload,
    // which is recognized by the webchannel backend.
    l.encodeInitMessageHeaders = !0;
    const d = s.join("");
    fe(sn, `Creating RPC '${e}' stream ${i}: ${d}`, l);
    const f = o.createWebChannel(d, l);
    let p = !1, g = !1;
    const _ = new oP({
      Io: (m) => {
        g ? fe(sn, `Not sending because RPC '${e}' stream ${i} is closed:`, m) : (p || (fe(sn, `Opening RPC '${e}' stream ${i} transport.`), f.open(), p = !0), fe(sn, `RPC '${e}' stream ${i} sending:`, m), f.send(m));
      },
      To: () => f.close()
    }), b = (m, v, C) => {
      m.listen(v, (x) => {
        try {
          C(x);
        } catch (P) {
          setTimeout(() => {
            throw P;
          }, 0);
        }
      });
    };
    return b(f, xo.EventType.OPEN, () => {
      g || (fe(sn, `RPC '${e}' stream ${i} transport opened.`), _.yo());
    }), b(f, xo.EventType.CLOSE, () => {
      g || (g = !0, fe(sn, `RPC '${e}' stream ${i} transport closed`), _.So());
    }), b(f, xo.EventType.ERROR, (m) => {
      g || (g = !0, Ks(sn, `RPC '${e}' stream ${i} transport errored:`, m), _.So(new ne(j.UNAVAILABLE, "The operation could not be completed")));
    }), b(f, xo.EventType.MESSAGE, (m) => {
      var v;
      if (!g) {
        const C = m.data[0];
        it(!!C);
        const x = C, P = x.error || ((v = x[0]) === null || v === void 0 ? void 0 : v.error);
        if (P) {
          fe(sn, `RPC '${e}' stream ${i} received error:`, P);
          const k = P.status;
          let U = (
            /**
            * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.
            *
            * @returns The Code equivalent to the given status string or undefined if
            *     there is no match.
            */
            function(T) {
              const A = Dt[T];
              if (A !== void 0) return PE(A);
            }(k)
          ), I = P.message;
          U === void 0 && (U = j.INTERNAL, I = "Unknown error status: " + k + " with message " + P.message), // Mark closed so no further events are propagated
          g = !0, _.So(new ne(U, I)), f.close();
        } else fe(sn, `RPC '${e}' stream ${i} received:`, C), _.bo(C);
      }
    }), b(a, oE.STAT_EVENT, (m) => {
      m.stat === $d.PROXY ? fe(sn, `RPC '${e}' stream ${i} detected buffering proxy`) : m.stat === $d.NOPROXY && fe(sn, `RPC '${e}' stream ${i} detected no buffering proxy`);
    }), setTimeout(() => {
      _.wo();
    }, 0), _;
  }
}
function yu() {
  return typeof document < "u" ? document : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Sl(t) {
  return new yO(
    t,
    /* useProto3Json= */
    !0
  );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zE {
  constructor(e, n, r = 1e3, i = 1.5, s = 6e4) {
    this.ui = e, this.timerId = n, this.ko = r, this.qo = i, this.Qo = s, this.Ko = 0, this.$o = null, /** The last backoff attempt, as epoch milliseconds. */
    this.Uo = Date.now(), this.reset();
  }
  /**
   * Resets the backoff delay.
   *
   * The very next backoffAndWait() will have no delay. If it is called again
   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
   * subsequent ones will increase according to the backoffFactor.
   */
  reset() {
    this.Ko = 0;
  }
  /**
   * Resets the backoff delay to the maximum delay (e.g. for use after a
   * RESOURCE_EXHAUSTED error).
   */
  Wo() {
    this.Ko = this.Qo;
  }
  /**
   * Returns a promise that resolves after currentDelayMs, and increases the
   * delay for any subsequent attempts. If there was a pending backoff operation
   * already, it will be canceled.
   */
  Go(e) {
    this.cancel();
    const n = Math.floor(this.Ko + this.zo()), r = Math.max(0, Date.now() - this.Uo), i = Math.max(0, n - r);
    i > 0 && fe("ExponentialBackoff", `Backing off for ${i} ms (base delay: ${this.Ko} ms, delay with jitter: ${n} ms, last attempt: ${r} ms ago)`), this.$o = this.ui.enqueueAfterDelay(this.timerId, i, () => (this.Uo = Date.now(), e())), // Apply backoff factor to determine next delay and ensure it is within
    // bounds.
    this.Ko *= this.qo, this.Ko < this.ko && (this.Ko = this.ko), this.Ko > this.Qo && (this.Ko = this.Qo);
  }
  jo() {
    this.$o !== null && (this.$o.skipDelay(), this.$o = null);
  }
  cancel() {
    this.$o !== null && (this.$o.cancel(), this.$o = null);
  }
  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
  zo() {
    return (Math.random() - 0.5) * this.Ko;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WE {
  constructor(e, n, r, i, s, o, a, l) {
    this.ui = e, this.Ho = r, this.Jo = i, this.connection = s, this.authCredentialsProvider = o, this.appCheckCredentialsProvider = a, this.listener = l, this.state = 0, /**
    * A close count that's incremented every time the stream is closed; used by
    * getCloseGuardedDispatcher() to invalidate callbacks that happen after
    * close.
    */
    this.Yo = 0, this.Zo = null, this.Xo = null, this.stream = null, /**
    * Count of response messages received.
    */
    this.e_ = 0, this.t_ = new zE(e, n);
  }
  /**
   * Returns true if start() has been called and no error has occurred. True
   * indicates the stream is open or in the process of opening (which
   * encompasses respecting backoff, getting auth tokens, and starting the
   * actual RPC). Use isOpen() to determine if the stream is open and ready for
   * outbound requests.
   */
  n_() {
    return this.state === 1 || this.state === 5 || this.r_();
  }
  /**
   * Returns true if the underlying RPC is open (the onOpen() listener has been
   * called) and the stream is ready for outbound requests.
   */
  r_() {
    return this.state === 2 || this.state === 3;
  }
  /**
   * Starts the RPC. Only allowed if isStarted() returns false. The stream is
   * not immediately ready for use: onOpen() will be invoked when the RPC is
   * ready for outbound requests, at which point isOpen() will return true.
   *
   * When start returns, isStarted() will return true.
   */
  start() {
    this.e_ = 0, this.state !== 4 ? this.auth() : this.i_();
  }
  /**
   * Stops the RPC. This call is idempotent and allowed regardless of the
   * current isStarted() state.
   *
   * When stop returns, isStarted() and isOpen() will both return false.
   */
  async stop() {
    this.n_() && await this.close(
      0
      /* PersistentStreamState.Initial */
    );
  }
  /**
   * After an error the stream will usually back off on the next attempt to
   * start it. If the error warrants an immediate restart of the stream, the
   * sender can use this to indicate that the receiver should not back off.
   *
   * Each error will call the onClose() listener. That function can decide to
   * inhibit backoff if required.
   */
  s_() {
    this.state = 0, this.t_.reset();
  }
  /**
   * Marks this stream as idle. If no further actions are performed on the
   * stream for one minute, the stream will automatically close itself and
   * notify the stream's onClose() handler with Status.OK. The stream will then
   * be in a !isStarted() state, requiring the caller to start the stream again
   * before further use.
   *
   * Only streams that are in state 'Open' can be marked idle, as all other
   * states imply pending network operations.
   */
  o_() {
    this.r_() && this.Zo === null && (this.Zo = this.ui.enqueueAfterDelay(this.Ho, 6e4, () => this.__()));
  }
  /** Sends a message to the underlying stream. */
  a_(e) {
    this.u_(), this.stream.send(e);
  }
  /** Called by the idle timer when the stream should close due to inactivity. */
  async __() {
    if (this.r_())
      return this.close(
        0
        /* PersistentStreamState.Initial */
      );
  }
  /** Marks the stream as active again. */
  u_() {
    this.Zo && (this.Zo.cancel(), this.Zo = null);
  }
  /** Cancels the health check delayed operation. */
  c_() {
    this.Xo && (this.Xo.cancel(), this.Xo = null);
  }
  /**
   * Closes the stream and cleans up as necessary:
   *
   * * closes the underlying GRPC stream;
   * * calls the onClose handler with the given 'error';
   * * sets internal stream state to 'finalState';
   * * adjusts the backoff timer based on the error
   *
   * A new stream can be opened by calling start().
   *
   * @param finalState - the intended state of the stream after closing.
   * @param error - the error the connection was closed with.
   */
  async close(e, n) {
    this.u_(), this.c_(), this.t_.cancel(), // Invalidates any stream-related callbacks (e.g. from auth or the
    // underlying stream), guaranteeing they won't execute.
    this.Yo++, e !== 4 ? (
      // If this is an intentional close ensure we don't delay our next connection attempt.
      this.t_.reset()
    ) : n && n.code === j.RESOURCE_EXHAUSTED ? (
      // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
      (Yr(n.toString()), Yr("Using maximum backoff delay to prevent overloading the backend."), this.t_.Wo())
    ) : n && n.code === j.UNAUTHENTICATED && this.state !== 3 && // "unauthenticated" error means the token was rejected. This should rarely
    // happen since both Auth and AppCheck ensure a sufficient TTL when we
    // request a token. If a user manually resets their system clock this can
    // fail, however. In this case, we should get a Code.UNAUTHENTICATED error
    // before we received the first message and we need to invalidate the token
    // to ensure that we fetch a new token.
    (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), // Clean up the underlying stream because we are no longer interested in events.
    this.stream !== null && (this.l_(), this.stream.close(), this.stream = null), // This state must be assigned before calling onClose() to allow the callback to
    // inhibit backoff or otherwise manipulate the state in its non-started state.
    this.state = e, // Notify the listener that the stream closed.
    await this.listener.mo(n);
  }
  /**
   * Can be overridden to perform additional cleanup before the stream is closed.
   * Calling super.tearDown() is not required.
   */
  l_() {
  }
  auth() {
    this.state = 1;
    const e = this.h_(this.Yo), n = this.Yo;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([r, i]) => {
      this.Yo === n && // Normally we'd have to schedule the callback on the AsyncQueue.
      // However, the following calls are safe to be called outside the
      // AsyncQueue since they don't chain asynchronous calls
      this.P_(r, i);
    }, (r) => {
      e(() => {
        const i = new ne(j.UNKNOWN, "Fetching auth token failed: " + r.message);
        return this.I_(i);
      });
    });
  }
  P_(e, n) {
    const r = this.h_(this.Yo);
    this.stream = this.T_(e, n), this.stream.Eo(() => {
      r(() => this.listener.Eo());
    }), this.stream.Ro(() => {
      r(() => (this.state = 2, this.Xo = this.ui.enqueueAfterDelay(this.Jo, 1e4, () => (this.r_() && (this.state = 3), Promise.resolve())), this.listener.Ro()));
    }), this.stream.mo((i) => {
      r(() => this.I_(i));
    }), this.stream.onMessage((i) => {
      r(() => ++this.e_ == 1 ? this.E_(i) : this.onNext(i));
    });
  }
  i_() {
    this.state = 5, this.t_.Go(async () => {
      this.state = 0, this.start();
    });
  }
  // Visible for tests
  I_(e) {
    return fe("PersistentStream", `close with error: ${e}`), this.stream = null, this.close(4, e);
  }
  /**
   * Returns a "dispatcher" function that dispatches operations onto the
   * AsyncQueue but only runs them if closeCount remains unchanged. This allows
   * us to turn auth / stream callbacks into no-ops if the stream is closed /
   * re-opened, etc.
   */
  h_(e) {
    return (n) => {
      this.ui.enqueueAndForget(() => this.Yo === e ? n() : (fe("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
}
class cP extends WE {
  constructor(e, n, r, i, s, o) {
    super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", n, r, i, o), this.serializer = s;
  }
  T_(e, n) {
    return this.connection.Bo("Listen", e, n);
  }
  E_(e) {
    return this.onNext(e);
  }
  onNext(e) {
    this.t_.reset();
    const n = vO(this.serializer, e), r = function(s) {
      if (!("targetChange" in s)) return Pe.min();
      const o = s.targetChange;
      return o.targetIds && o.targetIds.length ? Pe.min() : o.readTime ? br(o.readTime) : Pe.min();
    }(e);
    return this.listener.d_(n, r);
  }
  /**
   * Registers interest in the results of the given target. If the target
   * includes a resumeToken it will be included in the request. Results that
   * affect the target will be streamed back as WatchChange messages that
   * reference the targetId.
   */
  A_(e) {
    const n = {};
    n.database = Xd(this.serializer), n.addTarget = function(s, o) {
      let a;
      const l = o.target;
      if (a = Wd(l) ? {
        documents: TO(s, l)
      } : {
        query: IO(s, l)._t
      }, a.targetId = o.targetId, o.resumeToken.approximateByteSize() > 0) {
        a.resumeToken = DE(s, o.resumeToken);
        const u = Hd(s, o.expectedCount);
        u !== null && (a.expectedCount = u);
      } else if (o.snapshotVersion.compareTo(Pe.min()) > 0) {
        a.readTime = qc(s, o.snapshotVersion.toTimestamp());
        const u = Hd(s, o.expectedCount);
        u !== null && (a.expectedCount = u);
      }
      return a;
    }(this.serializer, e);
    const r = AO(this.serializer, e);
    r && (n.labels = r), this.a_(n);
  }
  /**
   * Unregisters interest in the results of the target associated with the
   * given targetId.
   */
  R_(e) {
    const n = {};
    n.database = Xd(this.serializer), n.removeTarget = e, this.a_(n);
  }
}
class lP extends WE {
  constructor(e, n, r, i, s, o) {
    super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", n, r, i, o), this.serializer = s;
  }
  /**
   * Tracks whether or not a handshake has been successfully exchanged and
   * the stream is ready to accept mutations.
   */
  get V_() {
    return this.e_ > 0;
  }
  // Override of PersistentStream.start
  start() {
    this.lastStreamToken = void 0, super.start();
  }
  l_() {
    this.V_ && this.m_([]);
  }
  T_(e, n) {
    return this.connection.Bo("Write", e, n);
  }
  E_(e) {
    return it(!!e.streamToken), this.lastStreamToken = e.streamToken, // The first response is always the handshake response
    it(!e.writeResults || e.writeResults.length === 0), this.listener.f_();
  }
  onNext(e) {
    it(!!e.streamToken), this.lastStreamToken = e.streamToken, // A successful first write response means the stream is healthy,
    // Note, that we could consider a successful handshake healthy, however,
    // the write itself might be causing an error we want to back off from.
    this.t_.reset();
    const n = wO(e.writeResults, e.commitTime), r = br(e.commitTime);
    return this.listener.g_(r, n);
  }
  /**
   * Sends an initial streamToken to the server, performing the handshake
   * required to make the StreamingWrite RPC work. Subsequent
   * calls should wait until onHandshakeComplete was called.
   */
  p_() {
    const e = {};
    e.database = Xd(this.serializer), this.a_(e);
  }
  /** Sends a group of mutations to the Firestore backend to apply. */
  m_(e) {
    const n = {
      streamToken: this.lastStreamToken,
      writes: e.map((r) => EO(this.serializer, r))
    };
    this.a_(n);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uP extends class {
} {
  constructor(e, n, r, i) {
    super(), this.authCredentials = e, this.appCheckCredentials = n, this.connection = r, this.serializer = i, this.y_ = !1;
  }
  w_() {
    if (this.y_) throw new ne(j.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  Mo(e, n, r, i) {
    return this.w_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, o]) => this.connection.Mo(e, Kd(n, r), i, s, o)).catch((s) => {
      throw s.name === "FirebaseError" ? (s.code === j.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new ne(j.UNKNOWN, s.toString());
    });
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  Lo(e, n, r, i, s) {
    return this.w_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([o, a]) => this.connection.Lo(e, Kd(n, r), i, o, a, s)).catch((o) => {
      throw o.name === "FirebaseError" ? (o.code === j.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), o) : new ne(j.UNKNOWN, o.toString());
    });
  }
  terminate() {
    this.y_ = !0, this.connection.terminate();
  }
}
class dP {
  constructor(e, n) {
    this.asyncQueue = e, this.onlineStateHandler = n, /** The current OnlineState. */
    this.state = "Unknown", /**
    * A count of consecutive failures to open the stream. If it reaches the
    * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
    * Offline.
    */
    this.S_ = 0, /**
    * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
    * transition from OnlineState.Unknown to OnlineState.Offline without waiting
    * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
    */
    this.b_ = null, /**
    * Whether the client should log a warning message if it fails to connect to
    * the backend (initially true, cleared after a successful stream, or if we've
    * logged the message already).
    */
    this.D_ = !0;
  }
  /**
   * Called by RemoteStore when a watch stream is started (including on each
   * backoff attempt).
   *
   * If this is the first attempt, it sets the OnlineState to Unknown and starts
   * the onlineStateTimer.
   */
  v_() {
    this.S_ === 0 && (this.C_(
      "Unknown"
      /* OnlineState.Unknown */
    ), this.b_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.b_ = null, this.F_("Backend didn't respond within 10 seconds."), this.C_(
      "Offline"
      /* OnlineState.Offline */
    ), Promise.resolve())));
  }
  /**
   * Updates our OnlineState as appropriate after the watch stream reports a
   * failure. The first failure moves us to the 'Unknown' state. We then may
   * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
   * actually transition to the 'Offline' state.
   */
  M_(e) {
    this.state === "Online" ? this.C_(
      "Unknown"
      /* OnlineState.Unknown */
    ) : (this.S_++, this.S_ >= 1 && (this.x_(), this.F_(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.C_(
      "Offline"
      /* OnlineState.Offline */
    )));
  }
  /**
   * Explicitly sets the OnlineState to the specified state.
   *
   * Note that this resets our timers / failure counters, etc. used by our
   * Offline heuristics, so must not be used in place of
   * handleWatchStreamStart() and handleWatchStreamFailure().
   */
  set(e) {
    this.x_(), this.S_ = 0, e === "Online" && // We've connected to watch at least once. Don't warn the developer
    // about being offline going forward.
    (this.D_ = !1), this.C_(e);
  }
  C_(e) {
    e !== this.state && (this.state = e, this.onlineStateHandler(e));
  }
  F_(e) {
    const n = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.D_ ? (Yr(n), this.D_ = !1) : fe("OnlineStateTracker", n);
  }
  x_() {
    this.b_ !== null && (this.b_.cancel(), this.b_ = null);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fP {
  constructor(e, n, r, i, s) {
    this.localStore = e, this.datastore = n, this.asyncQueue = r, this.remoteSyncer = {}, /**
    * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
    * LocalStore via fillWritePipeline() and have or will send to the write
    * stream.
    *
    * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
    * restart the write stream. When the stream is established the writes in the
    * pipeline will be sent in order.
    *
    * Writes remain in writePipeline until they are acknowledged by the backend
    * and thus will automatically be re-sent if the stream is interrupted /
    * restarted before they're acknowledged.
    *
    * Write responses from the backend are linked to their originating request
    * purely based on order, and so we can just shift() writes from the front of
    * the writePipeline as we receive responses.
    */
    this.O_ = [], /**
    * A mapping of watched targets that the client cares about tracking and the
    * user has explicitly called a 'listen' for this target.
    *
    * These targets may or may not have been sent to or acknowledged by the
    * server. On re-establishing the listen stream, these targets should be sent
    * to the server. The targets removed with unlistens are removed eagerly
    * without waiting for confirmation from the listen stream.
    */
    this.N_ = /* @__PURE__ */ new Map(), /**
    * A set of reasons for why the RemoteStore may be offline. If empty, the
    * RemoteStore may start its network connections.
    */
    this.L_ = /* @__PURE__ */ new Set(), /**
    * Event handlers that get called when the network is disabled or enabled.
    *
    * PORTING NOTE: These functions are used on the Web client to create the
    * underlying streams (to support tree-shakeable streams). On Android and iOS,
    * the streams are created during construction of RemoteStore.
    */
    this.B_ = [], this.k_ = s, this.k_._o((o) => {
      r.enqueueAndForget(async () => {
        fs(this) && (fe("RemoteStore", "Restarting streams for network reachability change."), await async function(l) {
          const u = xe(l);
          u.L_.add(
            4
            /* OfflineCause.ConnectivityChange */
          ), await Ta(u), u.q_.set(
            "Unknown"
            /* OnlineState.Unknown */
          ), u.L_.delete(
            4
            /* OfflineCause.ConnectivityChange */
          ), await Al(u);
        }(this));
      });
    }), this.q_ = new dP(r, i);
  }
}
async function Al(t) {
  if (fs(t)) for (const e of t.B_) await e(
    /* enabled= */
    !0
  );
}
async function Ta(t) {
  for (const e of t.B_) await e(
    /* enabled= */
    !1
  );
}
function GE(t, e) {
  const n = xe(t);
  n.N_.has(e.targetId) || // Mark this as something the client is currently listening for.
  (n.N_.set(e.targetId, e), Ch(n) ? (
    // The listen will be sent in onWatchStreamOpen
    Rh(n)
  ) : fo(n).r_() && Ah(n, e));
}
function Sh(t, e) {
  const n = xe(t), r = fo(n);
  n.N_.delete(e), r.r_() && HE(n, e), n.N_.size === 0 && (r.r_() ? r.o_() : fs(n) && // Revert to OnlineState.Unknown if the watch stream is not open and we
  // have no listeners, since without any listens to send we cannot
  // confirm if the stream is healthy and upgrade to OnlineState.Online.
  n.q_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function Ah(t, e) {
  if (t.Q_.xe(e.targetId), e.resumeToken.approximateByteSize() > 0 || e.snapshotVersion.compareTo(Pe.min()) > 0) {
    const n = t.remoteSyncer.getRemoteKeysForTarget(e.targetId).size;
    e = e.withExpectedCount(n);
  }
  fo(t).A_(e);
}
function HE(t, e) {
  t.Q_.xe(e), fo(t).R_(e);
}
function Rh(t) {
  t.Q_ = new hO({
    getRemoteKeysForTarget: (e) => t.remoteSyncer.getRemoteKeysForTarget(e),
    ot: (e) => t.N_.get(e) || null,
    tt: () => t.datastore.serializer.databaseId
  }), fo(t).start(), t.q_.v_();
}
function Ch(t) {
  return fs(t) && !fo(t).n_() && t.N_.size > 0;
}
function fs(t) {
  return xe(t).L_.size === 0;
}
function KE(t) {
  t.Q_ = void 0;
}
async function hP(t) {
  t.q_.set(
    "Online"
    /* OnlineState.Online */
  );
}
async function pP(t) {
  t.N_.forEach((e, n) => {
    Ah(t, e);
  });
}
async function mP(t, e) {
  KE(t), // If we still need the watch stream, retry the connection.
  Ch(t) ? (t.q_.M_(e), Rh(t)) : (
    // No need to restart watch stream because there are no active targets.
    // The online state is set to unknown because there is no active attempt
    // at establishing a connection
    t.q_.set(
      "Unknown"
      /* OnlineState.Unknown */
    )
  );
}
async function gP(t, e, n) {
  if (
    // Mark the client as online since we got a message from the server
    t.q_.set(
      "Online"
      /* OnlineState.Online */
    ), e instanceof ME && e.state === 2 && e.cause
  )
    try {
      await /** Handles an error on a target */
      async function(i, s) {
        const o = s.cause;
        for (const a of s.targetIds)
          i.N_.has(a) && (await i.remoteSyncer.rejectListen(a, o), i.N_.delete(a), i.Q_.removeTarget(a));
      }(t, e);
    } catch (r) {
      fe("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), r), await zc(t, r);
    }
  else if (e instanceof _c ? t.Q_.Ke(e) : e instanceof xE ? t.Q_.He(e) : t.Q_.We(e), !n.isEqual(Pe.min())) try {
    const r = await qE(t.localStore);
    n.compareTo(r) >= 0 && // We have received a target change with a global snapshot if the snapshot
    // version is not equal to SnapshotVersion.min().
    await /**
    * Takes a batch of changes from the Datastore, repackages them as a
    * RemoteEvent, and passes that on to the listener, which is typically the
    * SyncEngine.
    */
    function(s, o) {
      const a = s.Q_.rt(o);
      return a.targetChanges.forEach((l, u) => {
        if (l.resumeToken.approximateByteSize() > 0) {
          const d = s.N_.get(u);
          d && s.N_.set(u, d.withResumeToken(l.resumeToken, o));
        }
      }), // Re-establish listens for the targets that have been invalidated by
      // existence filter mismatches.
      a.targetMismatches.forEach((l, u) => {
        const d = s.N_.get(l);
        if (!d)
          return;
        s.N_.set(l, d.withResumeToken(Qt.EMPTY_BYTE_STRING, d.snapshotVersion)), // Cause a hard reset by unwatching and rewatching immediately, but
        // deliberately don't send a resume token so that we get a full update.
        HE(s, l);
        const f = new pi(d.target, l, u, d.sequenceNumber);
        Ah(s, f);
      }), s.remoteSyncer.applyRemoteEvent(a);
    }(t, n);
  } catch (r) {
    fe("RemoteStore", "Failed to raise snapshot:", r), await zc(t, r);
  }
}
async function zc(t, e, n) {
  if (!va(e)) throw e;
  t.L_.add(
    1
    /* OfflineCause.IndexedDbFailed */
  ), // Disable network and raise offline snapshots
  await Ta(t), t.q_.set(
    "Offline"
    /* OnlineState.Offline */
  ), n || // Use a simple read operation to determine if IndexedDB recovered.
  // Ideally, we would expose a health check directly on SimpleDb, but
  // RemoteStore only has access to persistence through LocalStore.
  (n = () => qE(t.localStore)), // Probe IndexedDB periodically and re-enable network
  t.asyncQueue.enqueueRetryable(async () => {
    fe("RemoteStore", "Retrying IndexedDB access"), await n(), t.L_.delete(
      1
      /* OfflineCause.IndexedDbFailed */
    ), await Al(t);
  });
}
function YE(t, e) {
  return e().catch((n) => zc(t, n, e));
}
async function Rl(t) {
  const e = xe(t), n = Ti(e);
  let r = e.O_.length > 0 ? e.O_[e.O_.length - 1].batchId : -1;
  for (; yP(e); ) try {
    const i = await eP(e.localStore, r);
    if (i === null) {
      e.O_.length === 0 && n.o_();
      break;
    }
    r = i.batchId, _P(e, i);
  } catch (i) {
    await zc(e, i);
  }
  XE(e) && QE(e);
}
function yP(t) {
  return fs(t) && t.O_.length < 10;
}
function _P(t, e) {
  t.O_.push(e);
  const n = Ti(t);
  n.r_() && n.V_ && n.m_(e.mutations);
}
function XE(t) {
  return fs(t) && !Ti(t).n_() && t.O_.length > 0;
}
function QE(t) {
  Ti(t).start();
}
async function bP(t) {
  Ti(t).p_();
}
async function vP(t) {
  const e = Ti(t);
  for (const n of t.O_) e.m_(n.mutations);
}
async function EP(t, e, n) {
  const r = t.O_.shift(), i = bh.from(r, e, n);
  await YE(t, () => t.remoteSyncer.applySuccessfulWrite(i)), // It's possible that with the completion of this mutation another
  // slot has freed up.
  await Rl(t);
}
async function wP(t, e) {
  e && Ti(t).V_ && // This error affects the actual write.
  await async function(r, i) {
    if (function(o) {
      return uO(o) && o !== j.ABORTED;
    }(i.code)) {
      const s = r.O_.shift();
      Ti(r).s_(), await YE(r, () => r.remoteSyncer.rejectFailedWrite(s.batchId, i)), // It's possible that with the completion of this mutation
      // another slot has freed up.
      await Rl(r);
    }
  }(t, e), // The write stream might have been started by refilling the write
  // pipeline for failed writes
  XE(t) && QE(t);
}
async function Qg(t, e) {
  const n = xe(t);
  n.asyncQueue.verifyOperationInProgress(), fe("RemoteStore", "RemoteStore received new credentials");
  const r = fs(n);
  n.L_.add(
    3
    /* OfflineCause.CredentialChange */
  ), await Ta(n), r && // Don't set the network status to Unknown if we are offline.
  n.q_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ), await n.remoteSyncer.handleCredentialChange(e), n.L_.delete(
    3
    /* OfflineCause.CredentialChange */
  ), await Al(n);
}
async function TP(t, e) {
  const n = xe(t);
  e ? (n.L_.delete(
    2
    /* OfflineCause.IsSecondary */
  ), await Al(n)) : e || (n.L_.add(
    2
    /* OfflineCause.IsSecondary */
  ), await Ta(n), n.q_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function fo(t) {
  return t.K_ || // Create stream (but note that it is not started yet).
  (t.K_ = function(n, r, i) {
    const s = xe(n);
    return s.w_(), new cP(r, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, i);
  }(t.datastore, t.asyncQueue, {
    Eo: hP.bind(null, t),
    Ro: pP.bind(null, t),
    mo: mP.bind(null, t),
    d_: gP.bind(null, t)
  }), t.B_.push(async (e) => {
    e ? (t.K_.s_(), Ch(t) ? Rh(t) : t.q_.set(
      "Unknown"
      /* OnlineState.Unknown */
    )) : (await t.K_.stop(), KE(t));
  })), t.K_;
}
function Ti(t) {
  return t.U_ || // Create stream (but note that it is not started yet).
  (t.U_ = function(n, r, i) {
    const s = xe(n);
    return s.w_(), new lP(r, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, i);
  }(t.datastore, t.asyncQueue, {
    Eo: () => Promise.resolve(),
    Ro: bP.bind(null, t),
    mo: wP.bind(null, t),
    f_: vP.bind(null, t),
    g_: EP.bind(null, t)
  }), t.B_.push(async (e) => {
    e ? (t.U_.s_(), // This will start the write stream if necessary.
    await Rl(t)) : (await t.U_.stop(), t.O_.length > 0 && (fe("RemoteStore", `Stopping write stream with ${t.O_.length} pending writes`), t.O_ = []));
  })), t.U_;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kh {
  constructor(e, n, r, i, s) {
    this.asyncQueue = e, this.timerId = n, this.targetTimeMs = r, this.op = i, this.removalCallback = s, this.deferred = new jr(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
    // and so we attach a dummy catch callback to avoid
    // 'UnhandledPromiseRejectionWarning' log spam.
    this.deferred.promise.catch((o) => {
    });
  }
  get promise() {
    return this.deferred.promise;
  }
  /**
   * Creates and returns a DelayedOperation that has been scheduled to be
   * executed on the provided asyncQueue after the provided delayMs.
   *
   * @param asyncQueue - The queue to schedule the operation on.
   * @param id - A Timer ID identifying the type of operation this is.
   * @param delayMs - The delay (ms) before the operation should be scheduled.
   * @param op - The operation to run.
   * @param removalCallback - A callback to be called synchronously once the
   *   operation is executed or canceled, notifying the AsyncQueue to remove it
   *   from its delayedOperations list.
   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
   *   the DelayedOperation class public.
   */
  static createAndSchedule(e, n, r, i, s) {
    const o = Date.now() + r, a = new kh(e, n, o, i, s);
    return a.start(r), a;
  }
  /**
   * Starts the timer. This is called immediately after construction by
   * createAndSchedule().
   */
  start(e) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e);
  }
  /**
   * Queues the operation to run immediately (if it hasn't already been run or
   * canceled).
   */
  skipDelay() {
    return this.handleDelayElapsed();
  }
  /**
   * Cancels the operation if it hasn't already been executed or canceled. The
   * promise will be rejected.
   *
   * As long as the operation has not yet been run, calling cancel() provides a
   * guarantee that the operation will not be run.
   */
  cancel(e) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new ne(j.CANCELLED, "Operation cancelled" + (e ? ": " + e : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((e) => this.deferred.resolve(e))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
function Nh(t, e) {
  if (Yr("AsyncQueue", `${e}: ${t}`), va(t)) return new ne(j.UNAVAILABLE, `${e}: ${t}`);
  throw t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Us {
  /** The default ordering is by key if the comparator is omitted */
  constructor(e) {
    this.comparator = e ? (n, r) => e(n, r) || ve.comparator(n.key, r.key) : (n, r) => ve.comparator(n.key, r.key), this.keyedMap = Mo(), this.sortedSet = new Tt(this.comparator);
  }
  /**
   * Returns an empty copy of the existing DocumentSet, using the same
   * comparator.
   */
  static emptySet(e) {
    return new Us(e.comparator);
  }
  has(e) {
    return this.keyedMap.get(e) != null;
  }
  get(e) {
    return this.keyedMap.get(e);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  /**
   * Returns the index of the provided key in the document set, or -1 if the
   * document key is not present in the set;
   */
  indexOf(e) {
    const n = this.keyedMap.get(e);
    return n ? this.sortedSet.indexOf(n) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  /** Iterates documents in order defined by "comparator" */
  forEach(e) {
    this.sortedSet.inorderTraversal((n, r) => (e(n), !1));
  }
  /** Inserts or updates a document with the same key */
  add(e) {
    const n = this.delete(e.key);
    return n.copy(n.keyedMap.insert(e.key, e), n.sortedSet.insert(e, null));
  }
  /** Deletes a document with a given key */
  delete(e) {
    const n = this.get(e);
    return n ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(n)) : this;
  }
  isEqual(e) {
    if (!(e instanceof Us) || this.size !== e.size) return !1;
    const n = this.sortedSet.getIterator(), r = e.sortedSet.getIterator();
    for (; n.hasNext(); ) {
      const i = n.getNext().key, s = r.getNext().key;
      if (!i.isEqual(s)) return !1;
    }
    return !0;
  }
  toString() {
    const e = [];
    return this.forEach((n) => {
      e.push(n.toString());
    }), e.length === 0 ? "DocumentSet ()" : `DocumentSet (
  ` + e.join(`  
`) + `
)`;
  }
  copy(e, n) {
    const r = new Us();
    return r.comparator = this.comparator, r.keyedMap = e, r.sortedSet = n, r;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Jg {
  constructor() {
    this.W_ = new Tt(ve.comparator);
  }
  track(e) {
    const n = e.doc.key, r = this.W_.get(n);
    r ? (
      // Merge the new change with the existing change.
      e.type !== 0 && r.type === 3 ? this.W_ = this.W_.insert(n, e) : e.type === 3 && r.type !== 1 ? this.W_ = this.W_.insert(n, {
        type: r.type,
        doc: e.doc
      }) : e.type === 2 && r.type === 2 ? this.W_ = this.W_.insert(n, {
        type: 2,
        doc: e.doc
      }) : e.type === 2 && r.type === 0 ? this.W_ = this.W_.insert(n, {
        type: 0,
        doc: e.doc
      }) : e.type === 1 && r.type === 0 ? this.W_ = this.W_.remove(n) : e.type === 1 && r.type === 2 ? this.W_ = this.W_.insert(n, {
        type: 1,
        doc: r.doc
      }) : e.type === 0 && r.type === 1 ? this.W_ = this.W_.insert(n, {
        type: 2,
        doc: e.doc
      }) : (
        // This includes these cases, which don't make sense:
        // Added->Added
        // Removed->Removed
        // Modified->Added
        // Removed->Modified
        // Metadata->Added
        // Removed->Metadata
        Ne()
      )
    ) : this.W_ = this.W_.insert(n, e);
  }
  G_() {
    const e = [];
    return this.W_.inorderTraversal((n, r) => {
      e.push(r);
    }), e;
  }
}
class eo {
  constructor(e, n, r, i, s, o, a, l, u) {
    this.query = e, this.docs = n, this.oldDocs = r, this.docChanges = i, this.mutatedKeys = s, this.fromCache = o, this.syncStateChanged = a, this.excludesMetadataChanges = l, this.hasCachedResults = u;
  }
  /** Returns a view snapshot as if all documents in the snapshot were added. */
  static fromInitialDocuments(e, n, r, i, s) {
    const o = [];
    return n.forEach((a) => {
      o.push({
        type: 0,
        doc: a
      });
    }), new eo(
      e,
      n,
      Us.emptySet(n),
      o,
      r,
      i,
      /* syncStateChanged= */
      !0,
      /* excludesMetadataChanges= */
      !1,
      s
    );
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(e) {
    if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && vl(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return !1;
    const n = this.docChanges, r = e.docChanges;
    if (n.length !== r.length) return !1;
    for (let i = 0; i < n.length; i++) if (n[i].type !== r[i].type || !n[i].doc.isEqual(r[i].doc)) return !1;
    return !0;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IP {
  constructor() {
    this.z_ = void 0, this.j_ = [];
  }
  // Helper methods that checks if the query has listeners that listening to remote store
  H_() {
    return this.j_.some((e) => e.J_());
  }
}
class SP {
  constructor() {
    this.queries = Zg(), this.onlineState = "Unknown", this.Y_ = /* @__PURE__ */ new Set();
  }
  terminate() {
    (function(n, r) {
      const i = xe(n), s = i.queries;
      i.queries = Zg(), s.forEach((o, a) => {
        for (const l of a.j_) l.onError(r);
      });
    })(this, new ne(j.ABORTED, "Firestore shutting down"));
  }
}
function Zg() {
  return new uo((t) => vE(t), vl);
}
async function Oh(t, e) {
  const n = xe(t);
  let r = 3;
  const i = e.query;
  let s = n.queries.get(i);
  s ? !s.H_() && e.J_() && // Query has been listening to local cache, and tries to add a new listener sourced from watch.
  (r = 2) : (s = new IP(), r = e.J_() ? 0 : 1);
  try {
    switch (r) {
      case 0:
        s.z_ = await n.onListen(
          i,
          /** enableRemoteListen= */
          !0
        );
        break;
      case 1:
        s.z_ = await n.onListen(
          i,
          /** enableRemoteListen= */
          !1
        );
        break;
      case 2:
        await n.onFirstRemoteStoreListen(i);
    }
  } catch (o) {
    const a = Nh(o, `Initialization of query '${ws(e.query)}' failed`);
    return void e.onError(a);
  }
  n.queries.set(i, s), s.j_.push(e), // Run global snapshot listeners if a consistent snapshot has been emitted.
  e.Z_(n.onlineState), s.z_ && e.X_(s.z_) && xh(n);
}
async function Ph(t, e) {
  const n = xe(t), r = e.query;
  let i = 3;
  const s = n.queries.get(r);
  if (s) {
    const o = s.j_.indexOf(e);
    o >= 0 && (s.j_.splice(o, 1), s.j_.length === 0 ? i = e.J_() ? 0 : 1 : !s.H_() && e.J_() && // The removed listener is the last one that sourced from watch.
    (i = 2));
  }
  switch (i) {
    case 0:
      return n.queries.delete(r), n.onUnlisten(
        r,
        /** disableRemoteListen= */
        !0
      );
    case 1:
      return n.queries.delete(r), n.onUnlisten(
        r,
        /** disableRemoteListen= */
        !1
      );
    case 2:
      return n.onLastRemoteStoreUnlisten(r);
    default:
      return;
  }
}
function AP(t, e) {
  const n = xe(t);
  let r = !1;
  for (const i of e) {
    const s = i.query, o = n.queries.get(s);
    if (o) {
      for (const a of o.j_) a.X_(i) && (r = !0);
      o.z_ = i;
    }
  }
  r && xh(n);
}
function RP(t, e, n) {
  const r = xe(t), i = r.queries.get(e);
  if (i) for (const s of i.j_) s.onError(n);
  r.queries.delete(e);
}
function xh(t) {
  t.Y_.forEach((e) => {
    e.next();
  });
}
var Jd, ey;
(ey = Jd || (Jd = {})).ea = "default", /** Listen to changes in cache only */
ey.Cache = "cache";
class Mh {
  constructor(e, n, r) {
    this.query = e, this.ta = n, /**
    * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
    * observer. This flag is set to true once we've actually raised an event.
    */
    this.na = !1, this.ra = null, this.onlineState = "Unknown", this.options = r || {};
  }
  /**
   * Applies the new ViewSnapshot to this listener, raising a user-facing event
   * if applicable (depending on what changed, whether the user has opted into
   * metadata-only changes, etc.). Returns true if a user-facing event was
   * indeed raised.
   */
  X_(e) {
    if (!this.options.includeMetadataChanges) {
      const r = [];
      for (const i of e.docChanges) i.type !== 3 && r.push(i);
      e = new eo(
        e.query,
        e.docs,
        e.oldDocs,
        r,
        e.mutatedKeys,
        e.fromCache,
        e.syncStateChanged,
        /* excludesMetadataChanges= */
        !0,
        e.hasCachedResults
      );
    }
    let n = !1;
    return this.na ? this.ia(e) && (this.ta.next(e), n = !0) : this.sa(e, this.onlineState) && (this.oa(e), n = !0), this.ra = e, n;
  }
  onError(e) {
    this.ta.error(e);
  }
  /** Returns whether a snapshot was raised. */
  Z_(e) {
    this.onlineState = e;
    let n = !1;
    return this.ra && !this.na && this.sa(this.ra, e) && (this.oa(this.ra), n = !0), n;
  }
  sa(e, n) {
    if (!e.fromCache || !this.J_()) return !0;
    const r = n !== "Offline";
    return (!this.options._a || !r) && (!e.docs.isEmpty() || e.hasCachedResults || n === "Offline");
  }
  ia(e) {
    if (e.docChanges.length > 0) return !0;
    const n = this.ra && this.ra.hasPendingWrites !== e.hasPendingWrites;
    return !(!e.syncStateChanged && !n) && this.options.includeMetadataChanges === !0;
  }
  oa(e) {
    e = eo.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults), this.na = !0, this.ta.next(e);
  }
  J_() {
    return this.options.source !== Jd.Cache;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JE {
  constructor(e) {
    this.key = e;
  }
}
class ZE {
  constructor(e) {
    this.key = e;
  }
}
class CP {
  constructor(e, n) {
    this.query = e, this.Ta = n, this.Ea = null, this.hasCachedResults = !1, /**
    * A flag whether the view is current with the backend. A view is considered
    * current after it has seen the current flag from the backend and did not
    * lose consistency within the watch stream (e.g. because of an existence
    * filter mismatch).
    */
    this.current = !1, /** Documents in the view but not in the remote target */
    this.da = qe(), /** Document Keys that have local changes */
    this.mutatedKeys = qe(), this.Aa = EE(e), this.Ra = new Us(this.Aa);
  }
  /**
   * The set of remote documents that the server has told us belongs to the target associated with
   * this view.
   */
  get Va() {
    return this.Ta;
  }
  /**
   * Iterates over a set of doc changes, applies the query limit, and computes
   * what the new results should be, what the changes were, and whether we may
   * need to go back to the local cache for more results. Does not make any
   * changes to the view.
   * @param docChanges - The doc changes to apply to this view.
   * @param previousChanges - If this is being called with a refill, then start
   *        with this set of docs and changes instead of the current view.
   * @returns a new set of docs, changes, and refill flag.
   */
  ma(e, n) {
    const r = n ? n.fa : new Jg(), i = n ? n.Ra : this.Ra;
    let s = n ? n.mutatedKeys : this.mutatedKeys, o = i, a = !1;
    const l = this.query.limitType === "F" && i.size === this.query.limit ? i.last() : null, u = this.query.limitType === "L" && i.size === this.query.limit ? i.first() : null;
    if (e.inorderTraversal((d, f) => {
      const p = i.get(d), g = El(this.query, f) ? f : null, _ = !!p && this.mutatedKeys.has(p.key), b = !!g && (g.hasLocalMutations || // We only consider committed mutations for documents that were
      // mutated during the lifetime of the view.
      this.mutatedKeys.has(g.key) && g.hasCommittedMutations);
      let m = !1;
      p && g ? p.data.isEqual(g.data) ? _ !== b && (r.track({
        type: 3,
        doc: g
      }), m = !0) : this.ga(p, g) || (r.track({
        type: 2,
        doc: g
      }), m = !0, (l && this.Aa(g, l) > 0 || u && this.Aa(g, u) < 0) && // This doc moved from inside the limit to outside the limit.
      // That means there may be some other doc in the local cache
      // that should be included instead.
      (a = !0)) : !p && g ? (r.track({
        type: 0,
        doc: g
      }), m = !0) : p && !g && (r.track({
        type: 1,
        doc: p
      }), m = !0, (l || u) && // A doc was removed from a full limit query. We'll need to
      // requery from the local cache to see if we know about some other
      // doc that should be in the results.
      (a = !0)), m && (g ? (o = o.add(g), s = b ? s.add(d) : s.delete(d)) : (o = o.delete(d), s = s.delete(d)));
    }), this.query.limit !== null) for (; o.size > this.query.limit; ) {
      const d = this.query.limitType === "F" ? o.last() : o.first();
      o = o.delete(d.key), s = s.delete(d.key), r.track({
        type: 1,
        doc: d
      });
    }
    return {
      Ra: o,
      fa: r,
      ns: a,
      mutatedKeys: s
    };
  }
  ga(e, n) {
    return e.hasLocalMutations && n.hasCommittedMutations && !n.hasLocalMutations;
  }
  /**
   * Updates the view with the given ViewDocumentChanges and optionally updates
   * limbo docs and sync state from the provided target change.
   * @param docChanges - The set of changes to make to the view's docs.
   * @param limboResolutionEnabled - Whether to update limbo documents based on
   *        this change.
   * @param targetChange - A target change to apply for computing limbo docs and
   *        sync state.
   * @param targetIsPendingReset - Whether the target is pending to reset due to
   *        existence filter mismatch. If not explicitly specified, it is treated
   *        equivalently to `false`.
   * @returns A new ViewChange with the given docs, changes, and sync state.
   */
  // PORTING NOTE: The iOS/Android clients always compute limbo document changes.
  applyChanges(e, n, r, i) {
    const s = this.Ra;
    this.Ra = e.Ra, this.mutatedKeys = e.mutatedKeys;
    const o = e.fa.G_();
    o.sort((d, f) => function(g, _) {
      const b = (m) => {
        switch (m) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return Ne();
        }
      };
      return b(g) - b(_);
    }(d.type, f.type) || this.Aa(d.doc, f.doc)), this.pa(r), i = i != null && i;
    const a = n && !i ? this.ya() : [], l = this.da.size === 0 && this.current && !i ? 1 : 0, u = l !== this.Ea;
    return this.Ea = l, o.length !== 0 || u ? {
      snapshot: new eo(
        this.query,
        e.Ra,
        s,
        o,
        e.mutatedKeys,
        l === 0,
        u,
        /* excludesMetadataChanges= */
        !1,
        !!r && r.resumeToken.approximateByteSize() > 0
      ),
      wa: a
    } : {
      wa: a
    };
  }
  /**
   * Applies an OnlineState change to the view, potentially generating a
   * ViewChange if the view's syncState changes as a result.
   */
  Z_(e) {
    return this.current && e === "Offline" ? (
      // If we're offline, set `current` to false and then call applyChanges()
      // to refresh our syncState and generate a ViewChange as appropriate. We
      // are guaranteed to get a new TargetChange that sets `current` back to
      // true once the client is back online.
      (this.current = !1, this.applyChanges(
        {
          Ra: this.Ra,
          fa: new Jg(),
          mutatedKeys: this.mutatedKeys,
          ns: !1
        },
        /* limboResolutionEnabled= */
        !1
      ))
    ) : {
      wa: []
    };
  }
  /**
   * Returns whether the doc for the given key should be in limbo.
   */
  Sa(e) {
    return !this.Ta.has(e) && // The local store doesn't think it's a result, so it shouldn't be in limbo.
    !!this.Ra.has(e) && !this.Ra.get(e).hasLocalMutations;
  }
  /**
   * Updates syncedDocuments, current, and limbo docs based on the given change.
   * Returns the list of changes to which docs are in limbo.
   */
  pa(e) {
    e && (e.addedDocuments.forEach((n) => this.Ta = this.Ta.add(n)), e.modifiedDocuments.forEach((n) => {
    }), e.removedDocuments.forEach((n) => this.Ta = this.Ta.delete(n)), this.current = e.current);
  }
  ya() {
    if (!this.current) return [];
    const e = this.da;
    this.da = qe(), this.Ra.forEach((r) => {
      this.Sa(r.key) && (this.da = this.da.add(r.key));
    });
    const n = [];
    return e.forEach((r) => {
      this.da.has(r) || n.push(new ZE(r));
    }), this.da.forEach((r) => {
      e.has(r) || n.push(new JE(r));
    }), n;
  }
  /**
   * Update the in-memory state of the current view with the state read from
   * persistence.
   *
   * We update the query view whenever a client's primary status changes:
   * - When a client transitions from primary to secondary, it can miss
   *   LocalStorage updates and its query views may temporarily not be
   *   synchronized with the state on disk.
   * - For secondary to primary transitions, the client needs to update the list
   *   of `syncedDocuments` since secondary clients update their query views
   *   based purely on synthesized RemoteEvents.
   *
   * @param queryResult.documents - The documents that match the query according
   * to the LocalStore.
   * @param queryResult.remoteKeys - The keys of the documents that match the
   * query according to the backend.
   *
   * @returns The ViewChange that resulted from this synchronization.
   */
  // PORTING NOTE: Multi-tab only.
  ba(e) {
    this.Ta = e.Ts, this.da = qe();
    const n = this.ma(e.documents);
    return this.applyChanges(
      n,
      /* limboResolutionEnabled= */
      !0
    );
  }
  /**
   * Returns a view snapshot as if this query was just listened to. Contains
   * a document add for every existing document and the `fromCache` and
   * `hasPendingWrites` status of the already established view.
   */
  // PORTING NOTE: Multi-tab only.
  Da() {
    return eo.fromInitialDocuments(this.query, this.Ra, this.mutatedKeys, this.Ea === 0, this.hasCachedResults);
  }
}
class kP {
  constructor(e, n, r) {
    this.query = e, this.targetId = n, this.view = r;
  }
}
class NP {
  constructor(e) {
    this.key = e, /**
    * Set to true once we've received a document. This is used in
    * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to
    * decide whether it needs to manufacture a delete event for the target once
    * the target is CURRENT.
    */
    this.va = !1;
  }
}
class OP {
  constructor(e, n, r, i, s, o) {
    this.localStore = e, this.remoteStore = n, this.eventManager = r, this.sharedClientState = i, this.currentUser = s, this.maxConcurrentLimboResolutions = o, this.Ca = {}, this.Fa = new uo((a) => vE(a), vl), this.Ma = /* @__PURE__ */ new Map(), /**
    * The keys of documents that are in limbo for which we haven't yet started a
    * limbo resolution query. The strings in this set are the result of calling
    * `key.path.canonicalString()` where `key` is a `DocumentKey` object.
    *
    * The `Set` type was chosen because it provides efficient lookup and removal
    * of arbitrary elements and it also maintains insertion order, providing the
    * desired queue-like FIFO semantics.
    */
    this.xa = /* @__PURE__ */ new Set(), /**
    * Keeps track of the target ID for each document that is in limbo with an
    * active target.
    */
    this.Oa = new Tt(ve.comparator), /**
    * Keeps track of the information about an active limbo resolution for each
    * active target ID that was started for the purpose of limbo resolution.
    */
    this.Na = /* @__PURE__ */ new Map(), this.La = new wh(), /** Stores user completion handlers, indexed by User and BatchId. */
    this.Ba = {}, /** Stores user callbacks waiting for all pending writes to be acknowledged. */
    this.ka = /* @__PURE__ */ new Map(), this.qa = Zs.kn(), this.onlineState = "Unknown", // The primary state is set to `true` or `false` immediately after Firestore
    // startup. In the interim, a client should only be considered primary if
    // `isPrimary` is true.
    this.Qa = void 0;
  }
  get isPrimaryClient() {
    return this.Qa === !0;
  }
}
async function PP(t, e, n = !0) {
  const r = sw(t);
  let i;
  const s = r.Fa.get(e);
  return s ? (
    // PORTING NOTE: With Multi-Tab Web, it is possible that a query view
    // already exists when EventManager calls us for the first time. This
    // happens when the primary tab is already listening to this query on
    // behalf of another tab and the user of the primary also starts listening
    // to the query. EventManager will not have an assigned target ID in this
    // case and calls `listen` to obtain this ID.
    (r.sharedClientState.addLocalQueryTarget(s.targetId), i = s.view.Da())
  ) : i = await ew(
    r,
    e,
    n,
    /** shouldInitializeView= */
    !0
  ), i;
}
async function xP(t, e) {
  const n = sw(t);
  await ew(
    n,
    e,
    /** shouldListenToRemote= */
    !0,
    /** shouldInitializeView= */
    !1
  );
}
async function ew(t, e, n, r) {
  const i = await tP(t.localStore, yr(e)), s = i.targetId, o = t.sharedClientState.addLocalQueryTarget(s, n);
  let a;
  return r && (a = await MP(t, e, s, o === "current", i.resumeToken)), t.isPrimaryClient && n && GE(t.remoteStore, i), a;
}
async function MP(t, e, n, r, i) {
  t.Ka = (f, p, g) => async function(b, m, v, C) {
    let x = m.view.ma(v);
    x.ns && // The query has a limit and some docs were removed, so we need
    // to re-run the query against the local store to make sure we
    // didn't lose any good docs that had been past the limit.
    (x = await Kg(
      b.localStore,
      m.query,
      /* usePreviousResults= */
      !1
    ).then(({ documents: I }) => m.view.ma(I, x)));
    const P = C && C.targetChanges.get(m.targetId), k = C && C.targetMismatches.get(m.targetId) != null, U = m.view.applyChanges(
      x,
      /* limboResolutionEnabled= */
      b.isPrimaryClient,
      P,
      k
    );
    return ny(b, m.targetId, U.wa), U.snapshot;
  }(t, f, p, g);
  const s = await Kg(
    t.localStore,
    e,
    /* usePreviousResults= */
    !0
  ), o = new CP(e, s.Ts), a = o.ma(s.documents), l = wa.createSynthesizedTargetChangeForCurrentChange(n, r && t.onlineState !== "Offline", i), u = o.applyChanges(
    a,
    /* limboResolutionEnabled= */
    t.isPrimaryClient,
    l
  );
  ny(t, n, u.wa);
  const d = new kP(e, n, o);
  return t.Fa.set(e, d), t.Ma.has(n) ? t.Ma.get(n).push(e) : t.Ma.set(n, [e]), u.snapshot;
}
async function DP(t, e, n) {
  const r = xe(t), i = r.Fa.get(e), s = r.Ma.get(i.targetId);
  if (s.length > 1) return r.Ma.set(i.targetId, s.filter((o) => !vl(o, e))), void r.Fa.delete(e);
  r.isPrimaryClient ? (r.sharedClientState.removeLocalQueryTarget(i.targetId), r.sharedClientState.isActiveQueryTarget(i.targetId) || await Qd(
    r.localStore,
    i.targetId,
    /*keepPersistedTargetData=*/
    !1
  ).then(() => {
    r.sharedClientState.clearQueryState(i.targetId), n && Sh(r.remoteStore, i.targetId), Zd(r, i.targetId);
  }).catch(ba)) : (Zd(r, i.targetId), await Qd(
    r.localStore,
    i.targetId,
    /*keepPersistedTargetData=*/
    !0
  ));
}
async function LP(t, e) {
  const n = xe(t), r = n.Fa.get(e), i = n.Ma.get(r.targetId);
  n.isPrimaryClient && i.length === 1 && // PORTING NOTE: Unregister the target ID with local Firestore client as
  // watch target.
  (n.sharedClientState.removeLocalQueryTarget(r.targetId), Sh(n.remoteStore, r.targetId));
}
async function UP(t, e, n) {
  const r = zP(t);
  try {
    const i = await function(o, a) {
      const l = xe(o), u = Vt.now(), d = a.reduce((g, _) => g.add(_.key), qe());
      let f, p;
      return l.persistence.runTransaction("Locally write mutations", "readwrite", (g) => {
        let _ = Xr(), b = qe();
        return l.cs.getEntries(g, d).next((m) => {
          _ = m, _.forEach((v, C) => {
            C.isValidDocument() || (b = b.add(v));
          });
        }).next(() => l.localDocuments.getOverlayedDocuments(g, _)).next((m) => {
          f = m;
          const v = [];
          for (const C of a) {
            const x = sO(C, f.get(C.key).overlayedDocument);
            x != null && // NOTE: The base state should only be applied if there's some
            // existing document to override, so use a Precondition of
            // exists=true
            v.push(new ds(C.key, x, hE(x.value.mapValue), _r.exists(!0)));
          }
          return l.mutationQueue.addMutationBatch(g, u, v, a);
        }).next((m) => {
          p = m;
          const v = m.applyToLocalDocumentSet(f, b);
          return l.documentOverlayCache.saveOverlays(g, m.batchId, v);
        });
      }).then(() => ({
        batchId: p.batchId,
        changes: TE(f)
      }));
    }(r.localStore, e);
    r.sharedClientState.addPendingMutation(i.batchId), function(o, a, l) {
      let u = o.Ba[o.currentUser.toKey()];
      u || (u = new Tt(Xe)), u = u.insert(a, l), o.Ba[o.currentUser.toKey()] = u;
    }(r, i.batchId, n), await Ia(r, i.changes), await Rl(r.remoteStore);
  } catch (i) {
    const s = Nh(i, "Failed to persist write");
    n.reject(s);
  }
}
async function tw(t, e) {
  const n = xe(t);
  try {
    const r = await JO(n.localStore, e);
    e.targetChanges.forEach((i, s) => {
      const o = n.Na.get(s);
      o && // Since this is a limbo resolution lookup, it's for a single document
      // and it could be added, modified, or removed, but not a combination.
      (it(i.addedDocuments.size + i.modifiedDocuments.size + i.removedDocuments.size <= 1), i.addedDocuments.size > 0 ? o.va = !0 : i.modifiedDocuments.size > 0 ? it(o.va) : i.removedDocuments.size > 0 && (it(o.va), o.va = !1));
    }), await Ia(n, r, e);
  } catch (r) {
    await ba(r);
  }
}
function ty(t, e, n) {
  const r = xe(t);
  if (r.isPrimaryClient && n === 0 || !r.isPrimaryClient && n === 1) {
    const i = [];
    r.Fa.forEach((s, o) => {
      const a = o.view.Z_(e);
      a.snapshot && i.push(a.snapshot);
    }), function(o, a) {
      const l = xe(o);
      l.onlineState = a;
      let u = !1;
      l.queries.forEach((d, f) => {
        for (const p of f.j_)
          p.Z_(a) && (u = !0);
      }), u && xh(l);
    }(r.eventManager, e), i.length && r.Ca.d_(i), r.onlineState = e, r.isPrimaryClient && r.sharedClientState.setOnlineState(e);
  }
}
async function FP(t, e, n) {
  const r = xe(t);
  r.sharedClientState.updateQueryState(e, "rejected", n);
  const i = r.Na.get(e), s = i && i.key;
  if (s) {
    let o = new Tt(ve.comparator);
    o = o.insert(s, an.newNoDocument(s, Pe.min()));
    const a = qe().add(s), l = new Il(
      Pe.min(),
      /* targetChanges= */
      /* @__PURE__ */ new Map(),
      /* targetMismatches= */
      new Tt(Xe),
      o,
      a
    );
    await tw(r, l), // Since this query failed, we won't want to manually unlisten to it.
    // We only remove it from bookkeeping after we successfully applied the
    // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to
    // this query when the RemoteStore restarts the Watch stream, which should
    // re-trigger the target failure.
    r.Oa = r.Oa.remove(s), r.Na.delete(e), Dh(r);
  } else await Qd(
    r.localStore,
    e,
    /* keepPersistedTargetData */
    !1
  ).then(() => Zd(r, e, n)).catch(ba);
}
async function VP(t, e) {
  const n = xe(t), r = e.batch.batchId;
  try {
    const i = await QO(n.localStore, e);
    rw(
      n,
      r,
      /*error=*/
      null
    ), nw(n, r), n.sharedClientState.updateMutationState(r, "acknowledged"), await Ia(n, i);
  } catch (i) {
    await ba(i);
  }
}
async function BP(t, e, n) {
  const r = xe(t);
  try {
    const i = await function(o, a) {
      const l = xe(o);
      return l.persistence.runTransaction("Reject batch", "readwrite-primary", (u) => {
        let d;
        return l.mutationQueue.lookupMutationBatch(u, a).next((f) => (it(f !== null), d = f.keys(), l.mutationQueue.removeMutationBatch(u, f))).next(() => l.mutationQueue.performConsistencyCheck(u)).next(() => l.documentOverlayCache.removeOverlaysForBatchId(u, d, a)).next(() => l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(u, d)).next(() => l.localDocuments.getDocuments(u, d));
      });
    }(r.localStore, e);
    rw(r, e, n), nw(r, e), r.sharedClientState.updateMutationState(e, "rejected", n), await Ia(r, i);
  } catch (i) {
    await ba(i);
  }
}
function nw(t, e) {
  (t.ka.get(e) || []).forEach((n) => {
    n.resolve();
  }), t.ka.delete(e);
}
function rw(t, e, n) {
  const r = xe(t);
  let i = r.Ba[r.currentUser.toKey()];
  if (i) {
    const s = i.get(e);
    s && (n ? s.reject(n) : s.resolve(), i = i.remove(e)), r.Ba[r.currentUser.toKey()] = i;
  }
}
function Zd(t, e, n = null) {
  t.sharedClientState.removeLocalQueryTarget(e);
  for (const r of t.Ma.get(e)) t.Fa.delete(r), n && t.Ca.$a(r, n);
  t.Ma.delete(e), t.isPrimaryClient && t.La.gr(e).forEach((r) => {
    t.La.containsKey(r) || // We removed the last reference for this key
    iw(t, r);
  });
}
function iw(t, e) {
  t.xa.delete(e.path.canonicalString());
  const n = t.Oa.get(e);
  n !== null && (Sh(t.remoteStore, n), t.Oa = t.Oa.remove(e), t.Na.delete(n), Dh(t));
}
function ny(t, e, n) {
  for (const r of n) r instanceof JE ? (t.La.addReference(r.key, e), $P(t, r)) : r instanceof ZE ? (fe("SyncEngine", "Document no longer in limbo: " + r.key), t.La.removeReference(r.key, e), t.La.containsKey(r.key) || // We removed the last reference for this key
  iw(t, r.key)) : Ne();
}
function $P(t, e) {
  const n = e.key, r = n.path.canonicalString();
  t.Oa.get(n) || t.xa.has(r) || (fe("SyncEngine", "New document in limbo: " + n), t.xa.add(r), Dh(t));
}
function Dh(t) {
  for (; t.xa.size > 0 && t.Oa.size < t.maxConcurrentLimboResolutions; ) {
    const e = t.xa.values().next().value;
    t.xa.delete(e);
    const n = new ve(mt.fromString(e)), r = t.qa.next();
    t.Na.set(r, new NP(n)), t.Oa = t.Oa.insert(n, r), GE(t.remoteStore, new pi(yr(bl(n.path)), r, "TargetPurposeLimboResolution", dh.oe));
  }
}
async function Ia(t, e, n) {
  const r = xe(t), i = [], s = [], o = [];
  r.Fa.isEmpty() || (r.Fa.forEach((a, l) => {
    o.push(r.Ka(l, e, n).then((u) => {
      var d;
      if ((u || n) && r.isPrimaryClient) {
        const f = u ? !u.fromCache : (d = n == null ? void 0 : n.targetChanges.get(l.targetId)) === null || d === void 0 ? void 0 : d.current;
        r.sharedClientState.updateQueryState(l.targetId, f ? "current" : "not-current");
      }
      if (u) {
        i.push(u);
        const f = Ih.Wi(l.targetId, u);
        s.push(f);
      }
    }));
  }), await Promise.all(o), r.Ca.d_(i), await async function(l, u) {
    const d = xe(l);
    try {
      await d.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (f) => W.forEach(u, (p) => W.forEach(p.$i, (g) => d.persistence.referenceDelegate.addReference(f, p.targetId, g)).next(() => W.forEach(p.Ui, (g) => d.persistence.referenceDelegate.removeReference(f, p.targetId, g)))));
    } catch (f) {
      if (!va(f)) throw f;
      fe("LocalStore", "Failed to update sequence numbers: " + f);
    }
    for (const f of u) {
      const p = f.targetId;
      if (!f.fromCache) {
        const g = d.os.get(p), _ = g.snapshotVersion, b = g.withLastLimboFreeSnapshotVersion(_);
        d.os = d.os.insert(p, b);
      }
    }
  }(r.localStore, s));
}
async function jP(t, e) {
  const n = xe(t);
  if (!n.currentUser.isEqual(e)) {
    fe("SyncEngine", "User change. New user:", e.toKey());
    const r = await jE(n.localStore, e);
    n.currentUser = e, // Fails tasks waiting for pending writes requested by previous user.
    function(s, o) {
      s.ka.forEach((a) => {
        a.forEach((l) => {
          l.reject(new ne(j.CANCELLED, o));
        });
      }), s.ka.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), // TODO(b/114226417): Consider calling this only in the primary tab.
    n.sharedClientState.handleUserChange(e, r.removedBatchIds, r.addedBatchIds), await Ia(n, r.hs);
  }
}
function qP(t, e) {
  const n = xe(t), r = n.Na.get(e);
  if (r && r.va) return qe().add(r.key);
  {
    let i = qe();
    const s = n.Ma.get(e);
    if (!s) return i;
    for (const o of s) {
      const a = n.Fa.get(o);
      i = i.unionWith(a.view.Va);
    }
    return i;
  }
}
function sw(t) {
  const e = xe(t);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = tw.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = qP.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = FP.bind(null, e), e.Ca.d_ = AP.bind(null, e.eventManager), e.Ca.$a = RP.bind(null, e.eventManager), e;
}
function zP(t) {
  const e = xe(t);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = VP.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = BP.bind(null, e), e;
}
class Wc {
  constructor() {
    this.kind = "memory", this.synchronizeTabs = !1;
  }
  async initialize(e) {
    this.serializer = Sl(e.databaseInfo.databaseId), this.sharedClientState = this.Wa(e), this.persistence = this.Ga(e), await this.persistence.start(), this.localStore = this.za(e), this.gcScheduler = this.ja(e, this.localStore), this.indexBackfillerScheduler = this.Ha(e, this.localStore);
  }
  ja(e, n) {
    return null;
  }
  Ha(e, n) {
    return null;
  }
  za(e) {
    return XO(this.persistence, new KO(), e.initialUser, this.serializer);
  }
  Ga(e) {
    return new WO(Th.Zr, this.serializer);
  }
  Wa(e) {
    return new rP();
  }
  async terminate() {
    var e, n;
    (e = this.gcScheduler) === null || e === void 0 || e.stop(), (n = this.indexBackfillerScheduler) === null || n === void 0 || n.stop(), this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
}
Wc.provider = {
  build: () => new Wc()
};
class ef {
  async initialize(e, n) {
    this.localStore || (this.localStore = e.localStore, this.sharedClientState = e.sharedClientState, this.datastore = this.createDatastore(n), this.remoteStore = this.createRemoteStore(n), this.eventManager = this.createEventManager(n), this.syncEngine = this.createSyncEngine(
      n,
      /* startAsPrimary=*/
      !e.synchronizeTabs
    ), this.sharedClientState.onlineStateHandler = (r) => ty(
      this.syncEngine,
      r,
      1
      /* OnlineStateSource.SharedClientState */
    ), this.remoteStore.remoteSyncer.handleCredentialChange = jP.bind(null, this.syncEngine), await TP(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(e) {
    return function() {
      return new SP();
    }();
  }
  createDatastore(e) {
    const n = Sl(e.databaseInfo.databaseId), r = function(s) {
      return new aP(s);
    }(e.databaseInfo);
    return function(s, o, a, l) {
      return new uP(s, o, a, l);
    }(e.authCredentials, e.appCheckCredentials, r, n);
  }
  createRemoteStore(e) {
    return function(r, i, s, o, a) {
      return new fP(r, i, s, o, a);
    }(this.localStore, this.datastore, e.asyncQueue, (n) => ty(
      this.syncEngine,
      n,
      0
      /* OnlineStateSource.RemoteStore */
    ), function() {
      return Xg.D() ? new Xg() : new iP();
    }());
  }
  createSyncEngine(e, n) {
    return function(i, s, o, a, l, u, d) {
      const f = new OP(i, s, o, a, l, u);
      return d && (f.Qa = !0), f;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, n);
  }
  async terminate() {
    var e, n;
    await async function(i) {
      const s = xe(i);
      fe("RemoteStore", "RemoteStore shutting down."), s.L_.add(
        5
        /* OfflineCause.Shutdown */
      ), await Ta(s), s.k_.shutdown(), // Set the OnlineState to Unknown (rather than Offline) to avoid potentially
      // triggering spurious listener events with cached data, etc.
      s.q_.set(
        "Unknown"
        /* OnlineState.Unknown */
      );
    }(this.remoteStore), (e = this.datastore) === null || e === void 0 || e.terminate(), (n = this.eventManager) === null || n === void 0 || n.terminate();
  }
}
ef.provider = {
  build: () => new ef()
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lh {
  constructor(e) {
    this.observer = e, /**
    * When set to true, will not raise future events. Necessary to deal with
    * async detachment of listener.
    */
    this.muted = !1;
  }
  next(e) {
    this.muted || this.observer.next && this.Ya(this.observer.next, e);
  }
  error(e) {
    this.muted || (this.observer.error ? this.Ya(this.observer.error, e) : Yr("Uncaught Error in snapshot listener:", e.toString()));
  }
  Za() {
    this.muted = !0;
  }
  Ya(e, n) {
    setTimeout(() => {
      this.muted || e(n);
    }, 0);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WP {
  constructor(e, n, r, i, s) {
    this.authCredentials = e, this.appCheckCredentials = n, this.asyncQueue = r, this.databaseInfo = i, this.user = on.UNAUTHENTICATED, this.clientId = uE.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this._uninitializedComponentsProvider = s, this.authCredentials.start(r, async (o) => {
      fe("FirestoreClient", "Received user=", o.uid), await this.authCredentialListener(o), this.user = o;
    }), this.appCheckCredentials.start(r, (o) => (fe("FirestoreClient", "Received new app check token=", o), this.appCheckCredentialListener(o, this.user)));
  }
  get configuration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(e) {
    this.authCredentialListener = e;
  }
  setAppCheckTokenChangeListener(e) {
    this.appCheckCredentialListener = e;
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const e = new jr();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), // The credentials provider must be terminated after shutting down the
        // RemoteStore as it will prevent the RemoteStore from retrieving auth
        // tokens.
        this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e.resolve();
      } catch (n) {
        const r = Nh(n, "Failed to shutdown persistence");
        e.reject(r);
      }
    }), e.promise;
  }
}
async function _u(t, e) {
  t.asyncQueue.verifyOperationInProgress(), fe("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = t.configuration;
  await e.initialize(n);
  let r = n.initialUser;
  t.setCredentialChangeListener(async (i) => {
    r.isEqual(i) || (await jE(e.localStore, i), r = i);
  }), // When a user calls clearPersistence() in one client, all other clients
  // need to be terminated to allow the delete to succeed.
  e.persistence.setDatabaseDeletedListener(() => t.terminate()), t._offlineComponents = e;
}
async function ry(t, e) {
  t.asyncQueue.verifyOperationInProgress();
  const n = await GP(t);
  fe("FirestoreClient", "Initializing OnlineComponentProvider"), await e.initialize(n, t.configuration), // The CredentialChangeListener of the online component provider takes
  // precedence over the offline component provider.
  t.setCredentialChangeListener((r) => Qg(e.remoteStore, r)), t.setAppCheckTokenChangeListener((r, i) => Qg(e.remoteStore, i)), t._onlineComponents = e;
}
async function GP(t) {
  if (!t._offlineComponents) if (t._uninitializedComponentsProvider) {
    fe("FirestoreClient", "Using user provided OfflineComponentProvider");
    try {
      await _u(t, t._uninitializedComponentsProvider._offline);
    } catch (e) {
      const n = e;
      if (!function(i) {
        return i.name === "FirebaseError" ? i.code === j.FAILED_PRECONDITION || i.code === j.UNIMPLEMENTED : !(typeof DOMException < "u" && i instanceof DOMException) || // When the browser is out of quota we could get either quota exceeded
        // or an aborted error depending on whether the error happened during
        // schema migration.
        i.code === 22 || i.code === 20 || // Firefox Private Browsing mode disables IndexedDb and returns
        // INVALID_STATE for any usage.
        i.code === 11;
      }(n)) throw n;
      Ks("Error using user provided cache. Falling back to memory cache: " + n), await _u(t, new Wc());
    }
  } else fe("FirestoreClient", "Using default OfflineComponentProvider"), await _u(t, new Wc());
  return t._offlineComponents;
}
async function ow(t) {
  return t._onlineComponents || (t._uninitializedComponentsProvider ? (fe("FirestoreClient", "Using user provided OnlineComponentProvider"), await ry(t, t._uninitializedComponentsProvider._online)) : (fe("FirestoreClient", "Using default OnlineComponentProvider"), await ry(t, new ef()))), t._onlineComponents;
}
function HP(t) {
  return ow(t).then((e) => e.syncEngine);
}
async function Gc(t) {
  const e = await ow(t), n = e.eventManager;
  return n.onListen = PP.bind(null, e.syncEngine), n.onUnlisten = DP.bind(null, e.syncEngine), n.onFirstRemoteStoreListen = xP.bind(null, e.syncEngine), n.onLastRemoteStoreUnlisten = LP.bind(null, e.syncEngine), n;
}
function KP(t, e, n = {}) {
  const r = new jr();
  return t.asyncQueue.enqueueAndForget(async () => function(s, o, a, l, u) {
    const d = new Lh({
      next: (p) => {
        d.Za(), o.enqueueAndForget(() => Ph(s, f));
        const g = p.docs.has(a);
        !g && p.fromCache ? (
          // TODO(dimond): If we're online and the document doesn't
          // exist then we resolve with a doc.exists set to false. If
          // we're offline however, we reject the Promise in this
          // case. Two options: 1) Cache the negative response from
          // the server so we can deliver that even when you're
          // offline 2) Actually reject the Promise in the online case
          // if the document doesn't exist.
          u.reject(new ne(j.UNAVAILABLE, "Failed to get document because the client is offline."))
        ) : g && p.fromCache && l && l.source === "server" ? u.reject(new ne(j.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : u.resolve(p);
      },
      error: (p) => u.reject(p)
    }), f = new Mh(bl(a.path), d, {
      includeMetadataChanges: !0,
      _a: !0
    });
    return Oh(s, f);
  }(await Gc(t), t.asyncQueue, e, n, r)), r.promise;
}
function YP(t, e, n = {}) {
  const r = new jr();
  return t.asyncQueue.enqueueAndForget(async () => function(s, o, a, l, u) {
    const d = new Lh({
      next: (p) => {
        d.Za(), o.enqueueAndForget(() => Ph(s, f)), p.fromCache && l.source === "server" ? u.reject(new ne(j.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : u.resolve(p);
      },
      error: (p) => u.reject(p)
    }), f = new Mh(a, d, {
      includeMetadataChanges: !0,
      _a: !0
    });
    return Oh(s, f);
  }(await Gc(t), t.asyncQueue, e, n, r)), r.promise;
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function aw(t) {
  const e = {};
  return t.timeoutSeconds !== void 0 && (e.timeoutSeconds = t.timeoutSeconds), e;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const iy = /* @__PURE__ */ new Map();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cw(t, e, n) {
  if (!n) throw new ne(j.INVALID_ARGUMENT, `Function ${t}() cannot be called with an empty ${e}.`);
}
function XP(t, e, n, r) {
  if (e === !0 && r === !0) throw new ne(j.INVALID_ARGUMENT, `${t} and ${n} cannot be used together.`);
}
function sy(t) {
  if (!ve.isDocumentKey(t)) throw new ne(j.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`);
}
function oy(t) {
  if (ve.isDocumentKey(t)) throw new ne(j.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`);
}
function Cl(t) {
  if (t === void 0) return "undefined";
  if (t === null) return "null";
  if (typeof t == "string") return t.length > 20 && (t = `${t.substring(0, 20)}...`), JSON.stringify(t);
  if (typeof t == "number" || typeof t == "boolean") return "" + t;
  if (typeof t == "object") {
    if (t instanceof Array) return "an array";
    {
      const e = (
        /** try to get the constructor name for an object. */
        function(r) {
          return r.constructor ? r.constructor.name : null;
        }(t)
      );
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t == "function" ? "a function" : Ne();
}
function tr(t, e) {
  if ("_delegate" in t && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (t = t._delegate), !(t instanceof e)) {
    if (e.name === t.constructor.name) throw new ne(j.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = Cl(t);
      throw new ne(j.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t;
}
function QP(t, e) {
  if (e <= 0) throw new ne(j.INVALID_ARGUMENT, `Function ${t}() requires a positive number, but it was: ${e}.`);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ay {
  constructor(e) {
    var n, r;
    if (e.host === void 0) {
      if (e.ssl !== void 0) throw new ne(j.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = !0;
    } else this.host = e.host, this.ssl = (n = e.ssl) === null || n === void 0 || n;
    if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, this.localCache = e.localCache, e.cacheSizeBytes === void 0) this.cacheSizeBytes = 41943040;
    else {
      if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576) throw new ne(j.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = e.cacheSizeBytes;
    }
    XP("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : e.experimentalAutoDetectLongPolling === void 0 ? this.experimentalAutoDetectLongPolling = !0 : (
      // For backwards compatibility, coerce the value to boolean even though
      // the TypeScript compiler has narrowed the type to boolean already.
      // noinspection PointlessBooleanExpressionJS
      this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling
    ), this.experimentalLongPollingOptions = aw((r = e.experimentalLongPollingOptions) !== null && r !== void 0 ? r : {}), function(s) {
      if (s.timeoutSeconds !== void 0) {
        if (isNaN(s.timeoutSeconds)) throw new ne(j.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (must not be NaN)`);
        if (s.timeoutSeconds < 5) throw new ne(j.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (minimum allowed value is 5)`);
        if (s.timeoutSeconds > 30) throw new ne(j.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (maximum allowed value is 30)`);
      }
    }(this.experimentalLongPollingOptions), this.useFetchStreams = !!e.useFetchStreams;
  }
  isEqual(e) {
    return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && function(r, i) {
      return r.timeoutSeconds === i.timeoutSeconds;
    }(this.experimentalLongPollingOptions, e.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams;
  }
}
class kl {
  /** @hideconstructor */
  constructor(e, n, r, i) {
    this._authCredentials = e, this._appCheckCredentials = n, this._databaseId = r, this._app = i, /**
    * Whether it's a Firestore or Firestore Lite instance.
    */
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new ay({}), this._settingsFrozen = !1, // A task that is assigned when the terminate() is invoked and resolved when
    // all components have shut down. Otherwise, Firestore is not terminated,
    // which can mean either the FirestoreClient is in the process of starting,
    // or restarting.
    this._terminateTask = "notTerminated";
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app) throw new ne(j.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== "notTerminated";
  }
  _setSettings(e) {
    if (this._settingsFrozen) throw new ne(j.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new ay(e), e.credentials !== void 0 && (this._authCredentials = function(r) {
      if (!r) return new pN();
      switch (r.type) {
        case "firstParty":
          return new _N(r.sessionIndex || "0", r.iamToken || null, r.authTokenFactory || null);
        case "provider":
          return r.client;
        default:
          throw new ne(j.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(e.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = !0, this._settings;
  }
  _delete() {
    return this._terminateTask === "notTerminated" && (this._terminateTask = this._terminate()), this._terminateTask;
  }
  async _restart() {
    this._terminateTask === "notTerminated" ? await this._terminate() : this._terminateTask = "notTerminated";
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return function(n) {
      const r = iy.get(n);
      r && (fe("ComponentProvider", "Removing Datastore"), iy.delete(n), r.terminate());
    }(this), Promise.resolve();
  }
}
function JP(t, e, n, r = {}) {
  var i;
  const s = (t = tr(t, kl))._getSettings(), o = `${e}:${n}`;
  if (s.host !== "firestore.googleapis.com" && s.host !== o && Ks("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), t._setSettings(Object.assign(Object.assign({}, s), {
    host: o,
    ssl: !1
  })), r.mockUserToken) {
    let a, l;
    if (typeof r.mockUserToken == "string") a = r.mockUserToken, l = on.MOCK_USER;
    else {
      a = vv(r.mockUserToken, (i = t._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const u = r.mockUserToken.sub || r.mockUserToken.user_id;
      if (!u) throw new ne(j.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      l = new on(u);
    }
    t._authCredentials = new mN(new lE(a, l));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Tr {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(e, n, r) {
    this.converter = n, this._query = r, /** The type of this Firestore reference. */
    this.type = "query", this.firestore = e;
  }
  withConverter(e) {
    return new Tr(this.firestore, e, this._query);
  }
}
class gn {
  /** @hideconstructor */
  constructor(e, n, r) {
    this.converter = n, this._key = r, /** The type of this Firestore reference. */
    this.type = "document", this.firestore = e;
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new _i(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(e) {
    return new gn(this.firestore, e, this._key);
  }
}
class _i extends Tr {
  /** @hideconstructor */
  constructor(e, n, r) {
    super(e, n, bl(r)), this._path = r, /** The type of this Firestore reference. */
    this.type = "collection";
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const e = this._path.popLast();
    return e.isEmpty() ? null : new gn(
      this.firestore,
      /* converter= */
      null,
      new ve(e)
    );
  }
  withConverter(e) {
    return new _i(this.firestore, e, this._path);
  }
}
function $B(t, e, ...n) {
  if (t = st(t), cw("collection", "path", e), t instanceof kl) {
    const r = mt.fromString(e, ...n);
    return oy(r), new _i(
      t,
      /* converter= */
      null,
      r
    );
  }
  {
    if (!(t instanceof gn || t instanceof _i)) throw new ne(j.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = t._path.child(mt.fromString(e, ...n));
    return oy(r), new _i(
      t.firestore,
      /* converter= */
      null,
      r
    );
  }
}
function jB(t, e, ...n) {
  if (t = st(t), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  arguments.length === 1 && (e = uE.newId()), cw("doc", "path", e), t instanceof kl) {
    const r = mt.fromString(e, ...n);
    return sy(r), new gn(
      t,
      /* converter= */
      null,
      new ve(r)
    );
  }
  {
    if (!(t instanceof gn || t instanceof _i)) throw new ne(j.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = t._path.child(mt.fromString(e, ...n));
    return sy(r), new gn(t.firestore, t instanceof _i ? t.converter : null, new ve(r));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cy {
  constructor(e = Promise.resolve()) {
    this.Pu = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
    // be changed again.
    this.Iu = !1, // Operations scheduled to be queued in the future. Operations are
    // automatically removed after they are run or canceled.
    this.Tu = [], // visible for testing
    this.Eu = null, // Flag set while there's an outstanding AsyncQueue operation, used for
    // assertion sanity-checks.
    this.du = !1, // Enabled during shutdown on Safari to prevent future access to IndexedDB.
    this.Au = !1, // List of TimerIds to fast-forward delays for.
    this.Ru = [], // Backoff timer used to schedule retries for retryable operations
    this.t_ = new zE(
      this,
      "async_queue_retry"
      /* TimerId.AsyncQueueRetry */
    ), // Visibility handler that triggers an immediate retry of all retryable
    // operations. Meant to speed up recovery when we regain file system access
    // after page comes into foreground.
    this.Vu = () => {
      const r = yu();
      r && fe("AsyncQueue", "Visibility state changed to " + r.visibilityState), this.t_.jo();
    }, this.mu = e;
    const n = yu();
    n && typeof n.addEventListener == "function" && n.addEventListener("visibilitychange", this.Vu);
  }
  get isShuttingDown() {
    return this.Iu;
  }
  /**
   * Adds a new operation to the queue without waiting for it to complete (i.e.
   * we ignore the Promise result).
   */
  enqueueAndForget(e) {
    this.enqueue(e);
  }
  enqueueAndForgetEvenWhileRestricted(e) {
    this.fu(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.gu(e);
  }
  enterRestrictedMode(e) {
    if (!this.Iu) {
      this.Iu = !0, this.Au = e || !1;
      const n = yu();
      n && typeof n.removeEventListener == "function" && n.removeEventListener("visibilitychange", this.Vu);
    }
  }
  enqueue(e) {
    if (this.fu(), this.Iu)
      return new Promise(() => {
      });
    const n = new jr();
    return this.gu(() => this.Iu && this.Au ? Promise.resolve() : (e().then(n.resolve, n.reject), n.promise)).then(() => n.promise);
  }
  enqueueRetryable(e) {
    this.enqueueAndForget(() => (this.Pu.push(e), this.pu()));
  }
  /**
   * Runs the next operation from the retryable queue. If the operation fails,
   * reschedules with backoff.
   */
  async pu() {
    if (this.Pu.length !== 0) {
      try {
        await this.Pu[0](), this.Pu.shift(), this.t_.reset();
      } catch (e) {
        if (!va(e)) throw e;
        fe("AsyncQueue", "Operation failed with retryable error: " + e);
      }
      this.Pu.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
      // This is necessary to run retryable operations that failed during
      // their initial attempt since we don't know whether they are already
      // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
      // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
      // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
      // call scheduled here.
      // Since `backoffAndRun()` cancels an existing backoff and schedules a
      // new backoff on every call, there is only ever a single additional
      // operation in the queue.
      this.t_.Go(() => this.pu());
    }
  }
  gu(e) {
    const n = this.mu.then(() => (this.du = !0, e().catch((r) => {
      this.Eu = r, this.du = !1;
      const i = (
        /**
        * Chrome includes Error.message in Error.stack. Other browsers do not.
        * This returns expected output of message + stack when available.
        * @param error - Error or FirestoreError
        */
        function(o) {
          let a = o.message || "";
          return o.stack && (a = o.stack.includes(o.message) ? o.stack : o.message + `
` + o.stack), a;
        }(r)
      );
      throw Yr("INTERNAL UNHANDLED ERROR: ", i), r;
    }).then((r) => (this.du = !1, r))));
    return this.mu = n, n;
  }
  enqueueAfterDelay(e, n, r) {
    this.fu(), // Fast-forward delays for timerIds that have been overridden.
    this.Ru.indexOf(e) > -1 && (n = 0);
    const i = kh.createAndSchedule(this, e, n, r, (s) => this.yu(s));
    return this.Tu.push(i), i;
  }
  fu() {
    this.Eu && Ne();
  }
  verifyOperationInProgress() {
  }
  /**
   * Waits until all currently queued tasks are finished executing. Delayed
   * operations are not run.
   */
  async wu() {
    let e;
    do
      e = this.mu, await e;
    while (e !== this.mu);
  }
  /**
   * For Tests: Determine if a delayed operation with a particular TimerId
   * exists.
   */
  Su(e) {
    for (const n of this.Tu) if (n.timerId === e) return !0;
    return !1;
  }
  /**
   * For Tests: Runs some or all delayed operations early.
   *
   * @param lastTimerId - Delayed operations up to and including this TimerId
   * will be drained. Pass TimerId.All to run all delayed operations.
   * @returns a Promise that resolves once all operations have been run.
   */
  bu(e) {
    return this.wu().then(() => {
      this.Tu.sort((n, r) => n.targetTimeMs - r.targetTimeMs);
      for (const n of this.Tu) if (n.skipDelay(), e !== "all" && n.timerId === e) break;
      return this.wu();
    });
  }
  /**
   * For Tests: Skip all subsequent delays for a timer id.
   */
  Du(e) {
    this.Ru.push(e);
  }
  /** Called once a DelayedOperation is run or canceled. */
  yu(e) {
    const n = this.Tu.indexOf(e);
    this.Tu.splice(n, 1);
  }
}
function ly(t) {
  return function(n, r) {
    if (typeof n != "object" || n === null) return !1;
    const i = n;
    for (const s of r) if (s in i && typeof i[s] == "function") return !0;
    return !1;
  }(t, ["next", "error", "complete"]);
}
class rs extends kl {
  /** @hideconstructor */
  constructor(e, n, r, i) {
    super(e, n, r, i), /**
    * Whether it's a {@link Firestore} or Firestore Lite instance.
    */
    this.type = "firestore", this._queue = new cy(), this._persistenceKey = (i == null ? void 0 : i.name) || "[DEFAULT]";
  }
  async _terminate() {
    if (this._firestoreClient) {
      const e = this._firestoreClient.terminate();
      this._queue = new cy(e), this._firestoreClient = void 0, await e;
    }
  }
}
function qB(t, e) {
  const n = typeof t == "object" ? t : fl(), r = typeof t == "string" ? t : "(default)", i = ga(n, "firestore").getImmediate({
    identifier: r
  });
  if (!i._initialized) {
    const s = Xf("firestore");
    s && JP(i, ...s);
  }
  return i;
}
function Nl(t) {
  if (t._terminated) throw new ne(j.FAILED_PRECONDITION, "The client has already been terminated.");
  return t._firestoreClient || ZP(t), t._firestoreClient;
}
function ZP(t) {
  var e, n, r;
  const i = t._freezeSettings(), s = function(a, l, u, d) {
    return new ON(a, l, u, d.host, d.ssl, d.experimentalForceLongPolling, d.experimentalAutoDetectLongPolling, aw(d.experimentalLongPollingOptions), d.useFetchStreams);
  }(t._databaseId, ((e = t._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t._persistenceKey, i);
  t._componentsProvider || !((n = i.localCache) === null || n === void 0) && n._offlineComponentProvider && (!((r = i.localCache) === null || r === void 0) && r._onlineComponentProvider) && (t._componentsProvider = {
    _offline: i.localCache._offlineComponentProvider,
    _online: i.localCache._onlineComponentProvider
  }), t._firestoreClient = new WP(t._authCredentials, t._appCheckCredentials, t._queue, s, t._componentsProvider && function(a) {
    const l = a == null ? void 0 : a._online.build();
    return {
      _offline: a == null ? void 0 : a._offline.build(l),
      _online: l
    };
  }(t._componentsProvider));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class to {
  /** @hideconstructor */
  constructor(e) {
    this._byteString = e;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(e) {
    try {
      return new to(Qt.fromBase64String(e));
    } catch (n) {
      throw new ne(j.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + n);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(e) {
    return new to(Qt.fromUint8Array(e));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(e) {
    return this._byteString.isEqual(e._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Uh {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...e) {
    for (let n = 0; n < e.length; ++n) if (e[n].length === 0) throw new ne(j.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new Ht(e);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(e) {
    return this._internalPath.isEqual(e._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lw {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(e) {
    this._methodName = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fh {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(e, n) {
    if (!isFinite(e) || e < -90 || e > 90) throw new ne(j.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e);
    if (!isFinite(n) || n < -180 || n > 180) throw new ne(j.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + n);
    this._lat = e, this._long = n;
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(e) {
    return this._lat === e._lat && this._long === e._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(e) {
    return Xe(this._lat, e._lat) || Xe(this._long, e._long);
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vh {
  /**
   * @private
   * @internal
   */
  constructor(e) {
    this._values = (e || []).map((n) => n);
  }
  /**
   * Returns a copy of the raw number array form of the vector.
   */
  toArray() {
    return this._values.map((e) => e);
  }
  /**
   * Returns `true` if the two VectorValue has the same raw number arrays, returns `false` otherwise.
   */
  isEqual(e) {
    return function(r, i) {
      if (r.length !== i.length) return !1;
      for (let s = 0; s < r.length; ++s) if (r[s] !== i[s]) return !1;
      return !0;
    }(this._values, e._values);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ex = /^__.*__$/;
class tx {
  constructor(e, n, r) {
    this.data = e, this.fieldMask = n, this.fieldTransforms = r;
  }
  toMutation(e, n) {
    return this.fieldMask !== null ? new ds(e, this.data, this.fieldMask, n, this.fieldTransforms) : new Ea(e, this.data, n, this.fieldTransforms);
  }
}
function uw(t) {
  switch (t) {
    case 0:
    // fall through
    case 2:
    // fall through
    case 1:
      return !0;
    case 3:
    case 4:
      return !1;
    default:
      throw Ne();
  }
}
class Bh {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(e, n, r, i, s, o) {
    this.settings = e, this.databaseId = n, this.serializer = r, this.ignoreUndefinedProperties = i, // Minor hack: If fieldTransforms is undefined, we assume this is an
    // external call and we need to validate the entire path.
    s === void 0 && this.vu(), this.fieldTransforms = s || [], this.fieldMask = o || [];
  }
  get path() {
    return this.settings.path;
  }
  get Cu() {
    return this.settings.Cu;
  }
  /** Returns a new context with the specified settings overwritten. */
  Fu(e) {
    return new Bh(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Mu(e) {
    var n;
    const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(e), i = this.Fu({
      path: r,
      xu: !1
    });
    return i.Ou(e), i;
  }
  Nu(e) {
    var n;
    const r = (n = this.path) === null || n === void 0 ? void 0 : n.child(e), i = this.Fu({
      path: r,
      xu: !1
    });
    return i.vu(), i;
  }
  Lu(e) {
    return this.Fu({
      path: void 0,
      xu: !0
    });
  }
  Bu(e) {
    return Hc(e, this.settings.methodName, this.settings.ku || !1, this.path, this.settings.qu);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(e) {
    return this.fieldMask.find((n) => e.isPrefixOf(n)) !== void 0 || this.fieldTransforms.find((n) => e.isPrefixOf(n.field)) !== void 0;
  }
  vu() {
    if (this.path) for (let e = 0; e < this.path.length; e++) this.Ou(this.path.get(e));
  }
  Ou(e) {
    if (e.length === 0) throw this.Bu("Document fields must not be empty");
    if (uw(this.Cu) && ex.test(e)) throw this.Bu('Document fields cannot begin and end with "__"');
  }
}
class nx {
  constructor(e, n, r) {
    this.databaseId = e, this.ignoreUndefinedProperties = n, this.serializer = r || Sl(e);
  }
  /** Creates a new top-level parse context. */
  Qu(e, n, r, i = !1) {
    return new Bh({
      Cu: e,
      methodName: n,
      qu: r,
      path: Ht.emptyPath(),
      xu: !1,
      ku: i
    }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
  }
}
function $h(t) {
  const e = t._freezeSettings(), n = Sl(t._databaseId);
  return new nx(t._databaseId, !!e.ignoreUndefinedProperties, n);
}
function rx(t, e, n, r, i, s = {}) {
  const o = t.Qu(s.merge || s.mergeFields ? 2 : 0, e, n, i);
  pw("Data must be an object, but it was:", o, r);
  const a = fw(r, o);
  let l, u;
  if (s.merge) l = new Qn(o.fieldMask), u = o.fieldTransforms;
  else if (s.mergeFields) {
    const d = [];
    for (const f of s.mergeFields) {
      const p = ix(e, f, n);
      if (!o.contains(p)) throw new ne(j.INVALID_ARGUMENT, `Field '${p}' is specified in your field mask but missing from your input data.`);
      ox(d, p) || d.push(p);
    }
    l = new Qn(d), u = o.fieldTransforms.filter((f) => l.covers(f.field));
  } else l = null, u = o.fieldTransforms;
  return new tx(new Vn(a), l, u);
}
function dw(t, e, n, r = !1) {
  return jh(n, t.Qu(r ? 4 : 3, e));
}
function jh(t, e) {
  if (hw(
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    t = st(t)
  )) return pw("Unsupported field value:", e, t), fw(t, e);
  if (t instanceof lw)
    return function(r, i) {
      if (!uw(i.Cu)) throw i.Bu(`${r._methodName}() can only be used with update() and set()`);
      if (!i.path) throw i.Bu(`${r._methodName}() is not currently supported inside arrays`);
      const s = r._toFieldTransform(i);
      s && i.fieldTransforms.push(s);
    }(t, e), null;
  if (t === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    e.path && e.fieldMask.push(e.path), t instanceof Array
  ) {
    if (e.settings.xu && e.Cu !== 4) throw e.Bu("Nested arrays are not supported");
    return function(r, i) {
      const s = [];
      let o = 0;
      for (const a of r) {
        let l = jh(a, i.Lu(o));
        l == null && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (l = {
          nullValue: "NULL_VALUE"
        }), s.push(l), o++;
      }
      return {
        arrayValue: {
          values: s
        }
      };
    }(t, e);
  }
  return function(r, i) {
    if ((r = st(r)) === null) return {
      nullValue: "NULL_VALUE"
    };
    if (typeof r == "number") return ZN(i.serializer, r);
    if (typeof r == "boolean") return {
      booleanValue: r
    };
    if (typeof r == "string") return {
      stringValue: r
    };
    if (r instanceof Date) {
      const s = Vt.fromDate(r);
      return {
        timestampValue: qc(i.serializer, s)
      };
    }
    if (r instanceof Vt) {
      const s = new Vt(r.seconds, 1e3 * Math.floor(r.nanoseconds / 1e3));
      return {
        timestampValue: qc(i.serializer, s)
      };
    }
    if (r instanceof Fh) return {
      geoPointValue: {
        latitude: r.latitude,
        longitude: r.longitude
      }
    };
    if (r instanceof to) return {
      bytesValue: DE(i.serializer, r._byteString)
    };
    if (r instanceof gn) {
      const s = i.databaseId, o = r.firestore._databaseId;
      if (!o.isEqual(s)) throw i.Bu(`Document reference is for database ${o.projectId}/${o.database} but should be for database ${s.projectId}/${s.database}`);
      return {
        referenceValue: Eh(r.firestore._databaseId || i.databaseId, r._key.path)
      };
    }
    if (r instanceof Vh)
      return function(o, a) {
        return {
          mapValue: {
            fields: {
              __type__: {
                stringValue: "__vector__"
              },
              value: {
                arrayValue: {
                  values: o.toArray().map((l) => {
                    if (typeof l != "number") throw a.Bu("VectorValues must only contain numeric values.");
                    return yh(a.serializer, l);
                  })
                }
              }
            }
          }
        };
      }(r, i);
    throw i.Bu(`Unsupported field value: ${Cl(r)}`);
  }(t, e);
}
function fw(t, e) {
  const n = {};
  return dE(t) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    e.path && e.path.length > 0 && e.fieldMask.push(e.path)
  ) : lo(t, (r, i) => {
    const s = jh(i, e.Mu(r));
    s != null && (n[r] = s);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function hw(t) {
  return !(typeof t != "object" || t === null || t instanceof Array || t instanceof Date || t instanceof Vt || t instanceof Fh || t instanceof to || t instanceof gn || t instanceof lw || t instanceof Vh);
}
function pw(t, e, n) {
  if (!hw(n) || !function(i) {
    return typeof i == "object" && i !== null && (Object.getPrototypeOf(i) === Object.prototype || Object.getPrototypeOf(i) === null);
  }(n)) {
    const r = Cl(n);
    throw r === "an object" ? e.Bu(t + " a custom object") : e.Bu(t + " " + r);
  }
}
function ix(t, e, n) {
  if (
    // If required, replace the FieldPath Compat class with the firestore-exp
    // FieldPath.
    (e = st(e)) instanceof Uh
  ) return e._internalPath;
  if (typeof e == "string") return mw(t, e);
  throw Hc(
    "Field path arguments must be of type string or ",
    t,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    n
  );
}
const sx = new RegExp("[~\\*/\\[\\]]");
function mw(t, e, n) {
  if (e.search(sx) >= 0) throw Hc(
    `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
    t,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    n
  );
  try {
    return new Uh(...e.split("."))._internalPath;
  } catch {
    throw Hc(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      t,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      n
    );
  }
}
function Hc(t, e, n, r, i) {
  const s = r && !r.isEmpty(), o = i !== void 0;
  let a = `Function ${e}() called with invalid data`;
  n && (a += " (via `toFirestore()`)"), a += ". ";
  let l = "";
  return (s || o) && (l += " (found", s && (l += ` in field ${r}`), o && (l += ` in document ${i}`), l += ")"), new ne(j.INVALID_ARGUMENT, a + t + l);
}
function ox(t, e) {
  return t.some((n) => n.isEqual(e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qh {
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(e, n, r, i, s) {
    this._firestore = e, this._userDataWriter = n, this._key = r, this._document = i, this._converter = s;
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new gn(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return this._document !== null;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (this._document) {
      if (this._converter) {
        const e = new ax(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(e);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(e) {
    if (this._document) {
      const n = this._document.data.field(Ol("DocumentSnapshot.get", e));
      if (n !== null) return this._userDataWriter.convertValue(n);
    }
  }
}
class ax extends qh {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
}
function Ol(t, e) {
  return typeof e == "string" ? mw(t, e) : e instanceof Uh ? e._internalPath : e._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function gw(t) {
  if (t.limitType === "L" && t.explicitOrderBy.length === 0) throw new ne(j.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
class zh {
}
class Pl extends zh {
}
function zB(t, e, ...n) {
  let r = [];
  e instanceof zh && r.push(e), r = r.concat(n), function(s) {
    const o = s.filter((l) => l instanceof ho).length, a = s.filter((l) => l instanceof Sa).length;
    if (o > 1 || o > 0 && a > 0) throw new ne(j.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.");
  }(r);
  for (const i of r) t = i._apply(t);
  return t;
}
class Sa extends Pl {
  /**
   * @internal
   */
  constructor(e, n, r) {
    super(), this._field = e, this._op = n, this._value = r, /** The type of this query constraint */
    this.type = "where";
  }
  static _create(e, n, r) {
    return new Sa(e, n, r);
  }
  _apply(e) {
    const n = this._parse(e);
    return yw(e._query, n), new Tr(e.firestore, e.converter, Gd(e._query, n));
  }
  _parse(e) {
    const n = $h(e.firestore);
    return function(s, o, a, l, u, d, f) {
      let p;
      if (u.isKeyField()) {
        if (d === "array-contains" || d === "array-contains-any") throw new ne(j.INVALID_ARGUMENT, `Invalid Query. You can't perform '${d}' queries on documentId().`);
        if (d === "in" || d === "not-in") {
          dy(f, d);
          const g = [];
          for (const _ of f) g.push(uy(l, s, _));
          p = {
            arrayValue: {
              values: g
            }
          };
        } else p = uy(l, s, f);
      } else d !== "in" && d !== "not-in" && d !== "array-contains-any" || dy(f, d), p = dw(
        a,
        o,
        f,
        /* allowArrays= */
        d === "in" || d === "not-in"
      );
      return Lt.create(u, d, p);
    }(e._query, "where", n, e.firestore._databaseId, this._field, this._op, this._value);
  }
}
function WB(t, e, n) {
  const r = e, i = Ol("where", t);
  return Sa._create(i, r, n);
}
class ho extends zh {
  /**
   * @internal
   */
  constructor(e, n) {
    super(), this.type = e, this._queryConstraints = n;
  }
  static _create(e, n) {
    return new ho(e, n);
  }
  _parse(e) {
    const n = this._queryConstraints.map((r) => r._parse(e)).filter((r) => r.getFilters().length > 0);
    return n.length === 1 ? n[0] : nr.create(n, this._getOperator());
  }
  _apply(e) {
    const n = this._parse(e);
    return n.getFilters().length === 0 ? e : (function(i, s) {
      let o = i;
      const a = s.getFlattenedFilters();
      for (const l of a) yw(o, l), o = Gd(o, l);
    }(e._query, n), new Tr(e.firestore, e.converter, Gd(e._query, n)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return this.type === "and" ? "and" : "or";
  }
}
function GB(...t) {
  return t.forEach((e) => _w("or", e)), ho._create("or", t);
}
function HB(...t) {
  return t.forEach((e) => _w("and", e)), ho._create("and", t);
}
class Wh extends Pl {
  /**
   * @internal
   */
  constructor(e, n) {
    super(), this._field = e, this._direction = n, /** The type of this query constraint */
    this.type = "orderBy";
  }
  static _create(e, n) {
    return new Wh(e, n);
  }
  _apply(e) {
    const n = function(i, s, o) {
      if (i.startAt !== null) throw new ne(j.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (i.endAt !== null) throw new ne(j.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      return new ia(s, o);
    }(e._query, this._field, this._direction);
    return new Tr(e.firestore, e.converter, function(i, s) {
      const o = i.explicitOrderBy.concat([s]);
      return new us(i.path, i.collectionGroup, o, i.filters.slice(), i.limit, i.limitType, i.startAt, i.endAt);
    }(e._query, n));
  }
}
function KB(t, e = "asc") {
  const n = e, r = Ol("orderBy", t);
  return Wh._create(r, n);
}
class Gh extends Pl {
  /**
   * @internal
   */
  constructor(e, n, r) {
    super(), this.type = e, this._limit = n, this._limitType = r;
  }
  static _create(e, n, r) {
    return new Gh(e, n, r);
  }
  _apply(e) {
    return new Tr(e.firestore, e.converter, Bc(e._query, this._limit, this._limitType));
  }
}
function YB(t) {
  return QP("limit", t), Gh._create(
    "limit",
    t,
    "F"
    /* LimitType.First */
  );
}
class Hh extends Pl {
  /**
   * @internal
   */
  constructor(e, n, r) {
    super(), this.type = e, this._docOrFields = n, this._inclusive = r;
  }
  static _create(e, n, r) {
    return new Hh(e, n, r);
  }
  _apply(e) {
    const n = cx(e, this.type, this._docOrFields, this._inclusive);
    return new Tr(e.firestore, e.converter, function(i, s) {
      return new us(i.path, i.collectionGroup, i.explicitOrderBy.slice(), i.filters.slice(), i.limit, i.limitType, s, i.endAt);
    }(e._query, n));
  }
}
function XB(...t) {
  return Hh._create(
    "startAfter",
    t,
    /*inclusive=*/
    !1
  );
}
function cx(t, e, n, r) {
  if (n[0] = st(n[0]), n[0] instanceof qh) return function(s, o, a, l, u) {
    if (!l) throw new ne(j.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${a}().`);
    const d = [];
    for (const f of Ls(s)) if (f.field.isKeyField()) d.push(Vc(o, l.key));
    else {
      const p = l.data.field(f.field);
      if (_l(p)) throw new ne(j.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + f.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
      if (p === null) {
        const g = f.field.canonicalString();
        throw new ne(j.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${g}' (used as the orderBy) does not exist.`);
      }
      d.push(p);
    }
    return new Js(d, u);
  }(t._query, t.firestore._databaseId, e, n[0]._document, r);
  {
    const i = $h(t.firestore);
    return function(o, a, l, u, d, f) {
      const p = o.explicitOrderBy;
      if (d.length > p.length) throw new ne(j.INVALID_ARGUMENT, `Too many arguments provided to ${u}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const g = [];
      for (let _ = 0; _ < d.length; _++) {
        const b = d[_];
        if (p[_].field.isKeyField()) {
          if (typeof b != "string") throw new ne(j.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${u}(), but got a ${typeof b}`);
          if (!gh(o) && b.indexOf("/") !== -1) throw new ne(j.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${u}() must be a plain document ID, but '${b}' contains a slash.`);
          const m = o.path.child(mt.fromString(b));
          if (!ve.isDocumentKey(m)) throw new ne(j.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${u}() must result in a valid document path, but '${m}' is not because it contains an odd number of segments.`);
          const v = new ve(m);
          g.push(Vc(a, v));
        } else {
          const m = dw(l, u, b);
          g.push(m);
        }
      }
      return new Js(g, f);
    }(t._query, t.firestore._databaseId, i, e, n, r);
  }
}
function uy(t, e, n) {
  if (typeof (n = st(n)) == "string") {
    if (n === "") throw new ne(j.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!gh(e) && n.indexOf("/") !== -1) throw new ne(j.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const r = e.path.child(mt.fromString(n));
    if (!ve.isDocumentKey(r)) throw new ne(j.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
    return Vc(t, new ve(r));
  }
  if (n instanceof gn) return Vc(t, n._key);
  throw new ne(j.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Cl(n)}.`);
}
function dy(t, e) {
  if (!Array.isArray(t) || t.length === 0) throw new ne(j.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
}
function yw(t, e) {
  const n = function(i, s) {
    for (const o of i) for (const a of o.getFlattenedFilters()) if (s.indexOf(a.op) >= 0) return a.op;
    return null;
  }(t.filters, function(i) {
    switch (i) {
      case "!=":
        return [
          "!=",
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "array-contains-any":
      case "in":
        return [
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "not-in":
        return [
          "array-contains-any",
          "in",
          "not-in",
          "!="
          /* Operator.NOT_EQUAL */
        ];
      default:
        return [];
    }
  }(e.op));
  if (n !== null)
    throw n === e.op ? new ne(j.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`) : new ne(j.INVALID_ARGUMENT, `Invalid query. You cannot use '${e.op.toString()}' filters with '${n.toString()}' filters.`);
}
function _w(t, e) {
  if (!(e instanceof Sa || e instanceof ho)) throw new ne(j.INVALID_ARGUMENT, `Function ${t}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);
}
class lx {
  convertValue(e, n = "none") {
    switch (ns(e)) {
      case 0:
        return null;
      case 1:
        return e.booleanValue;
      case 2:
        return Pt(e.integerValue || e.doubleValue);
      case 3:
        return this.convertTimestamp(e.timestampValue);
      case 4:
        return this.convertServerTimestamp(e, n);
      case 5:
        return e.stringValue;
      case 6:
        return this.convertBytes(ts(e.bytesValue));
      case 7:
        return this.convertReference(e.referenceValue);
      case 8:
        return this.convertGeoPoint(e.geoPointValue);
      case 9:
        return this.convertArray(e.arrayValue, n);
      case 11:
        return this.convertObject(e.mapValue, n);
      case 10:
        return this.convertVectorValue(e.mapValue);
      default:
        throw Ne();
    }
  }
  convertObject(e, n) {
    return this.convertObjectMap(e.fields, n);
  }
  /**
   * @internal
   */
  convertObjectMap(e, n = "none") {
    const r = {};
    return lo(e, (i, s) => {
      r[i] = this.convertValue(s, n);
    }), r;
  }
  /**
   * @internal
   */
  convertVectorValue(e) {
    var n, r, i;
    const s = (i = (r = (n = e.fields) === null || n === void 0 ? void 0 : n.value.arrayValue) === null || r === void 0 ? void 0 : r.values) === null || i === void 0 ? void 0 : i.map((o) => Pt(o.doubleValue));
    return new Vh(s);
  }
  convertGeoPoint(e) {
    return new Fh(Pt(e.latitude), Pt(e.longitude));
  }
  convertArray(e, n) {
    return (e.values || []).map((r) => this.convertValue(r, n));
  }
  convertServerTimestamp(e, n) {
    switch (n) {
      case "previous":
        const r = fh(e);
        return r == null ? null : this.convertValue(r, n);
      case "estimate":
        return this.convertTimestamp(ta(e));
      default:
        return null;
    }
  }
  convertTimestamp(e) {
    const n = wi(e);
    return new Vt(n.seconds, n.nanos);
  }
  convertDocumentKey(e, n) {
    const r = mt.fromString(e);
    it($E(r));
    const i = new na(r.get(1), r.get(3)), s = new ve(r.popFirst(5));
    return i.isEqual(n) || // TODO(b/64130202): Somehow support foreign references.
    Yr(`Document ${s} contains a document reference within a different database (${i.projectId}/${i.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`), s;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ux(t, e, n) {
  let r;
  return r = t ? n && (n.merge || n.mergeFields) ? t.toFirestore(e, n) : t.toFirestore(e) : e, r;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lo {
  /** @hideconstructor */
  constructor(e, n) {
    this.hasPendingWrites = e, this.fromCache = n;
  }
  /**
   * Returns true if this `SnapshotMetadata` is equal to the provided one.
   *
   * @param other - The `SnapshotMetadata` to compare against.
   * @returns true if this `SnapshotMetadata` is equal to the provided one.
   */
  isEqual(e) {
    return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache;
  }
}
class bw extends qh {
  /** @hideconstructor protected */
  constructor(e, n, r, i, s, o) {
    super(e, n, r, i, o), this._firestore = e, this._firestoreImpl = e, this.metadata = s;
  }
  /**
   * Returns whether or not the data exists. True if the document exists.
   */
  exists() {
    return super.exists();
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * By default, `serverTimestamp()` values that have not yet been
   * set to their final value will be returned as `null`. You can override
   * this by passing an options object.
   *
   * @param options - An options object to configure how data is retrieved from
   * the snapshot (for example the desired behavior for server timestamps that
   * have not yet been set to their final value).
   * @returns An `Object` containing all fields in the document or `undefined` if
   * the document doesn't exist.
   */
  data(e = {}) {
    if (this._document) {
      if (this._converter) {
        const n = new bc(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          this.metadata,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(n, e);
      }
      return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * By default, a `serverTimestamp()` that has not yet been set to
   * its final value will be returned as `null`. You can override this by
   * passing an options object.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @param options - An options object to configure how the field is retrieved
   * from the snapshot (for example the desired behavior for server timestamps
   * that have not yet been set to their final value).
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(e, n = {}) {
    if (this._document) {
      const r = this._document.data.field(Ol("DocumentSnapshot.get", e));
      if (r !== null) return this._userDataWriter.convertValue(r, n.serverTimestamps);
    }
  }
}
class bc extends bw {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * By default, `serverTimestamp()` values that have not yet been
   * set to their final value will be returned as `null`. You can override
   * this by passing an options object.
   *
   * @override
   * @param options - An options object to configure how data is retrieved from
   * the snapshot (for example the desired behavior for server timestamps that
   * have not yet been set to their final value).
   * @returns An `Object` containing all fields in the document.
   */
  data(e = {}) {
    return super.data(e);
  }
}
class vw {
  /** @hideconstructor */
  constructor(e, n, r, i) {
    this._firestore = e, this._userDataWriter = n, this._snapshot = i, this.metadata = new Lo(i.hasPendingWrites, i.fromCache), this.query = r;
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    const e = [];
    return this.forEach((n) => e.push(n)), e;
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this._snapshot.docs.size;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return this.size === 0;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(e, n) {
    this._snapshot.docs.forEach((r) => {
      e.call(n, new bc(this._firestore, this._userDataWriter, r.key, r, new Lo(this._snapshot.mutatedKeys.has(r.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  /**
   * Returns an array of the documents changes since the last snapshot. If this
   * is the first snapshot, all documents will be in the list as 'added'
   * changes.
   *
   * @param options - `SnapshotListenOptions` that control whether metadata-only
   * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger
   * snapshot events.
   */
  docChanges(e = {}) {
    const n = !!e.includeMetadataChanges;
    if (n && this._snapshot.excludesMetadataChanges) throw new ne(j.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === n || (this._cachedChanges = /** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */
    function(i, s) {
      if (i._snapshot.oldDocs.isEmpty()) {
        let o = 0;
        return i._snapshot.docChanges.map((a) => {
          const l = new bc(i._firestore, i._userDataWriter, a.doc.key, a.doc, new Lo(i._snapshot.mutatedKeys.has(a.doc.key), i._snapshot.fromCache), i.query.converter);
          return a.doc, {
            type: "added",
            doc: l,
            oldIndex: -1,
            newIndex: o++
          };
        });
      }
      {
        let o = i._snapshot.oldDocs;
        return i._snapshot.docChanges.filter((a) => s || a.type !== 3).map((a) => {
          const l = new bc(i._firestore, i._userDataWriter, a.doc.key, a.doc, new Lo(i._snapshot.mutatedKeys.has(a.doc.key), i._snapshot.fromCache), i.query.converter);
          let u = -1, d = -1;
          return a.type !== 0 && (u = o.indexOf(a.doc.key), o = o.delete(a.doc.key)), a.type !== 1 && (o = o.add(a.doc), d = o.indexOf(a.doc.key)), {
            type: dx(a.type),
            doc: l,
            oldIndex: u,
            newIndex: d
          };
        });
      }
    }(this, n), this._cachedChangesIncludeMetadataChanges = n), this._cachedChanges;
  }
}
function dx(t) {
  switch (t) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return Ne();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function QB(t) {
  t = tr(t, gn);
  const e = tr(t.firestore, rs);
  return KP(Nl(e), t._key).then((n) => ww(e, t, n));
}
class Kh extends lx {
  constructor(e) {
    super(), this.firestore = e;
  }
  convertBytes(e) {
    return new to(e);
  }
  convertReference(e) {
    const n = this.convertDocumentKey(e, this.firestore._databaseId);
    return new gn(
      this.firestore,
      /* converter= */
      null,
      n
    );
  }
}
function JB(t) {
  t = tr(t, Tr);
  const e = tr(t.firestore, rs), n = Nl(e), r = new Kh(e);
  return gw(t._query), YP(n, t._query).then((i) => new vw(e, r, t, i));
}
function ZB(t, e, n) {
  t = tr(t, gn);
  const r = tr(t.firestore, rs), i = ux(t.converter, e, n);
  return Ew(r, [rx($h(r), "setDoc", t._key, i, t.converter !== null, n).toMutation(t._key, _r.none())]);
}
function e2(t) {
  return Ew(tr(t.firestore, rs), [new _h(t._key, _r.none())]);
}
function t2(t, ...e) {
  var n, r, i;
  t = st(t);
  let s = {
    includeMetadataChanges: !1,
    source: "default"
  }, o = 0;
  typeof e[o] != "object" || ly(e[o]) || (s = e[o], o++);
  const a = {
    includeMetadataChanges: s.includeMetadataChanges,
    source: s.source
  };
  if (ly(e[o])) {
    const f = e[o];
    e[o] = (n = f.next) === null || n === void 0 ? void 0 : n.bind(f), e[o + 1] = (r = f.error) === null || r === void 0 ? void 0 : r.bind(f), e[o + 2] = (i = f.complete) === null || i === void 0 ? void 0 : i.bind(f);
  }
  let l, u, d;
  if (t instanceof gn) u = tr(t.firestore, rs), d = bl(t._key.path), l = {
    next: (f) => {
      e[o] && e[o](ww(u, t, f));
    },
    error: e[o + 1],
    complete: e[o + 2]
  };
  else {
    const f = tr(t, Tr);
    u = tr(f.firestore, rs), d = f._query;
    const p = new Kh(u);
    l = {
      next: (g) => {
        e[o] && e[o](new vw(u, p, f, g));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, gw(t._query);
  }
  return function(p, g, _, b) {
    const m = new Lh(b), v = new Mh(g, m, _);
    return p.asyncQueue.enqueueAndForget(async () => Oh(await Gc(p), v)), () => {
      m.Za(), p.asyncQueue.enqueueAndForget(async () => Ph(await Gc(p), v));
    };
  }(Nl(u), d, a, l);
}
function Ew(t, e) {
  return function(r, i) {
    const s = new jr();
    return r.asyncQueue.enqueueAndForget(async () => UP(await HP(r), i, s)), s.promise;
  }(Nl(t), e);
}
function ww(t, e, n) {
  const r = n.docs.get(e._key), i = new Kh(t);
  return new bw(t, i, e._key, r, new Lo(n.hasPendingWrites, n.fromCache), e.converter);
}
(function(e, n = !0) {
  (function(i) {
    co = i;
  })(ls), bi(new Wr("firestore", (r, { instanceIdentifier: i, options: s }) => {
    const o = r.getProvider("app").getImmediate(), a = new rs(new gN(r.getProvider("auth-internal")), new vN(r.getProvider("app-check-internal")), function(u, d) {
      if (!Object.prototype.hasOwnProperty.apply(u.options, ["projectId"])) throw new ne(j.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new na(u.options.projectId, d);
    }(o, i), o);
    return s = Object.assign({
      useFetchStreams: n
    }, s), a._setSettings(s), a;
  }, "PUBLIC").setMultipleInstances(!0)), $n(Rg, "4.7.3", e), // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
  $n(Rg, "4.7.3", "esm2017");
})();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Tw = "firebasestorage.googleapis.com", Iw = "storageBucket", fx = 2 * 60 * 1e3, hx = 10 * 60 * 1e3;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kt extends rr {
  /**
   * @param code - A `StorageErrorCode` string to be prefixed with 'storage/' and
   *  added to the end of the message.
   * @param message  - Error message.
   * @param status_ - Corresponding HTTP Status Code
   */
  constructor(e, n, r = 0) {
    super(bu(e), `Firebase Storage: ${n} (${bu(e)})`), this.status_ = r, this.customData = { serverResponse: null }, this._baseMessage = this.message, Object.setPrototypeOf(this, kt.prototype);
  }
  get status() {
    return this.status_;
  }
  set status(e) {
    this.status_ = e;
  }
  /**
   * Compares a `StorageErrorCode` against this error's code, filtering out the prefix.
   */
  _codeEquals(e) {
    return bu(e) === this.code;
  }
  /**
   * Optional response message that was added by the server.
   */
  get serverResponse() {
    return this.customData.serverResponse;
  }
  set serverResponse(e) {
    this.customData.serverResponse = e, this.customData.serverResponse ? this.message = `${this._baseMessage}
${this.customData.serverResponse}` : this.message = this._baseMessage;
  }
}
var Ct;
(function(t) {
  t.UNKNOWN = "unknown", t.OBJECT_NOT_FOUND = "object-not-found", t.BUCKET_NOT_FOUND = "bucket-not-found", t.PROJECT_NOT_FOUND = "project-not-found", t.QUOTA_EXCEEDED = "quota-exceeded", t.UNAUTHENTICATED = "unauthenticated", t.UNAUTHORIZED = "unauthorized", t.UNAUTHORIZED_APP = "unauthorized-app", t.RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded", t.INVALID_CHECKSUM = "invalid-checksum", t.CANCELED = "canceled", t.INVALID_EVENT_NAME = "invalid-event-name", t.INVALID_URL = "invalid-url", t.INVALID_DEFAULT_BUCKET = "invalid-default-bucket", t.NO_DEFAULT_BUCKET = "no-default-bucket", t.CANNOT_SLICE_BLOB = "cannot-slice-blob", t.SERVER_FILE_WRONG_SIZE = "server-file-wrong-size", t.NO_DOWNLOAD_URL = "no-download-url", t.INVALID_ARGUMENT = "invalid-argument", t.INVALID_ARGUMENT_COUNT = "invalid-argument-count", t.APP_DELETED = "app-deleted", t.INVALID_ROOT_OPERATION = "invalid-root-operation", t.INVALID_FORMAT = "invalid-format", t.INTERNAL_ERROR = "internal-error", t.UNSUPPORTED_ENVIRONMENT = "unsupported-environment";
})(Ct || (Ct = {}));
function bu(t) {
  return "storage/" + t;
}
function Yh() {
  const t = "An unknown error occurred, please check the error payload for server response.";
  return new kt(Ct.UNKNOWN, t);
}
function px(t) {
  return new kt(Ct.OBJECT_NOT_FOUND, "Object '" + t + "' does not exist.");
}
function mx(t) {
  return new kt(Ct.QUOTA_EXCEEDED, "Quota for bucket '" + t + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function gx() {
  const t = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new kt(Ct.UNAUTHENTICATED, t);
}
function yx() {
  return new kt(Ct.UNAUTHORIZED_APP, "This app does not have permission to access Firebase Storage on this project.");
}
function _x(t) {
  return new kt(Ct.UNAUTHORIZED, "User does not have permission to access '" + t + "'.");
}
function bx() {
  return new kt(Ct.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again.");
}
function vx() {
  return new kt(Ct.CANCELED, "User canceled the upload/download.");
}
function Ex(t) {
  return new kt(Ct.INVALID_URL, "Invalid URL '" + t + "'.");
}
function wx(t) {
  return new kt(Ct.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + t + "'.");
}
function Tx() {
  return new kt(Ct.NO_DEFAULT_BUCKET, "No default bucket found. Did you set the '" + Iw + "' property when initializing the app?");
}
function Ix() {
  return new kt(Ct.CANNOT_SLICE_BLOB, "Cannot slice blob for upload. Please retry the upload.");
}
function Sx() {
  return new kt(Ct.NO_DOWNLOAD_URL, "The given file does not have any download URLs.");
}
function Ax(t) {
  return new kt(Ct.UNSUPPORTED_ENVIRONMENT, `${t} is missing. Make sure to install the required polyfills. See https://firebase.google.com/docs/web/environments-js-sdk#polyfills for more information.`);
}
function tf(t) {
  return new kt(Ct.INVALID_ARGUMENT, t);
}
function Sw() {
  return new kt(Ct.APP_DELETED, "The Firebase app was deleted.");
}
function Rx(t) {
  return new kt(Ct.INVALID_ROOT_OPERATION, "The operation '" + t + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function Wo(t, e) {
  return new kt(Ct.INVALID_FORMAT, "String does not match format '" + t + "': " + e);
}
function Ro(t) {
  throw new kt(Ct.INTERNAL_ERROR, "Internal error: " + t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mn {
  constructor(e, n) {
    this.bucket = e, this.path_ = n;
  }
  get path() {
    return this.path_;
  }
  get isRoot() {
    return this.path.length === 0;
  }
  fullServerUrl() {
    const e = encodeURIComponent;
    return "/b/" + e(this.bucket) + "/o/" + e(this.path);
  }
  bucketOnlyServerUrl() {
    return "/b/" + encodeURIComponent(this.bucket) + "/o";
  }
  static makeFromBucketSpec(e, n) {
    let r;
    try {
      r = mn.makeFromUrl(e, n);
    } catch {
      return new mn(e, "");
    }
    if (r.path === "")
      return r;
    throw wx(e);
  }
  static makeFromUrl(e, n) {
    let r = null;
    const i = "([A-Za-z0-9.\\-_]+)";
    function s(P) {
      P.path.charAt(P.path.length - 1) === "/" && (P.path_ = P.path_.slice(0, -1));
    }
    const o = "(/(.*))?$", a = new RegExp("^gs://" + i + o, "i"), l = { bucket: 1, path: 3 };
    function u(P) {
      P.path_ = decodeURIComponent(P.path);
    }
    const d = "v[A-Za-z0-9_]+", f = n.replace(/[.]/g, "\\."), p = "(/([^?#]*).*)?$", g = new RegExp(`^https?://${f}/${d}/b/${i}/o${p}`, "i"), _ = { bucket: 1, path: 3 }, b = n === Tw ? "(?:storage.googleapis.com|storage.cloud.google.com)" : n, m = "([^?#]*)", v = new RegExp(`^https?://${b}/${i}/${m}`, "i"), x = [
      { regex: a, indices: l, postModify: s },
      {
        regex: g,
        indices: _,
        postModify: u
      },
      {
        regex: v,
        indices: { bucket: 1, path: 2 },
        postModify: u
      }
    ];
    for (let P = 0; P < x.length; P++) {
      const k = x[P], U = k.regex.exec(e);
      if (U) {
        const I = U[k.indices.bucket];
        let E = U[k.indices.path];
        E || (E = ""), r = new mn(I, E), k.postModify(r);
        break;
      }
    }
    if (r == null)
      throw Ex(e);
    return r;
  }
}
class Cx {
  constructor(e) {
    this.promise_ = Promise.reject(e);
  }
  /** @inheritDoc */
  getPromise() {
    return this.promise_;
  }
  /** @inheritDoc */
  cancel(e = !1) {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function kx(t, e, n) {
  let r = 1, i = null, s = null, o = !1, a = 0;
  function l() {
    return a === 2;
  }
  let u = !1;
  function d(...m) {
    u || (u = !0, e.apply(null, m));
  }
  function f(m) {
    i = setTimeout(() => {
      i = null, t(g, l());
    }, m);
  }
  function p() {
    s && clearTimeout(s);
  }
  function g(m, ...v) {
    if (u) {
      p();
      return;
    }
    if (m) {
      p(), d.call(null, m, ...v);
      return;
    }
    if (l() || o) {
      p(), d.call(null, m, ...v);
      return;
    }
    r < 64 && (r *= 2);
    let x;
    a === 1 ? (a = 2, x = 0) : x = (r + Math.random()) * 1e3, f(x);
  }
  let _ = !1;
  function b(m) {
    _ || (_ = !0, p(), !u && (i !== null ? (m || (a = 2), clearTimeout(i), f(0)) : m || (a = 1)));
  }
  return f(0), s = setTimeout(() => {
    o = !0, b(!0);
  }, n), b;
}
function Nx(t) {
  t(!1);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ox(t) {
  return t !== void 0;
}
function Px(t) {
  return typeof t == "object" && !Array.isArray(t);
}
function Xh(t) {
  return typeof t == "string" || t instanceof String;
}
function fy(t) {
  return Qh() && t instanceof Blob;
}
function Qh() {
  return typeof Blob < "u";
}
function nf(t, e, n, r) {
  if (r < e)
    throw tf(`Invalid value for '${t}'. Expected ${e} or greater.`);
  if (r > n)
    throw tf(`Invalid value for '${t}'. Expected ${n} or less.`);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Aa(t, e, n) {
  let r = e;
  return n == null && (r = `https://${e}`), `${n}://${r}/v0${t}`;
}
function Aw(t) {
  const e = encodeURIComponent;
  let n = "?";
  for (const r in t)
    if (t.hasOwnProperty(r)) {
      const i = e(r) + "=" + e(t[r]);
      n = n + i + "&";
    }
  return n = n.slice(0, -1), n;
}
var Xi;
(function(t) {
  t[t.NO_ERROR = 0] = "NO_ERROR", t[t.NETWORK_ERROR = 1] = "NETWORK_ERROR", t[t.ABORT = 2] = "ABORT";
})(Xi || (Xi = {}));
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function xx(t, e) {
  const n = t >= 500 && t < 600, i = [
    // Request Timeout: web server didn't receive full request in time.
    408,
    // Too Many Requests: you're getting rate-limited, basically.
    429
  ].indexOf(t) !== -1, s = e.indexOf(t) !== -1;
  return n || i || s;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mx {
  constructor(e, n, r, i, s, o, a, l, u, d, f, p = !0) {
    this.url_ = e, this.method_ = n, this.headers_ = r, this.body_ = i, this.successCodes_ = s, this.additionalRetryCodes_ = o, this.callback_ = a, this.errorCallback_ = l, this.timeout_ = u, this.progressCallback_ = d, this.connectionFactory_ = f, this.retry = p, this.pendingConnection_ = null, this.backoffId_ = null, this.canceled_ = !1, this.appDelete_ = !1, this.promise_ = new Promise((g, _) => {
      this.resolve_ = g, this.reject_ = _, this.start_();
    });
  }
  /**
   * Actually starts the retry loop.
   */
  start_() {
    const e = (r, i) => {
      if (i) {
        r(!1, new ec(!1, null, !0));
        return;
      }
      const s = this.connectionFactory_();
      this.pendingConnection_ = s;
      const o = (a) => {
        const l = a.loaded, u = a.lengthComputable ? a.total : -1;
        this.progressCallback_ !== null && this.progressCallback_(l, u);
      };
      this.progressCallback_ !== null && s.addUploadProgressListener(o), s.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
        this.progressCallback_ !== null && s.removeUploadProgressListener(o), this.pendingConnection_ = null;
        const a = s.getErrorCode() === Xi.NO_ERROR, l = s.getStatus();
        if (!a || xx(l, this.additionalRetryCodes_) && this.retry) {
          const d = s.getErrorCode() === Xi.ABORT;
          r(!1, new ec(!1, null, d));
          return;
        }
        const u = this.successCodes_.indexOf(l) !== -1;
        r(!0, new ec(u, s));
      });
    }, n = (r, i) => {
      const s = this.resolve_, o = this.reject_, a = i.connection;
      if (i.wasSuccessCode)
        try {
          const l = this.callback_(a, a.getResponse());
          Ox(l) ? s(l) : s();
        } catch (l) {
          o(l);
        }
      else if (a !== null) {
        const l = Yh();
        l.serverResponse = a.getErrorText(), this.errorCallback_ ? o(this.errorCallback_(a, l)) : o(l);
      } else if (i.canceled) {
        const l = this.appDelete_ ? Sw() : vx();
        o(l);
      } else {
        const l = bx();
        o(l);
      }
    };
    this.canceled_ ? n(!1, new ec(!1, null, !0)) : this.backoffId_ = kx(e, n, this.timeout_);
  }
  /** @inheritDoc */
  getPromise() {
    return this.promise_;
  }
  /** @inheritDoc */
  cancel(e) {
    this.canceled_ = !0, this.appDelete_ = e || !1, this.backoffId_ !== null && Nx(this.backoffId_), this.pendingConnection_ !== null && this.pendingConnection_.abort();
  }
}
class ec {
  constructor(e, n, r) {
    this.wasSuccessCode = e, this.connection = n, this.canceled = !!r;
  }
}
function Dx(t, e) {
  e !== null && e.length > 0 && (t.Authorization = "Firebase " + e);
}
function Lx(t, e) {
  t["X-Firebase-Storage-Version"] = "webjs/" + (e ?? "AppManager");
}
function Ux(t, e) {
  e && (t["X-Firebase-GMPID"] = e);
}
function Fx(t, e) {
  e !== null && (t["X-Firebase-AppCheck"] = e);
}
function Vx(t, e, n, r, i, s, o = !0) {
  const a = Aw(t.urlParams), l = t.url + a, u = Object.assign({}, t.headers);
  return Ux(u, e), Dx(u, n), Lx(u, s), Fx(u, r), new Mx(l, t.method, u, t.body, t.successCodes, t.additionalRetryCodes, t.handler, t.errorHandler, t.timeout, t.progressCallback, i, o);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Bx() {
  return typeof BlobBuilder < "u" ? BlobBuilder : typeof WebKitBlobBuilder < "u" ? WebKitBlobBuilder : void 0;
}
function $x(...t) {
  const e = Bx();
  if (e !== void 0) {
    const n = new e();
    for (let r = 0; r < t.length; r++)
      n.append(t[r]);
    return n.getBlob();
  } else {
    if (Qh())
      return new Blob(t);
    throw new kt(Ct.UNSUPPORTED_ENVIRONMENT, "This browser doesn't seem to support creating Blobs");
  }
}
function jx(t, e, n) {
  return t.webkitSlice ? t.webkitSlice(e, n) : t.mozSlice ? t.mozSlice(e, n) : t.slice ? t.slice(e, n) : null;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qx(t) {
  if (typeof atob > "u")
    throw Ax("base-64");
  return atob(t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jn = {
  /**
   * Indicates the string should be interpreted "raw", that is, as normal text.
   * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte
   * sequence.
   * Example: The string 'Hello! \\ud83d\\ude0a' becomes the byte sequence
   * 48 65 6c 6c 6f 21 20 f0 9f 98 8a
   */
  RAW: "raw",
  /**
   * Indicates the string should be interpreted as base64-encoded data.
   * Padding characters (trailing '='s) are optional.
   * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence
   * ad 69 8e fb e1 3a b7 bf eb 97
   */
  BASE64: "base64",
  /**
   * Indicates the string should be interpreted as base64url-encoded data.
   * Padding characters (trailing '='s) are optional.
   * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence
   * ad 69 8e fb e1 3a b7 bf eb 97
   */
  BASE64URL: "base64url",
  /**
   * Indicates the string is a data URL, such as one obtained from
   * canvas.toDataURL().
   * Example: the string 'data:application/octet-stream;base64,aaaa'
   * becomes the byte sequence
   * 69 a6 9a
   * (the content-type "application/octet-stream" is also applied, but can
   * be overridden in the metadata object).
   */
  DATA_URL: "data_url"
};
class vu {
  constructor(e, n) {
    this.data = e, this.contentType = n || null;
  }
}
function Rw(t, e) {
  switch (t) {
    case Jn.RAW:
      return new vu(Cw(e));
    case Jn.BASE64:
    case Jn.BASE64URL:
      return new vu(kw(t, e));
    case Jn.DATA_URL:
      return new vu(Wx(e), Gx(e));
  }
  throw Yh();
}
function Cw(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    let r = t.charCodeAt(n);
    if (r <= 127)
      e.push(r);
    else if (r <= 2047)
      e.push(192 | r >> 6, 128 | r & 63);
    else if ((r & 64512) === 55296)
      if (!(n < t.length - 1 && (t.charCodeAt(n + 1) & 64512) === 56320))
        e.push(239, 191, 189);
      else {
        const s = r, o = t.charCodeAt(++n);
        r = 65536 | (s & 1023) << 10 | o & 1023, e.push(240 | r >> 18, 128 | r >> 12 & 63, 128 | r >> 6 & 63, 128 | r & 63);
      }
    else
      (r & 64512) === 56320 ? e.push(239, 191, 189) : e.push(224 | r >> 12, 128 | r >> 6 & 63, 128 | r & 63);
  }
  return new Uint8Array(e);
}
function zx(t) {
  let e;
  try {
    e = decodeURIComponent(t);
  } catch {
    throw Wo(Jn.DATA_URL, "Malformed data URL.");
  }
  return Cw(e);
}
function kw(t, e) {
  switch (t) {
    case Jn.BASE64: {
      const i = e.indexOf("-") !== -1, s = e.indexOf("_") !== -1;
      if (i || s)
        throw Wo(t, "Invalid character '" + (i ? "-" : "_") + "' found: is it base64url encoded?");
      break;
    }
    case Jn.BASE64URL: {
      const i = e.indexOf("+") !== -1, s = e.indexOf("/") !== -1;
      if (i || s)
        throw Wo(t, "Invalid character '" + (i ? "+" : "/") + "' found: is it base64 encoded?");
      e = e.replace(/-/g, "+").replace(/_/g, "/");
      break;
    }
  }
  let n;
  try {
    n = qx(e);
  } catch (i) {
    throw i.message.includes("polyfill") ? i : Wo(t, "Invalid character found");
  }
  const r = new Uint8Array(n.length);
  for (let i = 0; i < n.length; i++)
    r[i] = n.charCodeAt(i);
  return r;
}
class Nw {
  constructor(e) {
    this.base64 = !1, this.contentType = null;
    const n = e.match(/^data:([^,]+)?,/);
    if (n === null)
      throw Wo(Jn.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
    const r = n[1] || null;
    r != null && (this.base64 = Hx(r, ";base64"), this.contentType = this.base64 ? r.substring(0, r.length - 7) : r), this.rest = e.substring(e.indexOf(",") + 1);
  }
}
function Wx(t) {
  const e = new Nw(t);
  return e.base64 ? kw(Jn.BASE64, e.rest) : zx(e.rest);
}
function Gx(t) {
  return new Nw(t).contentType;
}
function Hx(t, e) {
  return t.length >= e.length ? t.substring(t.length - e.length) === e : !1;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fi {
  constructor(e, n) {
    let r = 0, i = "";
    fy(e) ? (this.data_ = e, r = e.size, i = e.type) : e instanceof ArrayBuffer ? (n ? this.data_ = new Uint8Array(e) : (this.data_ = new Uint8Array(e.byteLength), this.data_.set(new Uint8Array(e))), r = this.data_.length) : e instanceof Uint8Array && (n ? this.data_ = e : (this.data_ = new Uint8Array(e.length), this.data_.set(e)), r = e.length), this.size_ = r, this.type_ = i;
  }
  size() {
    return this.size_;
  }
  type() {
    return this.type_;
  }
  slice(e, n) {
    if (fy(this.data_)) {
      const r = this.data_, i = jx(r, e, n);
      return i === null ? null : new fi(i);
    } else {
      const r = new Uint8Array(this.data_.buffer, e, n - e);
      return new fi(r, !0);
    }
  }
  static getBlob(...e) {
    if (Qh()) {
      const n = e.map((r) => r instanceof fi ? r.data_ : r);
      return new fi($x.apply(null, n));
    } else {
      const n = e.map((o) => Xh(o) ? Rw(Jn.RAW, o).data : o.data_);
      let r = 0;
      n.forEach((o) => {
        r += o.byteLength;
      });
      const i = new Uint8Array(r);
      let s = 0;
      return n.forEach((o) => {
        for (let a = 0; a < o.length; a++)
          i[s++] = o[a];
      }), new fi(i, !0);
    }
  }
  uploadData() {
    return this.data_;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Jh(t) {
  let e;
  try {
    e = JSON.parse(t);
  } catch {
    return null;
  }
  return Px(e) ? e : null;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Kx(t) {
  if (t.length === 0)
    return null;
  const e = t.lastIndexOf("/");
  return e === -1 ? "" : t.slice(0, e);
}
function Yx(t, e) {
  const n = e.split("/").filter((r) => r.length > 0).join("/");
  return t.length === 0 ? n : t + "/" + n;
}
function Ow(t) {
  const e = t.lastIndexOf("/", t.length - 2);
  return e === -1 ? t : t.slice(e + 1);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Xx(t, e) {
  return e;
}
class pn {
  constructor(e, n, r, i) {
    this.server = e, this.local = n || e, this.writable = !!r, this.xform = i || Xx;
  }
}
let tc = null;
function Qx(t) {
  return !Xh(t) || t.length < 2 ? t : Ow(t);
}
function Pw() {
  if (tc)
    return tc;
  const t = [];
  t.push(new pn("bucket")), t.push(new pn("generation")), t.push(new pn("metageneration")), t.push(new pn("name", "fullPath", !0));
  function e(s, o) {
    return Qx(o);
  }
  const n = new pn("name");
  n.xform = e, t.push(n);
  function r(s, o) {
    return o !== void 0 ? Number(o) : o;
  }
  const i = new pn("size");
  return i.xform = r, t.push(i), t.push(new pn("timeCreated")), t.push(new pn("updated")), t.push(new pn("md5Hash", null, !0)), t.push(new pn("cacheControl", null, !0)), t.push(new pn("contentDisposition", null, !0)), t.push(new pn("contentEncoding", null, !0)), t.push(new pn("contentLanguage", null, !0)), t.push(new pn("contentType", null, !0)), t.push(new pn("metadata", "customMetadata", !0)), tc = t, tc;
}
function Jx(t, e) {
  function n() {
    const r = t.bucket, i = t.fullPath, s = new mn(r, i);
    return e._makeStorageReference(s);
  }
  Object.defineProperty(t, "ref", { get: n });
}
function Zx(t, e, n) {
  const r = {};
  r.type = "file";
  const i = n.length;
  for (let s = 0; s < i; s++) {
    const o = n[s];
    r[o.local] = o.xform(r, e[o.server]);
  }
  return Jx(r, t), r;
}
function xw(t, e, n) {
  const r = Jh(e);
  return r === null ? null : Zx(t, r, n);
}
function eM(t, e, n, r) {
  const i = Jh(e);
  if (i === null || !Xh(i.downloadTokens))
    return null;
  const s = i.downloadTokens;
  if (s.length === 0)
    return null;
  const o = encodeURIComponent;
  return s.split(",").map((u) => {
    const d = t.bucket, f = t.fullPath, p = "/b/" + o(d) + "/o/" + o(f), g = Aa(p, n, r), _ = Aw({
      alt: "media",
      token: u
    });
    return g + _;
  })[0];
}
function tM(t, e) {
  const n = {}, r = e.length;
  for (let i = 0; i < r; i++) {
    const s = e[i];
    s.writable && (n[s.server] = t[s.local]);
  }
  return JSON.stringify(n);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hy = "prefixes", py = "items";
function nM(t, e, n) {
  const r = {
    prefixes: [],
    items: [],
    nextPageToken: n.nextPageToken
  };
  if (n[hy])
    for (const i of n[hy]) {
      const s = i.replace(/\/$/, ""), o = t._makeStorageReference(new mn(e, s));
      r.prefixes.push(o);
    }
  if (n[py])
    for (const i of n[py]) {
      const s = t._makeStorageReference(new mn(e, i.name));
      r.items.push(s);
    }
  return r;
}
function rM(t, e, n) {
  const r = Jh(n);
  return r === null ? null : nM(t, e, r);
}
class xl {
  constructor(e, n, r, i) {
    this.url = e, this.method = n, this.handler = r, this.timeout = i, this.urlParams = {}, this.headers = {}, this.body = null, this.errorHandler = null, this.progressCallback = null, this.successCodes = [200], this.additionalRetryCodes = [];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Zh(t) {
  if (!t)
    throw Yh();
}
function iM(t, e) {
  function n(r, i) {
    const s = xw(t, i, e);
    return Zh(s !== null), s;
  }
  return n;
}
function sM(t, e) {
  function n(r, i) {
    const s = rM(t, e, i);
    return Zh(s !== null), s;
  }
  return n;
}
function oM(t, e) {
  function n(r, i) {
    const s = xw(t, i, e);
    return Zh(s !== null), eM(s, i, t.host, t._protocol);
  }
  return n;
}
function ep(t) {
  function e(n, r) {
    let i;
    return n.getStatus() === 401 ? /* This exact message string is the only consistent part of the */ /* server's error response that identifies it as an App Check error. */ n.getErrorText().includes("Firebase App Check token is invalid") ? i = yx() : i = gx() : n.getStatus() === 402 ? i = mx(t.bucket) : n.getStatus() === 403 ? i = _x(t.path) : i = r, i.status = n.getStatus(), i.serverResponse = r.serverResponse, i;
  }
  return e;
}
function Mw(t) {
  const e = ep(t);
  function n(r, i) {
    let s = e(r, i);
    return r.getStatus() === 404 && (s = px(t.path)), s.serverResponse = i.serverResponse, s;
  }
  return n;
}
function aM(t, e, n, r, i) {
  const s = {};
  e.isRoot ? s.prefix = "" : s.prefix = e.path + "/", n.length > 0 && (s.delimiter = n), r && (s.pageToken = r), i && (s.maxResults = i);
  const o = e.bucketOnlyServerUrl(), a = Aa(o, t.host, t._protocol), l = "GET", u = t.maxOperationRetryTime, d = new xl(a, l, sM(t, e.bucket), u);
  return d.urlParams = s, d.errorHandler = ep(e), d;
}
function cM(t, e, n) {
  const r = e.fullServerUrl(), i = Aa(r, t.host, t._protocol), s = "GET", o = t.maxOperationRetryTime, a = new xl(i, s, oM(t, n), o);
  return a.errorHandler = Mw(e), a;
}
function lM(t, e) {
  const n = e.fullServerUrl(), r = Aa(n, t.host, t._protocol), i = "DELETE", s = t.maxOperationRetryTime;
  function o(l, u) {
  }
  const a = new xl(r, i, o, s);
  return a.successCodes = [200, 204], a.errorHandler = Mw(e), a;
}
function uM(t, e) {
  return t && t.contentType || e && e.type() || "application/octet-stream";
}
function dM(t, e, n) {
  const r = Object.assign({}, n);
  return r.fullPath = t.path, r.size = e.size(), r.contentType || (r.contentType = uM(null, e)), r;
}
function fM(t, e, n, r, i) {
  const s = e.bucketOnlyServerUrl(), o = {
    "X-Goog-Upload-Protocol": "multipart"
  };
  function a() {
    let x = "";
    for (let P = 0; P < 2; P++)
      x = x + Math.random().toString().slice(2);
    return x;
  }
  const l = a();
  o["Content-Type"] = "multipart/related; boundary=" + l;
  const u = dM(e, r, i), d = tM(u, n), f = "--" + l + `\r
Content-Type: application/json; charset=utf-8\r
\r
` + d + `\r
--` + l + `\r
Content-Type: ` + u.contentType + `\r
\r
`, p = `\r
--` + l + "--", g = fi.getBlob(f, r, p);
  if (g === null)
    throw Ix();
  const _ = { name: u.fullPath }, b = Aa(s, t.host, t._protocol), m = "POST", v = t.maxUploadRetryTime, C = new xl(b, m, iM(t, n), v);
  return C.urlParams = _, C.headers = o, C.body = g.uploadData(), C.errorHandler = ep(e), C;
}
class hM {
  constructor() {
    this.sent_ = !1, this.xhr_ = new XMLHttpRequest(), this.initXhr(), this.errorCode_ = Xi.NO_ERROR, this.sendPromise_ = new Promise((e) => {
      this.xhr_.addEventListener("abort", () => {
        this.errorCode_ = Xi.ABORT, e();
      }), this.xhr_.addEventListener("error", () => {
        this.errorCode_ = Xi.NETWORK_ERROR, e();
      }), this.xhr_.addEventListener("load", () => {
        e();
      });
    });
  }
  send(e, n, r, i) {
    if (this.sent_)
      throw Ro("cannot .send() more than once");
    if (this.sent_ = !0, this.xhr_.open(n, e, !0), i !== void 0)
      for (const s in i)
        i.hasOwnProperty(s) && this.xhr_.setRequestHeader(s, i[s].toString());
    return r !== void 0 ? this.xhr_.send(r) : this.xhr_.send(), this.sendPromise_;
  }
  getErrorCode() {
    if (!this.sent_)
      throw Ro("cannot .getErrorCode() before sending");
    return this.errorCode_;
  }
  getStatus() {
    if (!this.sent_)
      throw Ro("cannot .getStatus() before sending");
    try {
      return this.xhr_.status;
    } catch {
      return -1;
    }
  }
  getResponse() {
    if (!this.sent_)
      throw Ro("cannot .getResponse() before sending");
    return this.xhr_.response;
  }
  getErrorText() {
    if (!this.sent_)
      throw Ro("cannot .getErrorText() before sending");
    return this.xhr_.statusText;
  }
  /** Aborts the request. */
  abort() {
    this.xhr_.abort();
  }
  getResponseHeader(e) {
    return this.xhr_.getResponseHeader(e);
  }
  addUploadProgressListener(e) {
    this.xhr_.upload != null && this.xhr_.upload.addEventListener("progress", e);
  }
  removeUploadProgressListener(e) {
    this.xhr_.upload != null && this.xhr_.upload.removeEventListener("progress", e);
  }
}
class pM extends hM {
  initXhr() {
    this.xhr_.responseType = "text";
  }
}
function Ml() {
  return new pM();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class is {
  constructor(e, n) {
    this._service = e, n instanceof mn ? this._location = n : this._location = mn.makeFromUrl(n, e.host);
  }
  /**
   * Returns the URL for the bucket and path this object references,
   *     in the form gs://<bucket>/<object-path>
   * @override
   */
  toString() {
    return "gs://" + this._location.bucket + "/" + this._location.path;
  }
  _newRef(e, n) {
    return new is(e, n);
  }
  /**
   * A reference to the root of this object's bucket.
   */
  get root() {
    const e = new mn(this._location.bucket, "");
    return this._newRef(this._service, e);
  }
  /**
   * The name of the bucket containing this reference's object.
   */
  get bucket() {
    return this._location.bucket;
  }
  /**
   * The full path of this object.
   */
  get fullPath() {
    return this._location.path;
  }
  /**
   * The short name of this object, which is the last component of the full path.
   * For example, if fullPath is 'full/path/image.png', name is 'image.png'.
   */
  get name() {
    return Ow(this._location.path);
  }
  /**
   * The `StorageService` instance this `StorageReference` is associated with.
   */
  get storage() {
    return this._service;
  }
  /**
   * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if
   * this reference is the root.
   */
  get parent() {
    const e = Kx(this._location.path);
    if (e === null)
      return null;
    const n = new mn(this._location.bucket, e);
    return new is(this._service, n);
  }
  /**
   * Utility function to throw an error in methods that do not accept a root reference.
   */
  _throwIfRoot(e) {
    if (this._location.path === "")
      throw Rx(e);
  }
}
function Dw(t, e, n) {
  t._throwIfRoot("uploadBytes");
  const r = fM(t.storage, t._location, Pw(), new fi(e, !0), n);
  return t.storage.makeRequestWithTokens(r, Ml).then((i) => ({
    metadata: i,
    ref: t
  }));
}
function mM(t, e, n = Jn.RAW, r) {
  t._throwIfRoot("uploadString");
  const i = Rw(n, e), s = Object.assign({}, r);
  return s.contentType == null && i.contentType != null && (s.contentType = i.contentType), Dw(t, i.data, s);
}
function gM(t) {
  const e = {
    prefixes: [],
    items: []
  };
  return Lw(t, e).then(() => e);
}
async function Lw(t, e, n) {
  const i = await yM(t, {
    // maxResults is 1000 by default.
    pageToken: n
  });
  e.prefixes.push(...i.prefixes), e.items.push(...i.items), i.nextPageToken != null && await Lw(t, e, i.nextPageToken);
}
function yM(t, e) {
  e != null && typeof e.maxResults == "number" && nf(
    "options.maxResults",
    /* minValue= */
    1,
    /* maxValue= */
    1e3,
    e.maxResults
  );
  const n = e || {}, r = aM(
    t.storage,
    t._location,
    /*delimiter= */
    "/",
    n.pageToken,
    n.maxResults
  );
  return t.storage.makeRequestWithTokens(r, Ml);
}
function _M(t) {
  t._throwIfRoot("getDownloadURL");
  const e = cM(t.storage, t._location, Pw());
  return t.storage.makeRequestWithTokens(e, Ml).then((n) => {
    if (n === null)
      throw Sx();
    return n;
  });
}
function bM(t) {
  t._throwIfRoot("deleteObject");
  const e = lM(t.storage, t._location);
  return t.storage.makeRequestWithTokens(e, Ml);
}
function vM(t, e) {
  const n = Yx(t._location.path, e), r = new mn(t._location.bucket, n);
  return new is(t.storage, r);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function EM(t) {
  return /^[A-Za-z]+:\/\//.test(t);
}
function wM(t, e) {
  return new is(t, e);
}
function Uw(t, e) {
  if (t instanceof tp) {
    const n = t;
    if (n._bucket == null)
      throw Tx();
    const r = new is(n, n._bucket);
    return e != null ? Uw(r, e) : r;
  } else
    return e !== void 0 ? vM(t, e) : t;
}
function TM(t, e) {
  if (e && EM(e)) {
    if (t instanceof tp)
      return wM(t, e);
    throw tf("To use ref(service, url), the first argument must be a Storage instance.");
  } else
    return Uw(t, e);
}
function my(t, e) {
  const n = e == null ? void 0 : e[Iw];
  return n == null ? null : mn.makeFromBucketSpec(n, t);
}
function IM(t, e, n, r = {}) {
  t.host = `${e}:${n}`, t._protocol = "http";
  const { mockUserToken: i } = r;
  i && (t._overrideAuthToken = typeof i == "string" ? i : vv(i, t.app.options.projectId));
}
class tp {
  constructor(e, n, r, i, s) {
    this.app = e, this._authProvider = n, this._appCheckProvider = r, this._url = i, this._firebaseVersion = s, this._bucket = null, this._host = Tw, this._protocol = "https", this._appId = null, this._deleted = !1, this._maxOperationRetryTime = fx, this._maxUploadRetryTime = hx, this._requests = /* @__PURE__ */ new Set(), i != null ? this._bucket = mn.makeFromBucketSpec(i, this._host) : this._bucket = my(this._host, this.app.options);
  }
  /**
   * The host string for this service, in the form of `host` or
   * `host:port`.
   */
  get host() {
    return this._host;
  }
  set host(e) {
    this._host = e, this._url != null ? this._bucket = mn.makeFromBucketSpec(this._url, e) : this._bucket = my(e, this.app.options);
  }
  /**
   * The maximum time to retry uploads in milliseconds.
   */
  get maxUploadRetryTime() {
    return this._maxUploadRetryTime;
  }
  set maxUploadRetryTime(e) {
    nf(
      "time",
      /* minValue=*/
      0,
      /* maxValue= */
      Number.POSITIVE_INFINITY,
      e
    ), this._maxUploadRetryTime = e;
  }
  /**
   * The maximum time to retry operations other than uploads or downloads in
   * milliseconds.
   */
  get maxOperationRetryTime() {
    return this._maxOperationRetryTime;
  }
  set maxOperationRetryTime(e) {
    nf(
      "time",
      /* minValue=*/
      0,
      /* maxValue= */
      Number.POSITIVE_INFINITY,
      e
    ), this._maxOperationRetryTime = e;
  }
  async _getAuthToken() {
    if (this._overrideAuthToken)
      return this._overrideAuthToken;
    const e = this._authProvider.getImmediate({ optional: !0 });
    if (e) {
      const n = await e.getToken();
      if (n !== null)
        return n.accessToken;
    }
    return null;
  }
  async _getAppCheckToken() {
    const e = this._appCheckProvider.getImmediate({ optional: !0 });
    return e ? (await e.getToken()).token : null;
  }
  /**
   * Stop running requests and prevent more from being created.
   */
  _delete() {
    return this._deleted || (this._deleted = !0, this._requests.forEach((e) => e.cancel()), this._requests.clear()), Promise.resolve();
  }
  /**
   * Returns a new firebaseStorage.Reference object referencing this StorageService
   * at the given Location.
   */
  _makeStorageReference(e) {
    return new is(this, e);
  }
  /**
   * @param requestInfo - HTTP RequestInfo object
   * @param authToken - Firebase auth token
   */
  _makeRequest(e, n, r, i, s = !0) {
    if (this._deleted)
      return new Cx(Sw());
    {
      const o = Vx(e, this._appId, r, i, n, this._firebaseVersion, s);
      return this._requests.add(o), o.getPromise().then(() => this._requests.delete(o), () => this._requests.delete(o)), o;
    }
  }
  async makeRequestWithTokens(e, n) {
    const [r, i] = await Promise.all([
      this._getAuthToken(),
      this._getAppCheckToken()
    ]);
    return this._makeRequest(e, n, r, i).getPromise();
  }
}
const gy = "@firebase/storage", yy = "0.13.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fw = "storage";
function n2(t, e, n) {
  return t = st(t), Dw(t, e, n);
}
function r2(t, e, n, r) {
  return t = st(t), mM(t, e, n, r);
}
function i2(t) {
  return t = st(t), gM(t);
}
function s2(t) {
  return t = st(t), _M(t);
}
function o2(t) {
  return t = st(t), bM(t);
}
function a2(t, e) {
  return t = st(t), TM(t, e);
}
function c2(t = fl(), e) {
  t = st(t);
  const r = ga(t, Fw).getImmediate({
    identifier: e
  }), i = Xf("storage");
  return i && SM(r, ...i), r;
}
function SM(t, e, n, r = {}) {
  IM(t, e, n, r);
}
function AM(t, { instanceIdentifier: e }) {
  const n = t.getProvider("app").getImmediate(), r = t.getProvider("auth-internal"), i = t.getProvider("app-check-internal");
  return new tp(n, r, i, e, ls);
}
function RM() {
  bi(new Wr(
    Fw,
    AM,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ).setMultipleInstances(!0)), $n(gy, yy, ""), $n(gy, yy, "esm2017");
}
RM();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CM = "type.googleapis.com/google.protobuf.Int64Value", kM = "type.googleapis.com/google.protobuf.UInt64Value";
function Vw(t, e) {
  const n = {};
  for (const r in t)
    t.hasOwnProperty(r) && (n[r] = e(t[r]));
  return n;
}
function rf(t) {
  if (t == null)
    return null;
  if (t instanceof Number && (t = t.valueOf()), typeof t == "number" && isFinite(t) || t === !0 || t === !1 || Object.prototype.toString.call(t) === "[object String]")
    return t;
  if (t instanceof Date)
    return t.toISOString();
  if (Array.isArray(t))
    return t.map((e) => rf(e));
  if (typeof t == "function" || typeof t == "object")
    return Vw(t, (e) => rf(e));
  throw new Error("Data cannot be encoded in JSON: " + t);
}
function Kc(t) {
  if (t == null)
    return t;
  if (t["@type"])
    switch (t["@type"]) {
      case CM:
      // Fall through and handle this the same as unsigned.
      case kM: {
        const e = Number(t.value);
        if (isNaN(e))
          throw new Error("Data cannot be decoded from JSON: " + t);
        return e;
      }
      default:
        throw new Error("Data cannot be decoded from JSON: " + t);
    }
  return Array.isArray(t) ? t.map((e) => Kc(e)) : typeof t == "function" || typeof t == "object" ? Vw(t, (e) => Kc(e)) : t;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const np = "functions";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _y = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
class Fs extends rr {
  constructor(e, n, r) {
    super(`${np}/${e}`, n || ""), this.details = r;
  }
}
function NM(t) {
  if (t >= 200 && t < 300)
    return "ok";
  switch (t) {
    case 0:
      return "internal";
    case 400:
      return "invalid-argument";
    case 401:
      return "unauthenticated";
    case 403:
      return "permission-denied";
    case 404:
      return "not-found";
    case 409:
      return "aborted";
    case 429:
      return "resource-exhausted";
    case 499:
      return "cancelled";
    case 500:
      return "internal";
    case 501:
      return "unimplemented";
    case 503:
      return "unavailable";
    case 504:
      return "deadline-exceeded";
  }
  return "unknown";
}
function OM(t, e) {
  let n = NM(t), r = n, i;
  try {
    const s = e && e.error;
    if (s) {
      const o = s.status;
      if (typeof o == "string") {
        if (!_y[o])
          return new Fs("internal", "internal");
        n = _y[o], r = o;
      }
      const a = s.message;
      typeof a == "string" && (r = a), i = s.details, i !== void 0 && (i = Kc(i));
    }
  } catch {
  }
  return n === "ok" ? null : new Fs(n, r, i);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PM {
  constructor(e, n, r) {
    this.auth = null, this.messaging = null, this.appCheck = null, this.auth = e.getImmediate({ optional: !0 }), this.messaging = n.getImmediate({
      optional: !0
    }), this.auth || e.get().then((i) => this.auth = i, () => {
    }), this.messaging || n.get().then((i) => this.messaging = i, () => {
    }), this.appCheck || r.get().then((i) => this.appCheck = i, () => {
    });
  }
  async getAuthToken() {
    if (this.auth)
      try {
        const e = await this.auth.getToken();
        return e == null ? void 0 : e.accessToken;
      } catch {
        return;
      }
  }
  async getMessagingToken() {
    if (!(!this.messaging || !("Notification" in self) || Notification.permission !== "granted"))
      try {
        return await this.messaging.getToken();
      } catch {
        return;
      }
  }
  async getAppCheckToken(e) {
    if (this.appCheck) {
      const n = e ? await this.appCheck.getLimitedUseToken() : await this.appCheck.getToken();
      return n.error ? null : n.token;
    }
    return null;
  }
  async getContext(e) {
    const n = await this.getAuthToken(), r = await this.getMessagingToken(), i = await this.getAppCheckToken(e);
    return { authToken: n, messagingToken: r, appCheckToken: i };
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sf = "us-central1";
function xM(t) {
  let e = null;
  return {
    promise: new Promise((n, r) => {
      e = setTimeout(() => {
        r(new Fs("deadline-exceeded", "deadline-exceeded"));
      }, t);
    }),
    cancel: () => {
      e && clearTimeout(e);
    }
  };
}
class MM {
  /**
   * Creates a new Functions service for the given app.
   * @param app - The FirebaseApp to use.
   */
  constructor(e, n, r, i, s = sf, o) {
    this.app = e, this.fetchImpl = o, this.emulatorOrigin = null, this.contextProvider = new PM(n, r, i), this.cancelAllRequests = new Promise((a) => {
      this.deleteService = () => Promise.resolve(a());
    });
    try {
      const a = new URL(s);
      this.customDomain = a.origin + (a.pathname === "/" ? "" : a.pathname), this.region = sf;
    } catch {
      this.customDomain = null, this.region = s;
    }
  }
  _delete() {
    return this.deleteService();
  }
  /**
   * Returns the URL for a callable with the given name.
   * @param name - The name of the callable.
   * @internal
   */
  _url(e) {
    const n = this.app.options.projectId;
    return this.emulatorOrigin !== null ? `${this.emulatorOrigin}/${n}/${this.region}/${e}` : this.customDomain !== null ? `${this.customDomain}/${e}` : `https://${this.region}-${n}.cloudfunctions.net/${e}`;
  }
}
function DM(t, e, n) {
  t.emulatorOrigin = `http://${e}:${n}`;
}
function LM(t, e, n) {
  return (r) => FM(t, e, r, {});
}
async function UM(t, e, n, r) {
  n["Content-Type"] = "application/json";
  let i;
  try {
    i = await r(t, {
      method: "POST",
      body: JSON.stringify(e),
      headers: n
    });
  } catch {
    return {
      status: 0,
      json: null
    };
  }
  let s = null;
  try {
    s = await i.json();
  } catch {
  }
  return {
    status: i.status,
    json: s
  };
}
function FM(t, e, n, r) {
  const i = t._url(e);
  return VM(t, i, n, r);
}
async function VM(t, e, n, r) {
  n = rf(n);
  const i = { data: n }, s = {}, o = await t.contextProvider.getContext(r.limitedUseAppCheckTokens);
  o.authToken && (s.Authorization = "Bearer " + o.authToken), o.messagingToken && (s["Firebase-Instance-ID-Token"] = o.messagingToken), o.appCheckToken !== null && (s["X-Firebase-AppCheck"] = o.appCheckToken);
  const a = r.timeout || 7e4, l = xM(a), u = await Promise.race([
    UM(e, i, s, t.fetchImpl),
    l.promise,
    t.cancelAllRequests
  ]);
  if (l.cancel(), !u)
    throw new Fs("cancelled", "Firebase Functions instance was deleted.");
  const d = OM(u.status, u.json);
  if (d)
    throw d;
  if (!u.json)
    throw new Fs("internal", "Response is not valid JSON object.");
  let f = u.json.data;
  if (typeof f > "u" && (f = u.json.result), typeof f > "u")
    throw new Fs("internal", "Response is missing data field.");
  return { data: Kc(f) };
}
const by = "@firebase/functions", vy = "0.11.8";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BM = "auth-internal", $M = "app-check-internal", jM = "messaging-internal";
function qM(t, e) {
  const n = (r, { instanceIdentifier: i }) => {
    const s = r.getProvider("app").getImmediate(), o = r.getProvider(BM), a = r.getProvider(jM), l = r.getProvider($M);
    return new MM(s, o, a, l, i, t);
  };
  bi(new Wr(
    np,
    n,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ).setMultipleInstances(!0)), $n(by, vy, e), $n(by, vy, "esm2017");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function l2(t = fl(), e = sf) {
  const r = ga(st(t), np).getImmediate({
    identifier: e
  }), i = Xf("functions");
  return i && zM(r, ...i), r;
}
function zM(t, e, n) {
  DM(st(t), e, n);
}
function u2(t, e, n) {
  return LM(st(t), e);
}
qM(fetch.bind(self));
var Uo = { exports: {} }, WM = Uo.exports, Ey;
function GM() {
  return Ey || (Ey = 1, function(t, e) {
    var n = typeof self < "u" ? self : WM, r = function() {
      function s() {
        this.fetch = !1, this.DOMException = n.DOMException;
      }
      return s.prototype = n, new s();
    }();
    (function(s) {
      (function(o) {
        var a = {
          searchParams: "URLSearchParams" in s,
          iterable: "Symbol" in s && "iterator" in Symbol,
          blob: "FileReader" in s && "Blob" in s && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(),
          formData: "FormData" in s,
          arrayBuffer: "ArrayBuffer" in s
        };
        function l(D) {
          return D && DataView.prototype.isPrototypeOf(D);
        }
        if (a.arrayBuffer)
          var u = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ], d = ArrayBuffer.isView || function(D) {
            return D && u.indexOf(Object.prototype.toString.call(D)) > -1;
          };
        function f(D) {
          if (typeof D != "string" && (D = String(D)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(D))
            throw new TypeError("Invalid character in header field name");
          return D.toLowerCase();
        }
        function p(D) {
          return typeof D != "string" && (D = String(D)), D;
        }
        function g(D) {
          var V = {
            next: function() {
              var X = D.shift();
              return { done: X === void 0, value: X };
            }
          };
          return a.iterable && (V[Symbol.iterator] = function() {
            return V;
          }), V;
        }
        function _(D) {
          this.map = {}, D instanceof _ ? D.forEach(function(V, X) {
            this.append(X, V);
          }, this) : Array.isArray(D) ? D.forEach(function(V) {
            this.append(V[0], V[1]);
          }, this) : D && Object.getOwnPropertyNames(D).forEach(function(V) {
            this.append(V, D[V]);
          }, this);
        }
        _.prototype.append = function(D, V) {
          D = f(D), V = p(V);
          var X = this.map[D];
          this.map[D] = X ? X + ", " + V : V;
        }, _.prototype.delete = function(D) {
          delete this.map[f(D)];
        }, _.prototype.get = function(D) {
          return D = f(D), this.has(D) ? this.map[D] : null;
        }, _.prototype.has = function(D) {
          return this.map.hasOwnProperty(f(D));
        }, _.prototype.set = function(D, V) {
          this.map[f(D)] = p(V);
        }, _.prototype.forEach = function(D, V) {
          for (var X in this.map)
            this.map.hasOwnProperty(X) && D.call(V, this.map[X], X, this);
        }, _.prototype.keys = function() {
          var D = [];
          return this.forEach(function(V, X) {
            D.push(X);
          }), g(D);
        }, _.prototype.values = function() {
          var D = [];
          return this.forEach(function(V) {
            D.push(V);
          }), g(D);
        }, _.prototype.entries = function() {
          var D = [];
          return this.forEach(function(V, X) {
            D.push([X, V]);
          }), g(D);
        }, a.iterable && (_.prototype[Symbol.iterator] = _.prototype.entries);
        function b(D) {
          if (D.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          D.bodyUsed = !0;
        }
        function m(D) {
          return new Promise(function(V, X) {
            D.onload = function() {
              V(D.result);
            }, D.onerror = function() {
              X(D.error);
            };
          });
        }
        function v(D) {
          var V = new FileReader(), X = m(V);
          return V.readAsArrayBuffer(D), X;
        }
        function C(D) {
          var V = new FileReader(), X = m(V);
          return V.readAsText(D), X;
        }
        function x(D) {
          for (var V = new Uint8Array(D), X = new Array(V.length), ge = 0; ge < V.length; ge++)
            X[ge] = String.fromCharCode(V[ge]);
          return X.join("");
        }
        function P(D) {
          if (D.slice)
            return D.slice(0);
          var V = new Uint8Array(D.byteLength);
          return V.set(new Uint8Array(D)), V.buffer;
        }
        function k() {
          return this.bodyUsed = !1, this._initBody = function(D) {
            this._bodyInit = D, D ? typeof D == "string" ? this._bodyText = D : a.blob && Blob.prototype.isPrototypeOf(D) ? this._bodyBlob = D : a.formData && FormData.prototype.isPrototypeOf(D) ? this._bodyFormData = D : a.searchParams && URLSearchParams.prototype.isPrototypeOf(D) ? this._bodyText = D.toString() : a.arrayBuffer && a.blob && l(D) ? (this._bodyArrayBuffer = P(D.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(D) || d(D)) ? this._bodyArrayBuffer = P(D) : this._bodyText = D = Object.prototype.toString.call(D) : this._bodyText = "", this.headers.get("content-type") || (typeof D == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(D) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
          }, a.blob && (this.blob = function() {
            var D = b(this);
            if (D)
              return D;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]));
          }, this.arrayBuffer = function() {
            return this._bodyArrayBuffer ? b(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(v);
          }), this.text = function() {
            var D = b(this);
            if (D)
              return D;
            if (this._bodyBlob)
              return C(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(x(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }, a.formData && (this.formData = function() {
            return this.text().then(T);
          }), this.json = function() {
            return this.text().then(JSON.parse);
          }, this;
        }
        var U = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function I(D) {
          var V = D.toUpperCase();
          return U.indexOf(V) > -1 ? V : D;
        }
        function E(D, V) {
          V = V || {};
          var X = V.body;
          if (D instanceof E) {
            if (D.bodyUsed)
              throw new TypeError("Already read");
            this.url = D.url, this.credentials = D.credentials, V.headers || (this.headers = new _(D.headers)), this.method = D.method, this.mode = D.mode, this.signal = D.signal, !X && D._bodyInit != null && (X = D._bodyInit, D.bodyUsed = !0);
          } else
            this.url = String(D);
          if (this.credentials = V.credentials || this.credentials || "same-origin", (V.headers || !this.headers) && (this.headers = new _(V.headers)), this.method = I(V.method || this.method || "GET"), this.mode = V.mode || this.mode || null, this.signal = V.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && X)
            throw new TypeError("Body not allowed for GET or HEAD requests");
          this._initBody(X);
        }
        E.prototype.clone = function() {
          return new E(this, { body: this._bodyInit });
        };
        function T(D) {
          var V = new FormData();
          return D.trim().split("&").forEach(function(X) {
            if (X) {
              var ge = X.split("="), Te = ge.shift().replace(/\+/g, " "), Ie = ge.join("=").replace(/\+/g, " ");
              V.append(decodeURIComponent(Te), decodeURIComponent(Ie));
            }
          }), V;
        }
        function A(D) {
          var V = new _(), X = D.replace(/\r?\n[\t ]+/g, " ");
          return X.split(/\r?\n/).forEach(function(ge) {
            var Te = ge.split(":"), Ie = Te.shift().trim();
            if (Ie) {
              var B = Te.join(":").trim();
              V.append(Ie, B);
            }
          }), V;
        }
        k.call(E.prototype);
        function R(D, V) {
          V || (V = {}), this.type = "default", this.status = V.status === void 0 ? 200 : V.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in V ? V.statusText : "OK", this.headers = new _(V.headers), this.url = V.url || "", this._initBody(D);
        }
        k.call(R.prototype), R.prototype.clone = function() {
          return new R(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new _(this.headers),
            url: this.url
          });
        }, R.error = function() {
          var D = new R(null, { status: 0, statusText: "" });
          return D.type = "error", D;
        };
        var M = [301, 302, 303, 307, 308];
        R.redirect = function(D, V) {
          if (M.indexOf(V) === -1)
            throw new RangeError("Invalid status code");
          return new R(null, { status: V, headers: { location: D } });
        }, o.DOMException = s.DOMException;
        try {
          new o.DOMException();
        } catch {
          o.DOMException = function(V, X) {
            this.message = V, this.name = X;
            var ge = Error(V);
            this.stack = ge.stack;
          }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
        }
        function S(D, V) {
          return new Promise(function(X, ge) {
            var Te = new E(D, V);
            if (Te.signal && Te.signal.aborted)
              return ge(new o.DOMException("Aborted", "AbortError"));
            var Ie = new XMLHttpRequest();
            function B() {
              Ie.abort();
            }
            Ie.onload = function() {
              var q = {
                status: Ie.status,
                statusText: Ie.statusText,
                headers: A(Ie.getAllResponseHeaders() || "")
              };
              q.url = "responseURL" in Ie ? Ie.responseURL : q.headers.get("X-Request-URL");
              var se = "response" in Ie ? Ie.response : Ie.responseText;
              X(new R(se, q));
            }, Ie.onerror = function() {
              ge(new TypeError("Network request failed"));
            }, Ie.ontimeout = function() {
              ge(new TypeError("Network request failed"));
            }, Ie.onabort = function() {
              ge(new o.DOMException("Aborted", "AbortError"));
            }, Ie.open(Te.method, Te.url, !0), Te.credentials === "include" ? Ie.withCredentials = !0 : Te.credentials === "omit" && (Ie.withCredentials = !1), "responseType" in Ie && a.blob && (Ie.responseType = "blob"), Te.headers.forEach(function(q, se) {
              Ie.setRequestHeader(se, q);
            }), Te.signal && (Te.signal.addEventListener("abort", B), Ie.onreadystatechange = function() {
              Ie.readyState === 4 && Te.signal.removeEventListener("abort", B);
            }), Ie.send(typeof Te._bodyInit > "u" ? null : Te._bodyInit);
          });
        }
        return S.polyfill = !0, s.fetch || (s.fetch = S, s.Headers = _, s.Request = E, s.Response = R), o.Headers = _, o.Request = E, o.Response = R, o.fetch = S, Object.defineProperty(o, "__esModule", { value: !0 }), o;
      })({});
    })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
    var i = r;
    e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e;
  }(Uo, Uo.exports)), Uo.exports;
}
var HM = GM();
function ye(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(d) {
      try {
        u(r.next(d));
      } catch (f) {
        o(f);
      }
    }
    function l(d) {
      try {
        u(r.throw(d));
      } catch (f) {
        o(f);
      }
    }
    function u(d) {
      d.done ? s(d.value) : i(d.value).then(a, l);
    }
    u((r = r.apply(t, [])).next());
  });
}
class Gt {
  constructor(e) {
    this.client = e;
  }
  static flatten(e, n = "") {
    let r = {};
    for (const [i, s] of Object.entries(e)) {
      let o = n ? n + "[" + i + "]" : i;
      Array.isArray(s) ? r = Object.assign(Object.assign({}, r), Gt.flatten(s, o)) : r[o] = s;
    }
    return r;
  }
}
Gt.CHUNK_SIZE = 5 * 1024 * 1024;
class G extends Error {
  constructor(e, n = 0, r = "", i = "") {
    super(e), this.name = "AppwriteException", this.message = e, this.code = n, this.type = r, this.response = i;
  }
}
class d2 {
  constructor() {
    this.config = {
      endpoint: "https://cloud.appwrite.io/v1",
      endpointRealtime: "",
      project: "",
      jwt: "",
      locale: "",
      session: ""
    }, this.headers = {
      "x-sdk-name": "Web",
      "x-sdk-platform": "client",
      "x-sdk-language": "web",
      "x-sdk-version": "14.0.1",
      "X-Appwrite-Response-Format": "1.5.0"
    }, this.realtime = {
      socket: void 0,
      timeout: void 0,
      url: "",
      channels: /* @__PURE__ */ new Set(),
      subscriptions: /* @__PURE__ */ new Map(),
      subscriptionsCounter: 0,
      reconnect: !0,
      reconnectAttempts: 0,
      lastMessage: void 0,
      connect: () => {
        clearTimeout(this.realtime.timeout), this.realtime.timeout = window == null ? void 0 : window.setTimeout(() => {
          this.realtime.createSocket();
        }, 50);
      },
      getTimeout: () => {
        switch (!0) {
          case this.realtime.reconnectAttempts < 5:
            return 1e3;
          case this.realtime.reconnectAttempts < 15:
            return 5e3;
          case this.realtime.reconnectAttempts < 100:
            return 1e4;
          default:
            return 6e4;
        }
      },
      createSocket: () => {
        var e, n, r;
        if (this.realtime.channels.size < 1) {
          this.realtime.reconnect = !1, (e = this.realtime.socket) === null || e === void 0 || e.close();
          return;
        }
        const i = new URLSearchParams();
        i.set("project", this.config.project), this.realtime.channels.forEach((o) => {
          i.append("channels[]", o);
        });
        const s = this.config.endpointRealtime + "/realtime?" + i.toString();
        (s !== this.realtime.url || // Check if URL is present
        !this.realtime.socket || // Check if WebSocket has not been created
        ((n = this.realtime.socket) === null || n === void 0 ? void 0 : n.readyState) > WebSocket.OPEN) && (this.realtime.socket && ((r = this.realtime.socket) === null || r === void 0 ? void 0 : r.readyState) < WebSocket.CLOSING && (this.realtime.reconnect = !1, this.realtime.socket.close()), this.realtime.url = s, this.realtime.socket = new WebSocket(s), this.realtime.socket.addEventListener("message", this.realtime.onMessage), this.realtime.socket.addEventListener("open", (o) => {
          this.realtime.reconnectAttempts = 0;
        }), this.realtime.socket.addEventListener("close", (o) => {
          var a, l, u;
          if (!this.realtime.reconnect || ((l = (a = this.realtime) === null || a === void 0 ? void 0 : a.lastMessage) === null || l === void 0 ? void 0 : l.type) === "error" && // Check if last message was of type error
          ((u = this.realtime) === null || u === void 0 ? void 0 : u.lastMessage.data).code === 1008) {
            this.realtime.reconnect = !0;
            return;
          }
          const d = this.realtime.getTimeout();
          console.error(`Realtime got disconnected. Reconnect will be attempted in ${d / 1e3} seconds.`, o.reason), setTimeout(() => {
            this.realtime.reconnectAttempts++, this.realtime.createSocket();
          }, d);
        }));
      },
      onMessage: (e) => {
        var n, r;
        try {
          const i = JSON.parse(e.data);
          switch (this.realtime.lastMessage = i, i.type) {
            case "connected":
              const s = JSON.parse((n = window.localStorage.getItem("cookieFallback")) !== null && n !== void 0 ? n : "{}"), o = s == null ? void 0 : s[`a_session_${this.config.project}`], a = i.data;
              o && !a.user && ((r = this.realtime.socket) === null || r === void 0 || r.send(JSON.stringify({
                type: "authentication",
                data: {
                  session: o
                }
              })));
              break;
            case "event":
              let l = i.data;
              if (l != null && l.channels) {
                if (!l.channels.some((d) => this.realtime.channels.has(d)))
                  return;
                this.realtime.subscriptions.forEach((d) => {
                  l.channels.some((f) => d.channels.includes(f)) && setTimeout(() => d.callback(l));
                });
              }
              break;
            case "error":
              throw i.data;
            default:
              break;
          }
        } catch (i) {
          console.error(i);
        }
      },
      cleanUp: (e) => {
        this.realtime.channels.forEach((n) => {
          e.includes(n) && (Array.from(this.realtime.subscriptions).some(([i, s]) => s.channels.includes(n)) || this.realtime.channels.delete(n));
        });
      }
    };
  }
  /**
   * Set Endpoint
   *
   * Your project endpoint
   *
   * @param {string} endpoint
   *
   * @returns {this}
   */
  setEndpoint(e) {
    return this.config.endpoint = e, this.config.endpointRealtime = this.config.endpointRealtime || this.config.endpoint.replace("https://", "wss://").replace("http://", "ws://"), this;
  }
  /**
   * Set Realtime Endpoint
   *
   * @param {string} endpointRealtime
   *
   * @returns {this}
   */
  setEndpointRealtime(e) {
    return this.config.endpointRealtime = e, this;
  }
  /**
   * Set Project
   *
   * Your project ID
   *
   * @param value string
   *
   * @return {this}
   */
  setProject(e) {
    return this.headers["X-Appwrite-Project"] = e, this.config.project = e, this;
  }
  /**
   * Set JWT
   *
   * Your secret JSON Web Token
   *
   * @param value string
   *
   * @return {this}
   */
  setJWT(e) {
    return this.headers["X-Appwrite-JWT"] = e, this.config.jwt = e, this;
  }
  /**
   * Set Locale
   *
   * @param value string
   *
   * @return {this}
   */
  setLocale(e) {
    return this.headers["X-Appwrite-Locale"] = e, this.config.locale = e, this;
  }
  /**
   * Set Session
   *
   * The user session to authenticate with
   *
   * @param value string
   *
   * @return {this}
   */
  setSession(e) {
    return this.headers["X-Appwrite-Session"] = e, this.config.session = e, this;
  }
  /**
   * Subscribes to Appwrite events and passes you the payload in realtime.
   *
   * @param {string|string[]} channels
   * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.
   *
   * Possible channels are:
   * - account
   * - collections
   * - collections.[ID]
   * - collections.[ID].documents
   * - documents
   * - documents.[ID]
   * - files
   * - files.[ID]
   * - executions
   * - executions.[ID]
   * - functions.[ID]
   * - teams
   * - teams.[ID]
   * - memberships
   * - memberships.[ID]
   * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.
   * @returns {() => void} Unsubscribes from events.
   */
  subscribe(e, n) {
    let r = typeof e == "string" ? [e] : e;
    r.forEach((s) => this.realtime.channels.add(s));
    const i = this.realtime.subscriptionsCounter++;
    return this.realtime.subscriptions.set(i, {
      channels: r,
      callback: n
    }), this.realtime.connect(), () => {
      this.realtime.subscriptions.delete(i), this.realtime.cleanUp(r), this.realtime.connect();
    };
  }
  call(e, n, r = {}, i = {}) {
    var s, o;
    return ye(this, void 0, void 0, function* () {
      e = e.toUpperCase(), r = Object.assign({}, this.headers, r);
      let a = {
        method: e,
        headers: r,
        credentials: "include"
      };
      if (typeof window < "u" && window.localStorage && (r["X-Fallback-Cookies"] = (s = window.localStorage.getItem("cookieFallback")) !== null && s !== void 0 ? s : ""), e === "GET")
        for (const [l, u] of Object.entries(Gt.flatten(i)))
          n.searchParams.append(l, u);
      else
        switch (r["content-type"]) {
          case "application/json":
            a.body = JSON.stringify(i);
            break;
          case "multipart/form-data":
            let l = new FormData();
            for (const u in i)
              Array.isArray(i[u]) ? i[u].forEach((d) => {
                l.append(u + "[]", d);
              }) : l.append(u, i[u]);
            a.body = l, delete r["content-type"];
            break;
        }
      try {
        let l = null;
        const u = yield HM.fetch(n.toString(), a);
        if (!((o = u.headers.get("content-type")) === null || o === void 0) && o.includes("application/json") ? l = yield u.json() : l = {
          message: yield u.text()
        }, 400 <= u.status)
          throw new G(l == null ? void 0 : l.message, u.status, l == null ? void 0 : l.type, l);
        const d = u.headers.get("X-Fallback-Cookies");
        return typeof window < "u" && window.localStorage && d && (window.console.warn("Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint."), window.localStorage.setItem("cookieFallback", d)), l;
      } catch (l) {
        throw l instanceof G ? l : new G(l.message);
      }
    });
  }
}
class f2 extends Gt {
  constructor(e) {
    super(e);
  }
  /**
   * Get account
   *
   * Get the currently logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  get() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("get", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Create account
   *
   * Use this endpoint to allow a new user to register a new account in your
   * project. After the user registration completes successfully, you can use
   * the
   * [/account/verfication](https://appwrite.io/docs/references/cloud/client-web/account#createVerification)
   * route to start verifying the user email address. To allow the new user to
   * login to their new account, you need to create a new [account
   * session](https://appwrite.io/docs/references/cloud/client-web/account#createEmailSession).
   *
   * @param {string} userId
   * @param {string} email
   * @param {string} password
   * @param {string} name
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  create(e, n, r, i) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "email"');
      if (typeof r > "u")
        throw new G('Missing required parameter: "password"');
      const s = "/account", o = {};
      typeof e < "u" && (o.userId = e), typeof n < "u" && (o.email = n), typeof r < "u" && (o.password = r), typeof i < "u" && (o.name = i);
      const a = new URL(this.client.config.endpoint + s);
      return yield this.client.call("post", a, {
        "content-type": "application/json"
      }, o);
    });
  }
  /**
   * Update email
   *
   * Update currently logged in user account email address. After changing user
   * address, the user confirmation status will get reset. A new confirmation
   * email is not sent automatically however you can use the send confirmation
   * email endpoint again to send the confirmation email. For security measures,
   * user password is required to complete this request.
   * This endpoint can also be used to convert an anonymous account to a normal
   * one, by passing an email address and a new password.
   *
   *
   * @param {string} email
   * @param {string} password
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateEmail(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "email"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "password"');
      const r = "/account/email", i = {};
      typeof e < "u" && (i.email = e), typeof n < "u" && (i.password = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("patch", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * List Identities
   *
   * Get the list of identities for the currently logged in user.
   *
   * @param {string[]} queries
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  listIdentities(e) {
    return ye(this, void 0, void 0, function* () {
      const n = "/account/identities", r = {};
      typeof e < "u" && (r.queries = e);
      const i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("get", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Delete identity
   *
   * Delete an identity by its unique ID.
   *
   * @param {string} identityId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  deleteIdentity(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "identityId"');
      const n = "/account/identities/{identityId}".replace("{identityId}", e), r = {}, i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("delete", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Create JWT
   *
   * Use this endpoint to create a JSON Web Token. You can use the resulting JWT
   * to authenticate on behalf of the current user when working with the
   * Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes
   * from its creation and will be invalid if the user will logout in that time
   * frame.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createJWT() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/jwt", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("post", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * List logs
   *
   * Get the list of latest security activity logs for the currently logged in
   * user. Each log returns user IP address, location and date and time of log.
   *
   * @param {string[]} queries
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  listLogs(e) {
    return ye(this, void 0, void 0, function* () {
      const n = "/account/logs", r = {};
      typeof e < "u" && (r.queries = e);
      const i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("get", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Update MFA
   *
   * Enable or disable MFA on an account.
   *
   * @param {boolean} mfa
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateMFA(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "mfa"');
      const n = "/account/mfa", r = {};
      typeof e < "u" && (r.mfa = e);
      const i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("patch", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Add Authenticator
   *
   * Add an authenticator app to be used as an MFA factor. Verify the
   * authenticator using the [verify
   * authenticator](/docs/references/cloud/client-web/account#verifyAuthenticator)
   * method.
   *
   * @param {AuthenticatorType} type
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createMfaAuthenticator(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "type"');
      const n = "/account/mfa/authenticators/{type}".replace("{type}", e), r = {}, i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("post", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Verify Authenticator
   *
   * Verify an authenticator app after adding it using the [add
   * authenticator](/docs/references/cloud/client-web/account#addAuthenticator)
   * method.
   *
   * @param {AuthenticatorType} type
   * @param {string} otp
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateMfaAuthenticator(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "type"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "otp"');
      const r = "/account/mfa/authenticators/{type}".replace("{type}", e), i = {};
      typeof n < "u" && (i.otp = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("put", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Delete Authenticator
   *
   * Delete an authenticator for a user by ID.
   *
   * @param {AuthenticatorType} type
   * @param {string} otp
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  deleteMfaAuthenticator(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "type"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "otp"');
      const r = "/account/mfa/authenticators/{type}".replace("{type}", e), i = {};
      typeof n < "u" && (i.otp = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("delete", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Create 2FA Challenge
   *
   * Begin the process of MFA verification after sign-in. Finish the flow with
   * [updateMfaChallenge](/docs/references/cloud/client-web/account#updateMfaChallenge)
   * method.
   *
   * @param {AuthenticationFactor} factor
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createMfaChallenge(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "factor"');
      const n = "/account/mfa/challenge", r = {};
      typeof e < "u" && (r.factor = e);
      const i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("post", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Create MFA Challenge (confirmation)
   *
   * Complete the MFA challenge by providing the one-time password. Finish the
   * process of MFA verification by providing the one-time password. To begin
   * the flow, use
   * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)
   * method.
   *
   * @param {string} challengeId
   * @param {string} otp
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateMfaChallenge(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "challengeId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "otp"');
      const r = "/account/mfa/challenge", i = {};
      typeof e < "u" && (i.challengeId = e), typeof n < "u" && (i.otp = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("put", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * List Factors
   *
   * List the factors available on the account to be used as a MFA challange.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  listMfaFactors() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/mfa/factors", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("get", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Get MFA Recovery Codes
   *
   * Get recovery codes that can be used as backup for MFA flow. Before getting
   * codes, they must be generated using
   * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)
   * method. An OTP challenge is required to read recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  getMfaRecoveryCodes() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/mfa/recovery-codes", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("get", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Create MFA Recovery Codes
   *
   * Generate recovery codes as backup for MFA flow. It's recommended to
   * generate and show then immediately after user successfully adds their
   * authehticator. Recovery codes can be used as a MFA verification type in
   * [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge)
   * method.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createMfaRecoveryCodes() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/mfa/recovery-codes", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("post", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Regenerate MFA Recovery Codes
   *
   * Regenerate recovery codes that can be used as backup for MFA flow. Before
   * regenerating codes, they must be first generated using
   * [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes)
   * method. An OTP challenge is required to regenreate recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateMfaRecoveryCodes() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/mfa/recovery-codes", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("patch", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Update name
   *
   * Update currently logged in user account name.
   *
   * @param {string} name
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateName(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "name"');
      const n = "/account/name", r = {};
      typeof e < "u" && (r.name = e);
      const i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("patch", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Update password
   *
   * Update currently logged in user password. For validation, user is required
   * to pass in the new password, and the old password. For users created with
   * OAuth, Team Invites and Magic URL, oldPassword is optional.
   *
   * @param {string} password
   * @param {string} oldPassword
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updatePassword(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "password"');
      const r = "/account/password", i = {};
      typeof e < "u" && (i.password = e), typeof n < "u" && (i.oldPassword = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("patch", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Update phone
   *
   * Update the currently logged in user's phone number. After updating the
   * phone number, the phone verification status will be reset. A confirmation
   * SMS is not sent automatically, however you can use the [POST
   * /account/verification/phone](https://appwrite.io/docs/references/cloud/client-web/account#createPhoneVerification)
   * endpoint to send a confirmation SMS.
   *
   * @param {string} phone
   * @param {string} password
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updatePhone(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "phone"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "password"');
      const r = "/account/phone", i = {};
      typeof e < "u" && (i.phone = e), typeof n < "u" && (i.password = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("patch", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Get account preferences
   *
   * Get the preferences as a key-value object for the currently logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  getPrefs() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/prefs", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("get", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Update preferences
   *
   * Update currently logged in user account preferences. The object you pass is
   * stored as is, and replaces any previous value. The maximum allowed prefs
   * size is 64kB and throws error if exceeded.
   *
   * @param {Partial<Preferences>} prefs
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updatePrefs(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "prefs"');
      const n = "/account/prefs", r = {};
      typeof e < "u" && (r.prefs = e);
      const i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("patch", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Create password recovery
   *
   * Sends the user an email with a temporary secret key for password reset.
   * When the user clicks the confirmation link he is redirected back to your
   * app password reset URL with the secret key and email address values
   * attached to the URL query string. Use the query string params to submit a
   * request to the [PUT
   * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#updateRecovery)
   * endpoint to complete the process. The verification link sent to the user's
   * email address is valid for 1 hour.
   *
   * @param {string} email
   * @param {string} url
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createRecovery(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "email"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "url"');
      const r = "/account/recovery", i = {};
      typeof e < "u" && (i.email = e), typeof n < "u" && (i.url = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("post", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Create password recovery (confirmation)
   *
   * Use this endpoint to complete the user account password reset. Both the
   * **userId** and **secret** arguments will be passed as query parameters to
   * the redirect URL you have provided when sending your request to the [POST
   * /account/recovery](https://appwrite.io/docs/references/cloud/client-web/account#createRecovery)
   * endpoint.
   *
   * Please note that in order to avoid a [Redirect
   * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md)
   * the only valid redirect URLs are the ones from domains you have set when
   * adding your platforms in the console interface.
   *
   * @param {string} userId
   * @param {string} secret
   * @param {string} password
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateRecovery(e, n, r) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "secret"');
      if (typeof r > "u")
        throw new G('Missing required parameter: "password"');
      const i = "/account/recovery", s = {};
      typeof e < "u" && (s.userId = e), typeof n < "u" && (s.secret = n), typeof r < "u" && (s.password = r);
      const o = new URL(this.client.config.endpoint + i);
      return yield this.client.call("put", o, {
        "content-type": "application/json"
      }, s);
    });
  }
  /**
   * List sessions
   *
   * Get the list of active sessions across different devices for the currently
   * logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  listSessions() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/sessions", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("get", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Delete sessions
   *
   * Delete all sessions from the user account and remove any sessions cookies
   * from the end client.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  deleteSessions() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/sessions", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("delete", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Create anonymous session
   *
   * Use this endpoint to allow a new user to register an anonymous account in
   * your project. This route will also create a new session for the user. To
   * allow the new user to convert an anonymous account to a normal account, you
   * need to update its [email and
   * password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail)
   * or create an [OAuth2
   * session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createAnonymousSession() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/sessions/anonymous", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("post", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Create email password session
   *
   * Allow the user to login into their account by providing a valid email and
   * password combination. This route will create a new session for the user.
   *
   * A user is limited to 10 active sessions at a time by default. [Learn more
   * about session
   * limits](https://appwrite.io/docs/authentication-security#limits).
   *
   * @param {string} email
   * @param {string} password
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createEmailPasswordSession(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "email"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "password"');
      const r = "/account/sessions/email", i = {};
      typeof e < "u" && (i.email = e), typeof n < "u" && (i.password = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("post", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Update magic URL session
   *
   * Use this endpoint to create a session from token. Provide the **userId**
   * and **secret** parameters from the successful response of authentication
   * flows initiated by token creation. For example, magic URL and phone login.
   *
   * @param {string} userId
   * @param {string} secret
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateMagicURLSession(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "secret"');
      const r = "/account/sessions/magic-url", i = {};
      typeof e < "u" && (i.userId = e), typeof n < "u" && (i.secret = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("put", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Create OAuth2 session
   *
   * Allow the user to login to their account using the OAuth2 provider of their
   * choice. Each OAuth2 provider should be enabled from the Appwrite console
   * first. Use the success and failure arguments to provide a redirect URL's
   * back to your app when login is completed.
   *
   * If there is already an active session, the new session will be attached to
   * the logged-in account. If there are no active sessions, the server will
   * attempt to look for a user with the same email address as the email
   * received from the OAuth2 provider and attach the new session to the
   * existing user. If no matching user is found - the server will create a new
   * user.
   *
   * A user is limited to 10 active sessions at a time by default. [Learn more
   * about session
   * limits](https://appwrite.io/docs/authentication-security#limits).
   *
   *
   * @param {OAuthProvider} provider
   * @param {string} success
   * @param {string} failure
   * @param {string[]} scopes
   * @throws {AppwriteException}
   * @returns {void|string}
  */
  createOAuth2Session(e, n, r, i) {
    if (typeof e > "u")
      throw new G('Missing required parameter: "provider"');
    const s = "/account/sessions/oauth2/{provider}".replace("{provider}", e), o = {};
    typeof n < "u" && (o.success = n), typeof r < "u" && (o.failure = r), typeof i < "u" && (o.scopes = i);
    const a = new URL(this.client.config.endpoint + s);
    o.project = this.client.config.project;
    for (const [l, u] of Object.entries(Gt.flatten(o)))
      a.searchParams.append(l, u);
    if (typeof window < "u" && (window != null && window.location))
      window.location.href = a.toString();
    else
      return a;
  }
  /**
   * Update phone session
   *
   * Use this endpoint to create a session from token. Provide the **userId**
   * and **secret** parameters from the successful response of authentication
   * flows initiated by token creation. For example, magic URL and phone login.
   *
   * @param {string} userId
   * @param {string} secret
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updatePhoneSession(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "secret"');
      const r = "/account/sessions/phone", i = {};
      typeof e < "u" && (i.userId = e), typeof n < "u" && (i.secret = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("put", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Create session
   *
   * Use this endpoint to create a session from token. Provide the **userId**
   * and **secret** parameters from the successful response of authentication
   * flows initiated by token creation. For example, magic URL and phone login.
   *
   * @param {string} userId
   * @param {string} secret
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createSession(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "secret"');
      const r = "/account/sessions/token", i = {};
      typeof e < "u" && (i.userId = e), typeof n < "u" && (i.secret = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("post", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Get session
   *
   * Use this endpoint to get a logged in user's session using a Session ID.
   * Inputting 'current' will return the current session being used.
   *
   * @param {string} sessionId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  getSession(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "sessionId"');
      const n = "/account/sessions/{sessionId}".replace("{sessionId}", e), r = {}, i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("get", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Update session
   *
   * Use this endpoint to extend a session's length. Extending a session is
   * useful when session expiry is short. If the session was created using an
   * OAuth provider, this endpoint refreshes the access token from the provider.
   *
   * @param {string} sessionId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateSession(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "sessionId"');
      const n = "/account/sessions/{sessionId}".replace("{sessionId}", e), r = {}, i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("patch", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Delete session
   *
   * Logout the user. Use 'current' as the session ID to logout on this device,
   * use a session ID to logout on another device. If you're looking to logout
   * the user on all devices, use [Delete
   * Sessions](https://appwrite.io/docs/references/cloud/client-web/account#deleteSessions)
   * instead.
   *
   * @param {string} sessionId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  deleteSession(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "sessionId"');
      const n = "/account/sessions/{sessionId}".replace("{sessionId}", e), r = {}, i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("delete", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Update status
   *
   * Block the currently logged in user account. Behind the scene, the user
   * record is not deleted but permanently blocked from any access. To
   * completely delete a user, use the Users API instead.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateStatus() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/status", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("patch", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Create push target
   *
   *
   * @param {string} targetId
   * @param {string} identifier
   * @param {string} providerId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createPushTarget(e, n, r) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "targetId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "identifier"');
      const i = "/account/targets/push", s = {};
      typeof e < "u" && (s.targetId = e), typeof n < "u" && (s.identifier = n), typeof r < "u" && (s.providerId = r);
      const o = new URL(this.client.config.endpoint + i);
      return yield this.client.call("post", o, {
        "content-type": "application/json"
      }, s);
    });
  }
  /**
   * Update push target
   *
   *
   * @param {string} targetId
   * @param {string} identifier
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updatePushTarget(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "targetId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "identifier"');
      const r = "/account/targets/{targetId}/push".replace("{targetId}", e), i = {};
      typeof n < "u" && (i.identifier = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("put", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Delete push target
   *
   *
   * @param {string} targetId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  deletePushTarget(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "targetId"');
      const n = "/account/targets/{targetId}/push".replace("{targetId}", e), r = {}, i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("delete", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Create email token (OTP)
   *
   * Sends the user an email with a secret key for creating a session. If the
   * provided user ID has not be registered, a new user will be created. Use the
   * returned user ID and secret and submit a request to the [POST
   * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)
   * endpoint to complete the login process. The secret sent to the user's email
   * is valid for 15 minutes.
   *
   * A user is limited to 10 active sessions at a time by default. [Learn more
   * about session
   * limits](https://appwrite.io/docs/authentication-security#limits).
   *
   * @param {string} userId
   * @param {string} email
   * @param {boolean} phrase
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createEmailToken(e, n, r) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "email"');
      const i = "/account/tokens/email", s = {};
      typeof e < "u" && (s.userId = e), typeof n < "u" && (s.email = n), typeof r < "u" && (s.phrase = r);
      const o = new URL(this.client.config.endpoint + i);
      return yield this.client.call("post", o, {
        "content-type": "application/json"
      }, s);
    });
  }
  /**
   * Create magic URL token
   *
   * Sends the user an email with a secret key for creating a session. If the
   * provided user ID has not been registered, a new user will be created. When
   * the user clicks the link in the email, the user is redirected back to the
   * URL you provided with the secret key and userId values attached to the URL
   * query string. Use the query string parameters to submit a request to the
   * [POST
   * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)
   * endpoint to complete the login process. The link sent to the user's email
   * address is valid for 1 hour. If you are on a mobile device you can leave
   * the URL parameter empty, so that the login completion will be handled by
   * your Appwrite instance by default.
   *
   * A user is limited to 10 active sessions at a time by default. [Learn more
   * about session
   * limits](https://appwrite.io/docs/authentication-security#limits).
   *
   *
   * @param {string} userId
   * @param {string} email
   * @param {string} url
   * @param {boolean} phrase
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createMagicURLToken(e, n, r, i) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "email"');
      const s = "/account/tokens/magic-url", o = {};
      typeof e < "u" && (o.userId = e), typeof n < "u" && (o.email = n), typeof r < "u" && (o.url = r), typeof i < "u" && (o.phrase = i);
      const a = new URL(this.client.config.endpoint + s);
      return yield this.client.call("post", a, {
        "content-type": "application/json"
      }, o);
    });
  }
  /**
   * Create OAuth2 token
   *
   * Allow the user to login to their account using the OAuth2 provider of their
   * choice. Each OAuth2 provider should be enabled from the Appwrite console
   * first. Use the success and failure arguments to provide a redirect URL's
   * back to your app when login is completed.
   *
   * If authentication succeeds, `userId` and `secret` of a token will be
   * appended to the success URL as query parameters. These can be used to
   * create a new session using the [Create
   * session](https://appwrite.io/docs/references/cloud/client-web/account#createSession)
   * endpoint.
   *
   * A user is limited to 10 active sessions at a time by default. [Learn more
   * about session
   * limits](https://appwrite.io/docs/authentication-security#limits).
   *
   * @param {OAuthProvider} provider
   * @param {string} success
   * @param {string} failure
   * @param {string[]} scopes
   * @throws {AppwriteException}
   * @returns {void|string}
  */
  createOAuth2Token(e, n, r, i) {
    if (typeof e > "u")
      throw new G('Missing required parameter: "provider"');
    const s = "/account/tokens/oauth2/{provider}".replace("{provider}", e), o = {};
    typeof n < "u" && (o.success = n), typeof r < "u" && (o.failure = r), typeof i < "u" && (o.scopes = i);
    const a = new URL(this.client.config.endpoint + s);
    o.project = this.client.config.project;
    for (const [l, u] of Object.entries(Gt.flatten(o)))
      a.searchParams.append(l, u);
    if (typeof window < "u" && (window != null && window.location))
      window.location.href = a.toString();
    else
      return a;
  }
  /**
   * Create phone token
   *
   * Sends the user an SMS with a secret key for creating a session. If the
   * provided user ID has not be registered, a new user will be created. Use the
   * returned user ID and secret and submit a request to the [POST
   * /v1/account/sessions/token](https://appwrite.io/docs/references/cloud/client-web/account#createSession)
   * endpoint to complete the login process. The secret sent to the user's phone
   * is valid for 15 minutes.
   *
   * A user is limited to 10 active sessions at a time by default. [Learn more
   * about session
   * limits](https://appwrite.io/docs/authentication-security#limits).
   *
   * @param {string} userId
   * @param {string} phone
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createPhoneToken(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "phone"');
      const r = "/account/tokens/phone", i = {};
      typeof e < "u" && (i.userId = e), typeof n < "u" && (i.phone = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("post", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Create email verification
   *
   * Use this endpoint to send a verification message to your user email address
   * to confirm they are the valid owners of that address. Both the **userId**
   * and **secret** arguments will be passed as query parameters to the URL you
   * have provided to be attached to the verification email. The provided URL
   * should redirect the user back to your app and allow you to complete the
   * verification process by verifying both the **userId** and **secret**
   * parameters. Learn more about how to [complete the verification
   * process](https://appwrite.io/docs/references/cloud/client-web/account#updateVerification).
   * The verification link sent to the user's email address is valid for 7 days.
   *
   * Please note that in order to avoid a [Redirect
   * Attack](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md),
   * the only valid redirect URLs are the ones from domains you have set when
   * adding your platforms in the console interface.
   *
   *
   * @param {string} url
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createVerification(e) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "url"');
      const n = "/account/verification", r = {};
      typeof e < "u" && (r.url = e);
      const i = new URL(this.client.config.endpoint + n);
      return yield this.client.call("post", i, {
        "content-type": "application/json"
      }, r);
    });
  }
  /**
   * Create email verification (confirmation)
   *
   * Use this endpoint to complete the user email verification process. Use both
   * the **userId** and **secret** parameters that were attached to your app URL
   * to verify the user email ownership. If confirmed this route will return a
   * 200 status code.
   *
   * @param {string} userId
   * @param {string} secret
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateVerification(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "secret"');
      const r = "/account/verification", i = {};
      typeof e < "u" && (i.userId = e), typeof n < "u" && (i.secret = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("put", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Create phone verification
   *
   * Use this endpoint to send a verification SMS to the currently logged in
   * user. This endpoint is meant for use after updating a user's phone number
   * using the
   * [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone)
   * endpoint. Learn more about how to [complete the verification
   * process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification).
   * The verification code sent to the user's phone number is valid for 15
   * minutes.
   *
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createPhoneVerification() {
    return ye(this, void 0, void 0, function* () {
      const e = "/account/verification/phone", n = {}, r = new URL(this.client.config.endpoint + e);
      return yield this.client.call("post", r, {
        "content-type": "application/json"
      }, n);
    });
  }
  /**
   * Create phone verification (confirmation)
   *
   * Use this endpoint to complete the user phone verification process. Use the
   * **userId** and **secret** that were sent to your user's phone number to
   * verify the user email ownership. If confirmed this route will return a 200
   * status code.
   *
   * @param {string} userId
   * @param {string} secret
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updatePhoneVerification(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "userId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "secret"');
      const r = "/account/verification/phone", i = {};
      typeof e < "u" && (i.userId = e), typeof n < "u" && (i.secret = n);
      const s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("put", s, {
        "content-type": "application/json"
      }, i);
    });
  }
}
class h2 extends Gt {
  constructor(e) {
    super(e);
  }
  /**
   * List documents
   *
   * Get a list of all the user's documents in a given collection. You can use
   * the query params to filter your results.
   *
   * @param {string} databaseId
   * @param {string} collectionId
   * @param {string[]} queries
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  listDocuments(e, n, r) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "databaseId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "collectionId"');
      const i = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", e).replace("{collectionId}", n), s = {};
      typeof r < "u" && (s.queries = r);
      const o = new URL(this.client.config.endpoint + i);
      return yield this.client.call("get", o, {
        "content-type": "application/json"
      }, s);
    });
  }
  /**
   * Create document
   *
   * Create a new Document. Before using this route, you should create a new
   * collection resource using either a [server
   * integration](https://appwrite.io/docs/server/databases#databasesCreateCollection)
   * API or directly from your database console.
   *
   * @param {string} databaseId
   * @param {string} collectionId
   * @param {string} documentId
   * @param {Omit<Document, keyof Models.Document>} data
   * @param {string[]} permissions
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createDocument(e, n, r, i, s) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "databaseId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "collectionId"');
      if (typeof r > "u")
        throw new G('Missing required parameter: "documentId"');
      if (typeof i > "u")
        throw new G('Missing required parameter: "data"');
      const o = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", e).replace("{collectionId}", n), a = {};
      typeof r < "u" && (a.documentId = r), typeof i < "u" && (a.data = i), typeof s < "u" && (a.permissions = s);
      const l = new URL(this.client.config.endpoint + o);
      return yield this.client.call("post", l, {
        "content-type": "application/json"
      }, a);
    });
  }
  /**
   * Get document
   *
   * Get a document by its unique ID. This endpoint response returns a JSON
   * object with the document data.
   *
   * @param {string} databaseId
   * @param {string} collectionId
   * @param {string} documentId
   * @param {string[]} queries
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  getDocument(e, n, r, i) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "databaseId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "collectionId"');
      if (typeof r > "u")
        throw new G('Missing required parameter: "documentId"');
      const s = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", e).replace("{collectionId}", n).replace("{documentId}", r), o = {};
      typeof i < "u" && (o.queries = i);
      const a = new URL(this.client.config.endpoint + s);
      return yield this.client.call("get", a, {
        "content-type": "application/json"
      }, o);
    });
  }
  /**
   * Update document
   *
   * Update a document by its unique ID. Using the patch method you can pass
   * only specific fields that will get updated.
   *
   * @param {string} databaseId
   * @param {string} collectionId
   * @param {string} documentId
   * @param {Partial<Omit<Document, keyof Models.Document>>} data
   * @param {string[]} permissions
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateDocument(e, n, r, i, s) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "databaseId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "collectionId"');
      if (typeof r > "u")
        throw new G('Missing required parameter: "documentId"');
      const o = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", e).replace("{collectionId}", n).replace("{documentId}", r), a = {};
      typeof i < "u" && (a.data = i), typeof s < "u" && (a.permissions = s);
      const l = new URL(this.client.config.endpoint + o);
      return yield this.client.call("patch", l, {
        "content-type": "application/json"
      }, a);
    });
  }
  /**
   * Delete document
   *
   * Delete a document by its unique ID.
   *
   * @param {string} databaseId
   * @param {string} collectionId
   * @param {string} documentId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  deleteDocument(e, n, r) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "databaseId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "collectionId"');
      if (typeof r > "u")
        throw new G('Missing required parameter: "documentId"');
      const i = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", e).replace("{collectionId}", n).replace("{documentId}", r), s = {}, o = new URL(this.client.config.endpoint + i);
      return yield this.client.call("delete", o, {
        "content-type": "application/json"
      }, s);
    });
  }
}
class p2 extends Gt {
  constructor(e) {
    super(e);
  }
  /**
   * List executions
   *
   * Get a list of all the current user function execution logs. You can use the
   * query params to filter your results.
   *
   * @param {string} functionId
   * @param {string[]} queries
   * @param {string} search
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  listExecutions(e, n, r) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "functionId"');
      const i = "/functions/{functionId}/executions".replace("{functionId}", e), s = {};
      typeof n < "u" && (s.queries = n), typeof r < "u" && (s.search = r);
      const o = new URL(this.client.config.endpoint + i);
      return yield this.client.call("get", o, {
        "content-type": "application/json"
      }, s);
    });
  }
  /**
   * Create execution
   *
   * Trigger a function execution. The returned object will return you the
   * current execution status. You can ping the `Get Execution` endpoint to get
   * updates on the current execution status. Once this endpoint is called, your
   * function execution process will start asynchronously.
   *
   * @param {string} functionId
   * @param {string} body
   * @param {boolean} async
   * @param {string} xpath
   * @param {ExecutionMethod} method
   * @param {object} headers
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createExecution(e, n, r, i, s, o) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "functionId"');
      const a = "/functions/{functionId}/executions".replace("{functionId}", e), l = {};
      typeof n < "u" && (l.body = n), typeof r < "u" && (l.async = r), typeof i < "u" && (l.path = i), typeof s < "u" && (l.method = s), typeof o < "u" && (l.headers = o);
      const u = new URL(this.client.config.endpoint + a);
      return yield this.client.call("post", u, {
        "content-type": "application/json"
      }, l);
    });
  }
  /**
   * Get execution
   *
   * Get a function execution log by its unique ID.
   *
   * @param {string} functionId
   * @param {string} executionId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  getExecution(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "functionId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "executionId"');
      const r = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", e).replace("{executionId}", n), i = {}, s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("get", s, {
        "content-type": "application/json"
      }, i);
    });
  }
}
class m2 extends Gt {
  constructor(e) {
    super(e);
  }
  /**
   * List files
   *
   * Get a list of all the user files. You can use the query params to filter
   * your results.
   *
   * @param {string} bucketId
   * @param {string[]} queries
   * @param {string} search
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  listFiles(e, n, r) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "bucketId"');
      const i = "/storage/buckets/{bucketId}/files".replace("{bucketId}", e), s = {};
      typeof n < "u" && (s.queries = n), typeof r < "u" && (s.search = r);
      const o = new URL(this.client.config.endpoint + i);
      return yield this.client.call("get", o, {
        "content-type": "application/json"
      }, s);
    });
  }
  /**
   * Create file
   *
   * Create a new file. Before using this route, you should create a new bucket
   * resource using either a [server
   * integration](https://appwrite.io/docs/server/storage#storageCreateBucket)
   * API or directly from your Appwrite console.
   *
   * Larger files should be uploaded using multiple requests with the
   * [content-range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range)
   * header to send a partial request with a maximum supported chunk of `5MB`.
   * The `content-range` header values should always be in bytes.
   *
   * When the first request is sent, the server will return the **File** object,
   * and the subsequent part request must include the file's **id** in
   * `x-appwrite-id` header to allow the server to know that the partial upload
   * is for the existing file and not for a new one.
   *
   * If you're creating a new file using one of the Appwrite SDKs, all the
   * chunking logic will be managed by the SDK internally.
   *
   *
   * @param {string} bucketId
   * @param {string} fileId
   * @param {File} file
   * @param {string[]} permissions
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  createFile(e, n, r, i, s = (o) => {
  }) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "bucketId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "fileId"');
      if (typeof r > "u")
        throw new G('Missing required parameter: "file"');
      const o = "/storage/buckets/{bucketId}/files".replace("{bucketId}", e), a = {};
      typeof n < "u" && (a.fileId = n), typeof r < "u" && (a.file = r), typeof i < "u" && (a.permissions = i);
      const l = new URL(this.client.config.endpoint + o);
      if (!(r instanceof File))
        throw new G('Parameter "file" has to be a File.');
      const u = r.size;
      if (u <= Gt.CHUNK_SIZE)
        return yield this.client.call("post", l, {
          "content-type": "multipart/form-data"
        }, a);
      const d = {
        "content-type": "multipart/form-data"
      };
      let f = 0, p;
      if (n != "unique()")
        try {
          p = yield this.client.call("GET", new URL(this.client.config.endpoint + o + "/" + n), d), f = p.chunksUploaded * Gt.CHUNK_SIZE;
        } catch {
        }
      for (; f < u; ) {
        let g = Math.min(f + Gt.CHUNK_SIZE - 1, u - 1);
        d["content-range"] = "bytes " + f + "-" + g + "/" + u, p && p.$id && (d["x-appwrite-id"] = p.$id);
        const _ = r.slice(f, g + 1);
        a.file = new File([_], r.name), p = yield this.client.call("post", l, d, a), s && s({
          $id: p.$id,
          progress: f / u * 100,
          sizeUploaded: f,
          chunksTotal: p.chunksTotal,
          chunksUploaded: p.chunksUploaded
        }), f += Gt.CHUNK_SIZE;
      }
      return p;
    });
  }
  /**
   * Get file
   *
   * Get a file by its unique ID. This endpoint response returns a JSON object
   * with the file metadata.
   *
   * @param {string} bucketId
   * @param {string} fileId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  getFile(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "bucketId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "fileId"');
      const r = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", e).replace("{fileId}", n), i = {}, s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("get", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Update file
   *
   * Update a file by its unique ID. Only users with write permissions have
   * access to update this resource.
   *
   * @param {string} bucketId
   * @param {string} fileId
   * @param {string} name
   * @param {string[]} permissions
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  updateFile(e, n, r, i) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "bucketId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "fileId"');
      const s = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", e).replace("{fileId}", n), o = {};
      typeof r < "u" && (o.name = r), typeof i < "u" && (o.permissions = i);
      const a = new URL(this.client.config.endpoint + s);
      return yield this.client.call("put", a, {
        "content-type": "application/json"
      }, o);
    });
  }
  /**
   * Delete File
   *
   * Delete a file by its unique ID. Only users with write permissions have
   * access to delete this resource.
   *
   * @param {string} bucketId
   * @param {string} fileId
   * @throws {AppwriteException}
   * @returns {Promise}
  */
  deleteFile(e, n) {
    return ye(this, void 0, void 0, function* () {
      if (typeof e > "u")
        throw new G('Missing required parameter: "bucketId"');
      if (typeof n > "u")
        throw new G('Missing required parameter: "fileId"');
      const r = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", e).replace("{fileId}", n), i = {}, s = new URL(this.client.config.endpoint + r);
      return yield this.client.call("delete", s, {
        "content-type": "application/json"
      }, i);
    });
  }
  /**
   * Get file for download
   *
   * Get a file content by its unique ID. The endpoint response return with a
   * 'Content-Disposition: attachment' header that tells the browser to start
   * downloading the file to user downloads directory.
   *
   * @param {string} bucketId
   * @param {string} fileId
   * @throws {AppwriteException}
   * @returns {URL}
  */
  getFileDownload(e, n) {
    if (typeof e > "u")
      throw new G('Missing required parameter: "bucketId"');
    if (typeof n > "u")
      throw new G('Missing required parameter: "fileId"');
    const r = "/storage/buckets/{bucketId}/files/{fileId}/download".replace("{bucketId}", e).replace("{fileId}", n), i = {}, s = new URL(this.client.config.endpoint + r);
    i.project = this.client.config.project;
    for (const [o, a] of Object.entries(Gt.flatten(i)))
      s.searchParams.append(o, a);
    return s;
  }
  /**
   * Get file preview
   *
   * Get a file preview image. Currently, this method supports preview for image
   * files (jpg, png, and gif), other supported formats, like pdf, docs, slides,
   * and spreadsheets, will return the file icon image. You can also pass query
   * string arguments for cutting and resizing your preview image. Preview is
   * supported only for image files smaller than 10MB.
   *
   * @param {string} bucketId
   * @param {string} fileId
   * @param {number} width
   * @param {number} height
   * @param {ImageGravity} gravity
   * @param {number} quality
   * @param {number} borderWidth
   * @param {string} borderColor
   * @param {number} borderRadius
   * @param {number} opacity
   * @param {number} rotation
   * @param {string} background
   * @param {ImageFormat} output
   * @throws {AppwriteException}
   * @returns {URL}
  */
  getFilePreview(e, n, r, i, s, o, a, l, u, d, f, p, g) {
    if (typeof e > "u")
      throw new G('Missing required parameter: "bucketId"');
    if (typeof n > "u")
      throw new G('Missing required parameter: "fileId"');
    const _ = "/storage/buckets/{bucketId}/files/{fileId}/preview".replace("{bucketId}", e).replace("{fileId}", n), b = {};
    typeof r < "u" && (b.width = r), typeof i < "u" && (b.height = i), typeof s < "u" && (b.gravity = s), typeof o < "u" && (b.quality = o), typeof a < "u" && (b.borderWidth = a), typeof l < "u" && (b.borderColor = l), typeof u < "u" && (b.borderRadius = u), typeof d < "u" && (b.opacity = d), typeof f < "u" && (b.rotation = f), typeof p < "u" && (b.background = p), typeof g < "u" && (b.output = g);
    const m = new URL(this.client.config.endpoint + _);
    b.project = this.client.config.project;
    for (const [v, C] of Object.entries(Gt.flatten(b)))
      m.searchParams.append(v, C);
    return m;
  }
  /**
   * Get file for view
   *
   * Get a file content by its unique ID. This endpoint is similar to the
   * download method but returns with no  'Content-Disposition: attachment'
   * header.
   *
   * @param {string} bucketId
   * @param {string} fileId
   * @throws {AppwriteException}
   * @returns {URL}
  */
  getFileView(e, n) {
    if (typeof e > "u")
      throw new G('Missing required parameter: "bucketId"');
    if (typeof n > "u")
      throw new G('Missing required parameter: "fileId"');
    const r = "/storage/buckets/{bucketId}/files/{fileId}/view".replace("{bucketId}", e).replace("{fileId}", n), i = {}, s = new URL(this.client.config.endpoint + r);
    i.project = this.client.config.project;
    for (const [o, a] of Object.entries(Gt.flatten(i)))
      s.searchParams.append(o, a);
    return s;
  }
}
var wy;
(function(t) {
  t.Totp = "totp";
})(wy || (wy = {}));
var Ty;
(function(t) {
  t.Email = "email", t.Phone = "phone", t.Totp = "totp", t.Recoverycode = "recoverycode";
})(Ty || (Ty = {}));
var Iy;
(function(t) {
  t.Amazon = "amazon", t.Apple = "apple", t.Auth0 = "auth0", t.Authentik = "authentik", t.Autodesk = "autodesk", t.Bitbucket = "bitbucket", t.Bitly = "bitly", t.Box = "box", t.Dailymotion = "dailymotion", t.Discord = "discord", t.Disqus = "disqus", t.Dropbox = "dropbox", t.Etsy = "etsy", t.Facebook = "facebook", t.Github = "github", t.Gitlab = "gitlab", t.Google = "google", t.Linkedin = "linkedin", t.Microsoft = "microsoft", t.Notion = "notion", t.Oidc = "oidc", t.Okta = "okta", t.Paypal = "paypal", t.PaypalSandbox = "paypalSandbox", t.Podio = "podio", t.Salesforce = "salesforce", t.Slack = "slack", t.Spotify = "spotify", t.Stripe = "stripe", t.Tradeshift = "tradeshift", t.TradeshiftBox = "tradeshiftBox", t.Twitch = "twitch", t.Wordpress = "wordpress", t.Yahoo = "yahoo", t.Yammer = "yammer", t.Yandex = "yandex", t.Zoho = "zoho", t.Zoom = "zoom", t.Mock = "mock";
})(Iy || (Iy = {}));
var Sy;
(function(t) {
  t.AvantBrowser = "aa", t.AndroidWebViewBeta = "an", t.GoogleChrome = "ch", t.GoogleChromeIOS = "ci", t.GoogleChromeMobile = "cm", t.Chromium = "cr", t.MozillaFirefox = "ff", t.Safari = "sf", t.MobileSafari = "mf", t.MicrosoftEdge = "ps", t.MicrosoftEdgeIOS = "oi", t.OperaMini = "om", t.Opera = "op", t.OperaNext = "on";
})(Sy || (Sy = {}));
var Ay;
(function(t) {
  t.AmericanExpress = "amex", t.Argencard = "argencard", t.Cabal = "cabal", t.Consosud = "censosud", t.DinersClub = "diners", t.Discover = "discover", t.Elo = "elo", t.Hipercard = "hipercard", t.JCB = "jcb", t.Mastercard = "mastercard", t.Naranja = "naranja", t.TarjetaShopping = "targeta-shopping", t.UnionChinaPay = "union-china-pay", t.Visa = "visa", t.MIR = "mir", t.Maestro = "maestro";
})(Ay || (Ay = {}));
var Ry;
(function(t) {
  t.Afghanistan = "af", t.Angola = "ao", t.Albania = "al", t.Andorra = "ad", t.UnitedArabEmirates = "ae", t.Argentina = "ar", t.Armenia = "am", t.AntiguaAndBarbuda = "ag", t.Australia = "au", t.Austria = "at", t.Azerbaijan = "az", t.Burundi = "bi", t.Belgium = "be", t.Benin = "bj", t.BurkinaFaso = "bf", t.Bangladesh = "bd", t.Bulgaria = "bg", t.Bahrain = "bh", t.Bahamas = "bs", t.BosniaAndHerzegovina = "ba", t.Belarus = "by", t.Belize = "bz", t.Bolivia = "bo", t.Brazil = "br", t.Barbados = "bb", t.BruneiDarussalam = "bn", t.Bhutan = "bt", t.Botswana = "bw", t.CentralAfricanRepublic = "cf", t.Canada = "ca", t.Switzerland = "ch", t.Chile = "cl", t.China = "cn", t.CoteDIvoire = "ci", t.Cameroon = "cm", t.DemocraticRepublicOfTheCongo = "cd", t.RepublicOfTheCongo = "cg", t.Colombia = "co", t.Comoros = "km", t.CapeVerde = "cv", t.CostaRica = "cr", t.Cuba = "cu", t.Cyprus = "cy", t.CzechRepublic = "cz", t.Germany = "de", t.Djibouti = "dj", t.Dominica = "dm", t.Denmark = "dk", t.DominicanRepublic = "do", t.Algeria = "dz", t.Ecuador = "ec", t.Egypt = "eg", t.Eritrea = "er", t.Spain = "es", t.Estonia = "ee", t.Ethiopia = "et", t.Finland = "fi", t.Fiji = "fj", t.France = "fr", t.MicronesiaFederatedStatesOf = "fm", t.Gabon = "ga", t.UnitedKingdom = "gb", t.Georgia = "ge", t.Ghana = "gh", t.Guinea = "gn", t.Gambia = "gm", t.GuineaBissau = "gw", t.EquatorialGuinea = "gq", t.Greece = "gr", t.Grenada = "gd", t.Guatemala = "gt", t.Guyana = "gy", t.Honduras = "hn", t.Croatia = "hr", t.Haiti = "ht", t.Hungary = "hu", t.Indonesia = "id", t.India = "in", t.Ireland = "ie", t.IranIslamicRepublicOf = "ir", t.Iraq = "iq", t.Iceland = "is", t.Israel = "il", t.Italy = "it", t.Jamaica = "jm", t.Jordan = "jo", t.Japan = "jp", t.Kazakhstan = "kz", t.Kenya = "ke", t.Kyrgyzstan = "kg", t.Cambodia = "kh", t.Kiribati = "ki", t.SaintKittsAndNevis = "kn", t.SouthKorea = "kr", t.Kuwait = "kw", t.LaoPeopleSDemocraticRepublic = "la", t.Lebanon = "lb", t.Liberia = "lr", t.Libya = "ly", t.SaintLucia = "lc", t.Liechtenstein = "li", t.SriLanka = "lk", t.Lesotho = "ls", t.Lithuania = "lt", t.Luxembourg = "lu", t.Latvia = "lv", t.Morocco = "ma", t.Monaco = "mc", t.Moldova = "md", t.Madagascar = "mg", t.Maldives = "mv", t.Mexico = "mx", t.MarshallIslands = "mh", t.NorthMacedonia = "mk", t.Mali = "ml", t.Malta = "mt", t.Myanmar = "mm", t.Montenegro = "me", t.Mongolia = "mn", t.Mozambique = "mz", t.Mauritania = "mr", t.Mauritius = "mu", t.Malawi = "mw", t.Malaysia = "my", t.Namibia = "na", t.Niger = "ne", t.Nigeria = "ng", t.Nicaragua = "ni", t.Netherlands = "nl", t.Norway = "no", t.Nepal = "np", t.Nauru = "nr", t.NewZealand = "nz", t.Oman = "om", t.Pakistan = "pk", t.Panama = "pa", t.Peru = "pe", t.Philippines = "ph", t.Palau = "pw", t.PapuaNewGuinea = "pg", t.Poland = "pl", t.NorthKorea = "kp", t.Portugal = "pt", t.Paraguay = "py", t.Qatar = "qa", t.Romania = "ro", t.Russia = "ru", t.Rwanda = "rw", t.SaudiArabia = "sa", t.Sudan = "sd", t.Senegal = "sn", t.Singapore = "sg", t.SolomonIslands = "sb", t.SierraLeone = "sl", t.ElSalvador = "sv", t.SanMarino = "sm", t.Somalia = "so", t.Serbia = "rs", t.SouthSudan = "ss", t.SaoTomeAndPrincipe = "st", t.Suriname = "sr", t.Slovakia = "sk", t.Slovenia = "si", t.Sweden = "se", t.Eswatini = "sz", t.Seychelles = "sc", t.Syria = "sy", t.Chad = "td", t.Togo = "tg", t.Thailand = "th", t.Tajikistan = "tj", t.Turkmenistan = "tm", t.TimorLeste = "tl", t.Tonga = "to", t.TrinidadAndTobago = "tt", t.Tunisia = "tn", t.Turkey = "tr", t.Tuvalu = "tv", t.Tanzania = "tz", t.Uganda = "ug", t.Ukraine = "ua", t.Uruguay = "uy", t.UnitedStates = "us", t.Uzbekistan = "uz", t.VaticanCity = "va", t.SaintVincentAndTheGrenadines = "vc", t.Venezuela = "ve", t.Vietnam = "vn", t.Vanuatu = "vu", t.Samoa = "ws", t.Yemen = "ye", t.SouthAfrica = "za", t.Zambia = "zm", t.Zimbabwe = "zw";
})(Ry || (Ry = {}));
var Cy;
(function(t) {
  t.GET = "GET", t.POST = "POST", t.PUT = "PUT", t.PATCH = "PATCH", t.DELETE = "DELETE", t.OPTIONS = "OPTIONS";
})(Cy || (Cy = {}));
var ky;
(function(t) {
  t.Center = "center", t.Topleft = "top-left", t.Top = "top", t.Topright = "top-right", t.Left = "left", t.Right = "right", t.Bottomleft = "bottom-left", t.Bottom = "bottom", t.Bottomright = "bottom-right";
})(ky || (ky = {}));
var Ny;
(function(t) {
  t.Jpg = "jpg", t.Jpeg = "jpeg", t.Gif = "gif", t.Png = "png", t.Webp = "webp";
})(Ny || (Ny = {}));
var ua;
const Fn = class Fn {
  constructor(e, n) {
    Ui(this, "inited", {});
    Ui(this, "app", {
      // for access database
      nosql: {
        // write options
        createDoc: async (e, n) => {
        },
        upsertDoc: async (e, n) => {
        },
        updateDoc: async (e, n) => {
        },
        deleteDoc: async (e) => {
        },
        // read options
        getDoc: async (e) => null,
        getDocs: async (e, n) => null,
        onDocSnapshot: (e, n) => () => {
        },
        onCollectionSnapshot: (e, n, r) => () => {
        },
        onAutoSnapshot: (e, n) => () => {
        },
        getCollections: async (e) => null
        // rest of the database methods
      },
      sql: {
        // write options
        addRecord: async (e, n, r) => {
        },
        updateRecord: async (e, n, r) => {
        },
        deleteRecord: async (e, n) => {
        },
        // read options
        getRecord: async (e, n) => null,
        getRecords: async (e, n) => null,
        onRecordSnapshot: (e, n, r) => () => {
        },
        onTableSnapshot: (e, n, r) => () => {
        }
      },
      storage: {
        // write options
        async createFile(e, n, r) {
        },
        async upsertFile(e, n, r) {
        },
        async updateFile(e, n, r) {
        },
        async deleteFile(e) {
        },
        // read options
        async getFileContent(e) {
          return null;
        },
        async getFiles(e) {
          return null;
        },
        async getDownloadURL(e) {
          return null;
        }
        // rest of the storage methods
      },
      auth: {
        async signIn(e) {
        },
        async getCurrentAuth() {
          return null;
        },
        async signOut() {
        },
        async deleteUser() {
        },
        async signInWithCustomToken(e) {
        },
        async resetPassword() {
        },
        async confirmPasswordReset(e, n) {
        },
        onAuthStateChanged(e) {
          return () => {
          };
        },
        async signInWithEmailAndPassword(e, n) {
        },
        async createUserWithEmailAndPassword(e, n) {
        },
        async setUserData() {
          return null;
        },
        async generateToken() {
          return null;
        }
      },
      functions: {
        // write options
        getFunction: async (e, n, r) => null,
        getUserFunction: async (e, n, r) => null
        // rest of the functions methods
      },
      ai: {
        sendMessage: async (e) => null,
        translate: async (e, n, r) => null
      }
    });
    em(this, ua);
    var r;
    if (Fn.list[e])
      throw "Cloud Already Exists";
    if (n)
      if (n instanceof Fn)
        this.app = n.app, this.inited = n.inited;
      else {
        const i = (r = Fn.list[n]) == null ? void 0 : r.app;
        i ? this.app = i : console.warn(`no app config defined from '${n}' to '${e}'`);
      }
    tm(this, ua, e), Fn.list[e] = this;
  }
  get name() {
    return Zp(this, ua);
  }
  set(e, n, r) {
    this.inited[`${e}/${n.toString()}`] = !0, this.app[e][n] = r;
  }
  remove(e, n) {
    this.inited[`${e}/${n.toString()}`] = !1;
  }
  get(e, n) {
    const r = `${e}/${n.toString()}`;
    return this.inited[r] ? this.app[e][n] : () => {
      throw `${r} Not Defined`;
    };
  }
  setAsMain() {
    Fn.setMain(this.name);
  }
  static setMain(e) {
    Fn.main = typeof e == "string" ? e : e.name;
  }
  static getMain() {
    return Fn.list[Fn.main];
  }
};
ua = new WeakMap(), Ui(Fn, "main", "main"), Ui(Fn, "list", {});
let Yc = Fn;
function g2(t) {
  const e = rp(t).split("/");
  return e.length >= 3 && e.length % 2;
}
function y2(t) {
  return rp(t).split("/").length % 2 == 1;
}
function _2(t = Yf("env.isDev") ?? !1) {
  return t;
}
function KM() {
  return ["==", ">", "<", ">=", "<=", "!="];
}
function YM() {
  return ["and", "or"];
}
function b2(t, {
  single: e,
  compound: n
} = {}) {
  if (KM().includes(t.operator))
    return e == null ? void 0 : e(t);
  if (YM().includes(t.operator))
    return n == null ? void 0 : n(t);
}
function Ur() {
  return Yc.getMain();
}
function v2(t, e, n) {
  return {
    field: t,
    operator: e,
    value: n
  };
}
function E2(...t) {
  return {
    operator: "and",
    querys: Ff(...t)
  };
}
function w2(...t) {
  return {
    operator: "or",
    querys: Ff(...t)
  };
}
function T2(t, e = "asc") {
  return {
    type: "asc",
    field: t
  };
}
function rp(...t) {
  const e = (n) => typeof n == "string" ? n : n.map(e).join("/");
  return e(t);
}
function I2(...t) {
  return rp(t).split("/");
}
/*! Capacitor: https://capacitorjs.com/ - MIT License */
const XM = (t) => {
  const e = /* @__PURE__ */ new Map();
  e.set("web", { name: "web" });
  const n = t.CapacitorPlatforms || {
    currentPlatform: { name: "web" },
    platforms: e
  }, r = (s, o) => {
    n.platforms.set(s, o);
  }, i = (s) => {
    n.platforms.has(s) && (n.currentPlatform = n.platforms.get(s));
  };
  return n.addPlatform = r, n.setPlatform = i, n;
}, QM = (t) => t.CapacitorPlatforms = XM(t), Bw = /* @__PURE__ */ QM(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {});
Bw.addPlatform;
Bw.setPlatform;
var no;
(function(t) {
  t.Unimplemented = "UNIMPLEMENTED", t.Unavailable = "UNAVAILABLE";
})(no || (no = {}));
class Eu extends Error {
  constructor(e, n, r) {
    super(e), this.message = e, this.code = n, this.data = r;
  }
}
const JM = (t) => {
  var e, n;
  return t != null && t.androidBridge ? "android" : !((n = (e = t == null ? void 0 : t.webkit) === null || e === void 0 ? void 0 : e.messageHandlers) === null || n === void 0) && n.bridge ? "ios" : "web";
}, ZM = (t) => {
  var e, n, r, i, s;
  const o = t.CapacitorCustomPlatform || null, a = t.Capacitor || {}, l = a.Plugins = a.Plugins || {}, u = t.CapacitorPlatforms, d = () => o !== null ? o.name : JM(t), f = ((e = u == null ? void 0 : u.currentPlatform) === null || e === void 0 ? void 0 : e.getPlatform) || d, p = () => f() !== "web", g = ((n = u == null ? void 0 : u.currentPlatform) === null || n === void 0 ? void 0 : n.isNativePlatform) || p, _ = (I) => {
    const E = P.get(I);
    return !!(E != null && E.platforms.has(f()) || v(I));
  }, b = ((r = u == null ? void 0 : u.currentPlatform) === null || r === void 0 ? void 0 : r.isPluginAvailable) || _, m = (I) => {
    var E;
    return (E = a.PluginHeaders) === null || E === void 0 ? void 0 : E.find((T) => T.name === I);
  }, v = ((i = u == null ? void 0 : u.currentPlatform) === null || i === void 0 ? void 0 : i.getPluginHeader) || m, C = (I) => t.console.error(I), x = (I, E, T) => Promise.reject(`${T} does not have an implementation of "${E}".`), P = /* @__PURE__ */ new Map(), k = (I, E = {}) => {
    const T = P.get(I);
    if (T)
      return console.warn(`Capacitor plugin "${I}" already registered. Cannot register plugins twice.`), T.proxy;
    const A = f(), R = v(I);
    let M;
    const S = async () => (!M && A in E ? M = typeof E[A] == "function" ? M = await E[A]() : M = E[A] : o !== null && !M && "web" in E && (M = typeof E.web == "function" ? M = await E.web() : M = E.web), M), D = (B, q) => {
      var se, re;
      if (R) {
        const ae = R == null ? void 0 : R.methods.find((ce) => q === ce.name);
        if (ae)
          return ae.rtype === "promise" ? (ce) => a.nativePromise(I, q.toString(), ce) : (ce, pe) => a.nativeCallback(I, q.toString(), ce, pe);
        if (B)
          return (se = B[q]) === null || se === void 0 ? void 0 : se.bind(B);
      } else {
        if (B)
          return (re = B[q]) === null || re === void 0 ? void 0 : re.bind(B);
        throw new Eu(`"${I}" plugin is not implemented on ${A}`, no.Unimplemented);
      }
    }, V = (B) => {
      let q;
      const se = (...re) => {
        const ae = S().then((ce) => {
          const pe = D(ce, B);
          if (pe) {
            const ie = pe(...re);
            return q = ie == null ? void 0 : ie.remove, ie;
          } else
            throw new Eu(`"${I}.${B}()" is not implemented on ${A}`, no.Unimplemented);
        });
        return B === "addListener" && (ae.remove = async () => q()), ae;
      };
      return se.toString = () => `${B.toString()}() { [capacitor code] }`, Object.defineProperty(se, "name", {
        value: B,
        writable: !1,
        configurable: !1
      }), se;
    }, X = V("addListener"), ge = V("removeListener"), Te = (B, q) => {
      const se = X({ eventName: B }, q), re = async () => {
        const ce = await se;
        ge({
          eventName: B,
          callbackId: ce
        }, q);
      }, ae = new Promise((ce) => se.then(() => ce({ remove: re })));
      return ae.remove = async () => {
        console.warn("Using addListener() without 'await' is deprecated."), await re();
      }, ae;
    }, Ie = new Proxy({}, {
      get(B, q) {
        switch (q) {
          // https://github.com/facebook/react/issues/20030
          case "$$typeof":
            return;
          case "toJSON":
            return () => ({});
          case "addListener":
            return R ? Te : X;
          case "removeListener":
            return ge;
          default:
            return V(q);
        }
      }
    });
    return l[I] = Ie, P.set(I, {
      name: I,
      proxy: Ie,
      platforms: /* @__PURE__ */ new Set([
        ...Object.keys(E),
        ...R ? [A] : []
      ])
    }), Ie;
  }, U = ((s = u == null ? void 0 : u.currentPlatform) === null || s === void 0 ? void 0 : s.registerPlugin) || k;
  return a.convertFileSrc || (a.convertFileSrc = (I) => I), a.getPlatform = f, a.handleError = C, a.isNativePlatform = g, a.isPluginAvailable = b, a.pluginMethodNoop = x, a.registerPlugin = U, a.Exception = Eu, a.DEBUG = !!a.DEBUG, a.isLoggingEnabled = !!a.isLoggingEnabled, a.platform = a.getPlatform(), a.isNative = a.isNativePlatform(), a;
}, eD = (t) => t.Capacitor = ZM(t), Ii = /* @__PURE__ */ eD(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {}), Dl = Ii.registerPlugin;
Ii.Plugins;
class $w {
  constructor(e) {
    this.listeners = {}, this.retainedEventArguments = {}, this.windowListeners = {}, e && (console.warn(`Capacitor WebPlugin "${e.name}" config object was deprecated in v3 and will be removed in v4.`), this.config = e);
  }
  addListener(e, n) {
    let r = !1;
    this.listeners[e] || (this.listeners[e] = [], r = !0), this.listeners[e].push(n);
    const s = this.windowListeners[e];
    s && !s.registered && this.addWindowListener(s), r && this.sendRetainedArgumentsForEvent(e);
    const o = async () => this.removeListener(e, n);
    return Promise.resolve({ remove: o });
  }
  async removeAllListeners() {
    this.listeners = {};
    for (const e in this.windowListeners)
      this.removeWindowListener(this.windowListeners[e]);
    this.windowListeners = {};
  }
  notifyListeners(e, n, r) {
    const i = this.listeners[e];
    if (!i) {
      if (r) {
        let s = this.retainedEventArguments[e];
        s || (s = []), s.push(n), this.retainedEventArguments[e] = s;
      }
      return;
    }
    i.forEach((s) => s(n));
  }
  hasListeners(e) {
    return !!this.listeners[e].length;
  }
  registerWindowListener(e, n) {
    this.windowListeners[n] = {
      registered: !1,
      windowEventName: e,
      pluginEventName: n,
      handler: (r) => {
        this.notifyListeners(n, r);
      }
    };
  }
  unimplemented(e = "not implemented") {
    return new Ii.Exception(e, no.Unimplemented);
  }
  unavailable(e = "not available") {
    return new Ii.Exception(e, no.Unavailable);
  }
  async removeListener(e, n) {
    const r = this.listeners[e];
    if (!r)
      return;
    const i = r.indexOf(n);
    this.listeners[e].splice(i, 1), this.listeners[e].length || this.removeWindowListener(this.windowListeners[e]);
  }
  addWindowListener(e) {
    window.addEventListener(e.windowEventName, e.handler), e.registered = !0;
  }
  removeWindowListener(e) {
    e && (window.removeEventListener(e.windowEventName, e.handler), e.registered = !1);
  }
  sendRetainedArgumentsForEvent(e) {
    const n = this.retainedEventArguments[e];
    n && (delete this.retainedEventArguments[e], n.forEach((r) => {
      this.notifyListeners(e, r);
    }));
  }
}
const Oy = (t) => encodeURIComponent(t).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape), Py = (t) => t.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class tD extends $w {
  async getCookies() {
    const e = document.cookie, n = {};
    return e.split(";").forEach((r) => {
      if (r.length <= 0)
        return;
      let [i, s] = r.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
      i = Py(i).trim(), s = Py(s).trim(), n[i] = s;
    }), n;
  }
  async setCookie(e) {
    try {
      const n = Oy(e.key), r = Oy(e.value), i = `; expires=${(e.expires || "").replace("expires=", "")}`, s = (e.path || "/").replace("path=", ""), o = e.url != null && e.url.length > 0 ? `domain=${e.url}` : "";
      document.cookie = `${n}=${r || ""}${i}; path=${s}; ${o};`;
    } catch (n) {
      return Promise.reject(n);
    }
  }
  async deleteCookie(e) {
    try {
      document.cookie = `${e.key}=; Max-Age=0`;
    } catch (n) {
      return Promise.reject(n);
    }
  }
  async clearCookies() {
    try {
      const e = document.cookie.split(";") || [];
      for (const n of e)
        document.cookie = n.replace(/^ +/, "").replace(/=.*/, `=;expires=${(/* @__PURE__ */ new Date()).toUTCString()};path=/`);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  async clearAllCookies() {
    try {
      await this.clearCookies();
    } catch (e) {
      return Promise.reject(e);
    }
  }
}
Dl("CapacitorCookies", {
  web: () => new tD()
});
const nD = async (t) => new Promise((e, n) => {
  const r = new FileReader();
  r.onload = () => {
    const i = r.result;
    e(i.indexOf(",") >= 0 ? i.split(",")[1] : i);
  }, r.onerror = (i) => n(i), r.readAsDataURL(t);
}), rD = (t = {}) => {
  const e = Object.keys(t);
  return Object.keys(t).map((i) => i.toLocaleLowerCase()).reduce((i, s, o) => (i[s] = t[e[o]], i), {});
}, iD = (t, e = !0) => t ? Object.entries(t).reduce((r, i) => {
  const [s, o] = i;
  let a, l;
  return Array.isArray(o) ? (l = "", o.forEach((u) => {
    a = e ? encodeURIComponent(u) : u, l += `${s}=${a}&`;
  }), l.slice(0, -1)) : (a = e ? encodeURIComponent(o) : o, l = `${s}=${a}`), `${r}&${l}`;
}, "").substr(1) : null, sD = (t, e = {}) => {
  const n = Object.assign({ method: t.method || "GET", headers: t.headers }, e), i = rD(t.headers)["content-type"] || "";
  if (typeof t.data == "string")
    n.body = t.data;
  else if (i.includes("application/x-www-form-urlencoded")) {
    const s = new URLSearchParams();
    for (const [o, a] of Object.entries(t.data || {}))
      s.set(o, a);
    n.body = s.toString();
  } else if (i.includes("multipart/form-data") || t.data instanceof FormData) {
    const s = new FormData();
    if (t.data instanceof FormData)
      t.data.forEach((a, l) => {
        s.append(l, a);
      });
    else
      for (const a of Object.keys(t.data))
        s.append(a, t.data[a]);
    n.body = s;
    const o = new Headers(n.headers);
    o.delete("content-type"), n.headers = o;
  } else (i.includes("application/json") || typeof t.data == "object") && (n.body = JSON.stringify(t.data));
  return n;
};
class oD extends $w {
  /**
   * Perform an Http request given a set of options
   * @param options Options to build the HTTP request
   */
  async request(e) {
    const n = sD(e, e.webFetchExtra), r = iD(e.params, e.shouldEncodeUrlParams), i = r ? `${e.url}?${r}` : e.url, s = await fetch(i, n), o = s.headers.get("content-type") || "";
    let { responseType: a = "text" } = s.ok ? e : {};
    o.includes("application/json") && (a = "json");
    let l, u;
    switch (a) {
      case "arraybuffer":
      case "blob":
        u = await s.blob(), l = await nD(u);
        break;
      case "json":
        l = await s.json();
        break;
      case "document":
      case "text":
      default:
        l = await s.text();
    }
    const d = {};
    return s.headers.forEach((f, p) => {
      d[p] = f;
    }), {
      data: l,
      headers: d,
      status: s.status,
      url: s.url
    };
  }
  /**
   * Perform an Http GET request given a set of options
   * @param options Options to build the HTTP request
   */
  async get(e) {
    return this.request(Object.assign(Object.assign({}, e), { method: "GET" }));
  }
  /**
   * Perform an Http POST request given a set of options
   * @param options Options to build the HTTP request
   */
  async post(e) {
    return this.request(Object.assign(Object.assign({}, e), { method: "POST" }));
  }
  /**
   * Perform an Http PUT request given a set of options
   * @param options Options to build the HTTP request
   */
  async put(e) {
    return this.request(Object.assign(Object.assign({}, e), { method: "PUT" }));
  }
  /**
   * Perform an Http PATCH request given a set of options
   * @param options Options to build the HTTP request
   */
  async patch(e) {
    return this.request(Object.assign(Object.assign({}, e), { method: "PATCH" }));
  }
  /**
   * Perform an Http DELETE request given a set of options
   * @param options Options to build the HTTP request
   */
  async delete(e) {
    return this.request(Object.assign(Object.assign({}, e), { method: "DELETE" }));
  }
}
Dl("CapacitorHttp", {
  web: () => new oD()
});
function aD() {
  HS(), nA(), AS(), oA(), _S(), OS(), DS(), kS(), US(), vS(), JS(), BS(), cA(), IS();
}
var Go;
(function(t) {
  t.Dark = "DARK", t.Light = "LIGHT", t.Default = "DEFAULT";
})(Go || (Go = {}));
var xy;
(function(t) {
  t.None = "NONE", t.Slide = "SLIDE", t.Fade = "FADE";
})(xy || (xy = {}));
const nc = Dl("StatusBar"), My = Dl("NavigationBar", {
  web: () => import("./web-CoSSBpho.mjs").then((t) => new t.NavigationBarWeb())
});
function cD(t) {
  const e = Bs("window/dark.boolean"), n = fr.getOne("secondary.background"), r = fr.getOne("text.color"), i = fr.getOne("bg.selection"), s = fr.getOne("text.selection");
  vt(() => {
    if (pD) {
      const d = document.createElement("script");
      d.src = "https://raw.githubusercontent.com/ilyestearti5/biqpod/main/ui", d.type = "module", document.head.appendChild(d);
    }
  }, []), vt(() => {
    if (e != null)
      return document.body.setAttribute("data-dark", e ? "true" : "false"), () => {
        document.body.removeAttribute("data-dark");
      };
  }, [e]);
  const o = ND();
  vt(() => {
    if (e == null)
      return;
    const d = n ? hi(e, o || n) : null, f = r ? hi(e, r) : null;
    if (f && (document.body.style.color = f), d && (document.body.style.backgroundColor = d), hD) {
      if (d)
        return nc.setBackgroundColor({
          color: d
        }), nc.setStyle({
          style: e ? Go.Dark : Go.Light
        }), My.setNavigationBarColor({
          color: d
        }), () => {
          nc.setBackgroundColor({
            color: d
          }), nc.setStyle({
            style: Go.Default
          }), My.setNavigationBarColor({
            color: d
          });
        };
    } else if (d) {
      const p = document.createElement("meta");
      return p.name = "theme-color", p.content = d, document.head.appendChild(p), () => {
        p.remove();
      };
    }
  }, [n, r, o, e]);
  const a = Bs("preferences/font.enum");
  vt(() => {
    a && (document.body.style.fontFamily = a);
    let d;
    return i && s && (d = document.createElement("style"), d.textContent = `
        ::selection {
          background: ${hi(!!e, i)};
          color: ${hi(!!e, s)};
        }
      `, document.head.append(d)), () => {
      d == null || d.remove();
    };
  }, [e, i, s, a]);
  const l = fr.getAll();
  vt(() => {
    const d = document.createElement("style"), f = l.map((p) => `--biqpod-${p.colorId.split(".").join("-")}: ${hi(e ?? !1, p)};`).join(`
`);
    return d.innerHTML = `:root { ${f} }`, d.id = "biqpod-colors", document.head.append(d), () => {
      d.remove();
    };
  }, [l, e]), vt(() => {
    Et("innerWidth", window.innerWidth), Et("innerHeight", window.innerHeight);
    const d = () => {
      Et("innerWidth", window.innerWidth), Et("innerHeight", window.innerHeight);
    };
    return window.addEventListener("resize", d), () => {
      window.removeEventListener("resize", d);
    };
  }, []), uA(
    "focus",
    (d) => {
      Pb(d);
    },
    []
  );
  const u = Bs("developer/seeComponent.boolean");
  vt(() => {
    if (!u)
      return;
    const d = ({ target: p }) => {
      const { x: g, y: _, width: b, height: m } = p.getBoundingClientRect();
      Et("dev.html.hoverPosition", {
        x: g,
        y: _,
        width: b,
        height: m
      });
    }, f = () => {
      Et("dev.html.hoverPosition", null);
    };
    return document.addEventListener("mouseover", d), document.addEventListener("mouseleave", f), () => {
      Et("dev.html.hoverPosition", null), document.removeEventListener("mouseover", d), document.removeEventListener("mouseleave", f);
    };
  }, [u]), vt(() => {
    function d() {
      Et("local.isOnLine", navigator.onLine);
    }
    return d(), window.addEventListener("online", d), window.addEventListener("offline", d), () => {
      window.removeEventListener("online", d), window.removeEventListener("offline", d);
    };
  }, []), vt(() => {
    const d = (f) => {
      f.repeat || (hn("Shift", f.getModifierState("Shift")), hn("Alt", f.getModifierState("Alt")), hn("Control", f.getModifierState("Control")), hn("SymbolLock", f.getModifierState("SymbolLock")), hn("AltGraph", f.getModifierState("AltGraph")), hn("CapsLock", f.getModifierState("CapsLock")), hn("Fn", f.getModifierState("Fn")), hn("FnLock", f.getModifierState("FnLock")), hn("Hyper", f.getModifierState("Hyper")), hn("Meta", f.getModifierState("Meta")), hn("NumLock", f.getModifierState("NumLock")), hn("Super", f.getModifierState("Super")), hn("ScrollLock", f.getModifierState("ScrollLock")), hn("Symbol", f.getModifierState("Symbol")), hn("Key", f.key));
    };
    return addEventListener("keydown", d), addEventListener("keyup", d), () => {
      removeEventListener("keydown", d), removeEventListener("keyup", d);
    };
  }, []);
}
const Si = ({ children: t }) => /* @__PURE__ */ he(wI, { children: t });
var bs = {}, Dy;
function lD() {
  if (Dy) return bs;
  Dy = 1;
  var t = yI;
  if (process.env.NODE_ENV === "production")
    bs.createRoot = t.createRoot, bs.hydrateRoot = t.hydrateRoot;
  else {
    var e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    bs.createRoot = function(n, r) {
      e.usingClientEntryPoint = !0;
      try {
        return t.createRoot(n, r);
      } finally {
        e.usingClientEntryPoint = !1;
      }
    }, bs.hydrateRoot = function(n, r, i) {
      e.usingClientEntryPoint = !0;
      try {
        return t.hydrateRoot(n, r, i);
      } finally {
        e.usingClientEntryPoint = !1;
      }
    };
  }
  return bs;
}
var uD = lD();
const { data: dD } = sv, Ly = ({ render: t = /* @__PURE__ */ he(Si, {}) }) => typeof t == "function" ? /* @__PURE__ */ he(t, {}) : t, fD = ({ props: t, app: e }) => {
  cD(), aD(), MD(), vt(() => {
    if (Et("projectId", t.projectId), An.setAll(
      Object.entries(dD).map(([i, s]) => ({
        ...s,
        settingId: i,
        value: s.def
      }))
    ), r.set("idle"), po) {
      const { ipcRenderer: i } = require("electron"), s = (o, a) => {
        Et("windowId", a);
      };
      return i.on("windowId", s), () => {
        i.off("windowId", s);
      };
    }
  }, []);
  const n = Er("env.isDev");
  vt(() => {
    var i;
    if (n)
      return window.auth = (i = Ur()) == null ? void 0 : i.app.auth, window.cloud = Yc, window.execAction = dA, window.execCommand = uv, window.store = Fe, () => {
        delete window.auth, delete window.cloud, delete window.execAction, delete window.execCommand, delete window.store;
      };
  }, [n]);
  const { status: r } = _D(async () => {
    var s;
    await Id(t.timeLoading), Et("env.isDev", t.isDev);
    let i = (s = t.onPrepare) == null ? void 0 : s.call(t);
    i instanceof Promise && (i = await i), i && (i.colors && await xb(i.colors, async (o) => {
      await Id(30), fr.upsert([o]);
    }), i.translations && i.translations.map((o) => {
      Hs.upsert([o]);
    }), i.commands && i.commands.map(({ keys: o, ...a }) => {
      LD(a, o);
    }), Et("project", i));
  }, [t]);
  return /* @__PURE__ */ bn("div", { className: "fixed inset-0 flex flex-col w-full overflow-hidden", children: [
    ["ready", "idle", "loading"].includes(r.get) && /* @__PURE__ */ he(Ly, { render: t.loading }),
    r.get == "success" && /* @__PURE__ */ he(Ly, { render: e }),
    r.get == "error" && /* @__PURE__ */ he("div", { className: "flex justify-center items-center w-full h-full", children: /* @__PURE__ */ bn(sU, { className: "flex flex-col items-center gap-2", children: [
      /* @__PURE__ */ he("h1", { className: "p-2 text-2xl text-center", children: /* @__PURE__ */ he(E_, { content: "Found Problem , Try After Moment!" }) }),
      /* @__PURE__ */ he("div", { className: "p-2", children: /* @__PURE__ */ he(
        iU,
        {
          onClick: () => {
            r.set("idle");
          },
          children: /* @__PURE__ */ he(E_, { content: "Try Again" })
        }
      ) })
    ] }) })
  ] });
}, S2 = async (t, e) => {
  const n = document.createElement("div");
  n.classList.add("window"), e = Lf(e, {
    loading: /* @__PURE__ */ he("div", { className: "top-1/2 left-1/2 fixed -translate-x-1/2 -translate-y-1/2 transform", children: /* @__PURE__ */ he(CT, { circleClassName: "w-[50px] h-[50px] border-4 " }) }),
    timeLoading: 500
  }), document.body.appendChild(n);
  const r = uD.createRoot(n);
  return r.render(
    /* @__PURE__ */ he(dI, { children: /* @__PURE__ */ he(pS, { store: Fe, children: /* @__PURE__ */ he(fD, { app: t, props: e }) }) })
  ), r;
}, po = !!window.require, hD = Ii.isNativePlatform(), pD = !po && Ii.getPlatform() == "web", A2 = Ii.getPlatform() === "android", R2 = Ii.getPlatform() === "ios", C2 = navigator.userAgent.includes("iPhone") || navigator.userAgent.includes("iPad"), mD = ["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp", "tiff", "ico", "jfif", "pjpeg", "pjp", "avif", "apng", "heif", "heic", "flif", "jxl", "jpe", "jif", "jfi"], of = /* @__PURE__ */ new Map();
function jw(t) {
  var r;
  const e = typeof t.native == "boolean" ? t.native : !!((r = Kf.selectById(Fe.getState().settings, "ui/native.boolean")) != null && r.value);
  if (po && !e) {
    const { ipcRenderer: i } = require("electron");
    return i.invoke("dialog:showDialogBox", t);
  }
  const n = $t();
  return new Promise((i, s) => {
    var l;
    if (!((l = t.buttons) != null && l.length)) {
      s("Need Minimum One Button");
      return;
    }
    Xm.setTemp("id", n), Xm.setTemp("params", t);
    const o = async () => {
      var p, g, _;
      const { slot: u, object: d } = Fe.getState(), f = (p = u.entities["dialog-list"]) == null ? void 0 : p.submited;
      typeof f == "number" && (i({
        response: f,
        checkboxChecked: ((_ = (g = d.data) == null ? void 0 : g.dialog) == null ? void 0 : _.checked) || !1
      }), a(), Et("dialog.id", null));
    }, a = Fe.subscribe(o);
  });
}
const k2 = async () => {
  const { screenX: t, screenY: e, innerWidth: n, innerHeight: r } = window;
  return {
    x: t,
    y: e,
    width: n,
    height: r
  };
}, N2 = async () => await fetch("https://api.ipify.org?format=json").then((t) => t.json()).then((t) => t.ip), O2 = (t) => {
  var r;
  const e = (r = t.match(/\.[a-z]+$/gi)) == null ? void 0 : r[0].slice(1).toLowerCase();
  let n = {};
  return mD.forEach((i) => {
    n[i] = i;
  }), n = {
    ...n,
    jpg: "jpeg",
    svg: "svg+xml"
  }, e ? n[e] : "png";
}, P2 = async ({ to: t, subject: e = "", body: n = "" }) => {
  const r = document.createElement("a");
  r.href = `mailto:${t}?subject=${encodeURIComponent(e)}&body=${encodeURIComponent(n)}`, r.target = "_blank", r.click();
}, x2 = ({ tel: t }) => {
  const e = document.createElement("a");
  e.href = `tel:${t}`, e.target = "_blank", e.click();
}, M2 = ({ to: t, body: e = "" }) => {
  const n = document.createElement("a");
  n.href = `sms:${t}?body=${encodeURIComponent(e)}`, n.target = "_blank", n.click();
}, D2 = (t, e) => {
  const n = async () => {
    const r = e();
    r instanceof Promise && await r;
  };
  of.set(t, n), document.addEventListener(t, n);
}, L2 = (t) => {
  const e = of.get(t);
  e && (document.removeEventListener(t, e), of.delete(t));
}, U2 = async ({ options: t, value: e }) => {
  if (Qm.setTemp("main", e), Qm.setTemp("main-mode", t == null ? void 0 : t.mode), po) {
    const { ipcRenderer: n } = require("electron");
    n.send("progress:show", { value: e, options: t });
  }
}, F2 = ({ x: t, y: e, menu: n, native: r = !!((i) => (i = Kf.selectById(Fe.getState().settings, "ui/native.boolean")) == null ? void 0 : i.value)() }) => {
  if (po && !r) {
    const { ipcRenderer: a } = require("electron");
    a.once("menu:click", (l, u) => {
      var d, f;
      (f = (d = n[u]) == null ? void 0 : d.click) == null || f.call(d);
    }), a.invoke("menu:show", { x: t, y: e, menu: n.map(({ click: l, defaultIcon: u, ...d }, f) => ({ index: f, ...d })) });
    return;
  }
  if (_s.setTemp("position", { x: t, y: e }), typeof Yf("menu.id") == "string")
    throw "menu defined before";
  const o = $t();
  _s.setTemp("id", o), _s.setTemp(
    "list",
    n.map(({ click: a, ...l }) => l)
  ), Qc(
    "object.data.menu.result",
    (a) => typeof a == "number",
    (a) => {
      var u, d;
      const l = (u = a.object.data) == null ? void 0 : u.menu;
      if (typeof l == "object" && typeof l.result == "number" && l.id == o) {
        _s.setTemp("id", null), _s.setTemp("list", []), _s.setTemp("result", null);
        const f = n[l.result];
        (d = f.click) == null || d.call(f);
      }
    }
  );
}, V2 = async ({ native: t, max: e = 1 / 0, ...n }) => {
  var i;
  const r = t === void 0 ? !!((i = Kf.selectById(Fe.getState().settings, "ui/native.boolean")) != null && i.value) : t;
  return po && !r ? await require("electron").ipcRenderer.invoke("dialog:openPath", n) : new Promise((s, o) => {
    var l;
    const a = document.createElement("input");
    a.type = "file", n.filters ? a.accept = n.filters.map(({ name: u, extensions: d }) => `${u}.{${d.join(",")}`).join(",") : a.accept = "*", a.multiple = !!((l = n.properties) != null && l.includes("multiSelections")), a.onchange = async () => {
      var u;
      if ((u = a.files) != null && u.length) {
        const d = [], f = Math.min(a.files.length, e);
        a.files.length > e && CD(`\`\`\`${a.files.length - e + 1}\`\`\` file not skiped`, "warning");
        for (let g = 0; g < f; g++) {
          const _ = a.files.item(g);
          _ && d.push(_);
        }
        const p = await xb(d, async (g) => new Promise((_) => {
          const b = new FileReader();
          b.onload = () => {
            b.result && _(b.result.toString());
          }, b.readAsDataURL(g);
        }));
        s(p);
      }
    }, a.click(), a.onerror = o;
  });
}, B2 = async (t) => (await jw({
  ...t,
  buttons: ["Yes", "No"],
  defaultId: 0
})).response === 0, $2 = async (t) => {
  await jw({
    ...t,
    buttons: ["Ok"],
    defaultId: 0
  });
}, gD = new fA("date-layout-time"), j2 = async (t) => gD.run(t), q2 = async (t) => {
  const e = document.createElement("audio");
  e.src = t, await e.play();
}, z2 = async ({ init: t = "#000000", x: e = 0, y: n = 0 }) => new Promise((r) => {
  const i = document.createElement("input");
  i.type = "color", i.value = t, i.style.position = "fixed", i.className = "w-0 h-0 p-0 m-0", document.appendChild(i), i.style.left = `${e}px`, i.style.top = `${n}px`, i.onchange = () => {
    r(i.value), i.remove();
  }, i.click();
});
function W2(t, e = [], n) {
  const r = at(null);
  return vt(() => (t().then(r.set), () => {
    n == null || n(e);
  }), e), r.get;
}
function Vs(t, e = [], n = () => {
}) {
  const r = at(!0);
  return vt(() => (r.set(!0), t().then().finally(() => {
    r.set(!1);
  }), () => n(e)), e), r.get;
}
function at(t) {
  const [e, n] = fI(t);
  return {
    get: e,
    set: n
  };
}
function Uy(t, e, n = (r) => r) {
  const r = at(n(t)), i = hI(r.get);
  return vt(() => {
    e(i);
  }, [i]), vt(() => {
    r.set(n(t));
  }, [t]), r;
}
function G2(t, e = [], n = 1e3) {
  const r = at(null), i = at(!1);
  return vt(() => {
    const s = new Uf();
    return i.set(!0), s.start(n).then(() => {
      r.set(t()), i.set(!1);
    }), () => {
      s.clear(), i.set(!1);
    };
  }, [...e, n]), [i.get, r.get];
}
function yD(t, e = [], n = 1e3) {
  const r = at(!1);
  return vt(() => {
    const i = new Uf();
    r.set(!0);
    let s;
    return i.start(n).then(async () => {
      s = t(), s instanceof Promise && await s, r.set(!1);
    }), () => {
      i.clear(), typeof s == "function" && s(), r.set(!1);
    };
  }, [...e, n]), r.get;
}
function _D(t, e = []) {
  const n = at("ready"), r = at(null), i = at(null);
  return Vs(async () => {
    if (n.get == "idle") {
      n.set("loading");
      try {
        const s = await t();
        r.set(s), i.set(null), n.set("success");
      } catch (s) {
        r.set(null), i.set(s), n.set("error");
      }
    }
  }, [n.get, ...e]), {
    status: n,
    data: r,
    error: i
  };
}
function bD(t) {
  const e = An.getOne(t);
  return ct(() => e || null, [e]);
}
function vD() {
  const t = An.getAll();
  return ct(() => t.filter(({ private: n = !1 }) => !n), [t]);
}
function H2(t) {
  const e = An.getOneFeild(t, "config");
  return ct(() => e || null, [e]);
}
function K2() {
  const t = vD(), e = Xt.getOneFeild("findConfigurations", "value"), n = iv.getOneFeild("settings.viewType", "focused"), r = ct(() => n == "list" ? qs.orderBy(t, "name", "asc") : n ? qs.orderBy(t, "settingId", "asc") : t, [n, t]), i = Bs("settings/findBy.enum"), s = ct(() => Object.entries(Mb(String(e))).map(([a, l]) => [a, l.join(" ")]), [e]), o = ct(() => r.filter((a) => s.every(([l, u]) => {
    var d;
    switch (l) {
      case "id":
        return ai(a.settingId, u);
      case "name":
        return typeof a.name == "string" && ai(a.name, u);
      case "changed":
        return !Ni(a.def, a.value);
      case "type": {
        const f = (d = a.settingId.match(/\.[a-z]+$/gi)) == null ? void 0 : d[0].slice(1);
        return typeof f == "string" ? ai(u, f) : !1;
      }
      case "default value":
        return i == "nice" ? ai(Ff(a.name, a.desc, a.settingId).join(" "), u) : i && ai(String(a[i]), u);
    }
  })), [s, r, i]);
  return vt(() => {
    Et("configurations.found.length", o.length);
  }, [o]), o;
}
function Y2(t, e) {
  An.setOneFeild(t, "config", e);
}
function ED(t, e) {
  An.setOneFeild(t, "value", e);
}
function X2(t, e) {
  Xt.setOneFeild(t, "value", e);
}
function Q2(t) {
  Xt.remove([t]);
}
function J2(t, e) {
  mi.setOneFeild(t, "focused", e);
}
function Z2(t, e) {
  mi.setOneFeild(t, "submited", e);
}
function e$(t, e) {
  let n = {};
  e.forEach((r) => {
    n[r] = !0;
  }), mi.setOneFeild(t, "selected", n);
}
function t$() {
  const t = Hs.getAll();
  return ct(() => t.map(({ ...n }) => Object.values(n)).flat(), [t]);
}
function n$(t) {
  return Xn.getOne(t);
}
function wD() {
  const t = Er("innerWidth"), e = Er("innerHeight"), n = ct(() => t || window.innerWidth, [t]), r = ct(() => e || window.innerHeight, [e]);
  return {
    width: n,
    height: r
  };
}
function r$() {
  const { width: t } = wD(), e = ct(() => t <= 768, [t]), n = ct(() => t > 768 && t <= 1024, [t]), r = ct(() => t > 1024, [t]);
  return { isMobile: e, isTablet: n, isDesktop: r, innerWidth: t };
}
function Bs(t) {
  const e = bD(t);
  return e == null ? void 0 : e.value;
}
function i$(t) {
  const e = ul.getAll();
  return ct(() => qs.join({ commandId: t }, e, "commandId->command"), [t, e]);
}
function ip() {
  const t = ul.getAll();
  return ct(() => t.filter(({ value: e }) => e), [t]);
}
function s$(t) {
  const e = ip();
  return ct(() => qs.join({ commandId: t }, e, "commandId->command"), [e, t]);
}
function o$(t) {
  const e = ip();
  return ct(() => qs.join({ actionName: t }, e, "actionName->action"), [e]);
}
function a$(t) {
  return zr.setTemp("settings", t == null ? void 0 : t.toString());
}
function TD() {
  const t = dv.getAll();
  return ct(() => t.filter((e) => !e.private), [t]);
}
function c$() {
  const t = TD(), e = Xt.getOneFeild("findConfigurations", "value"), n = ip(), r = ct(() => qs.fullJoin(t, n, "commandId->command").map(({ childs: o, data: a }) => ({
    ...a,
    keys: o
  })), [t, n]), i = ct(() => {
    if (!e)
      return r;
    const s = Object.entries(Mb(e)).map(([o, a]) => ({
      prop: o,
      value: a.join(" ")
    }));
    return r.filter(({ commandId: o, label: a, keys: l }) => s.every(({ prop: u, value: d }) => {
      switch (u) {
        case "key":
          return ai(l.map(({ value: f }) => f).join(" "), d);
        case "label":
          return ai(a, d);
        case "commandId":
          return o.startsWith(d);
        default:
          return ai([a, ...l.map(({ value: f }) => f)].join(" "), d);
      }
    }));
  }, [e, r]);
  return vt(() => {
    Et("configurations.found.length", i.length);
  }, [i]), i;
}
function l$(t, e = []) {
  const n = Object.entries(t), r = n.map(([, i]) => Xt.getOneFeild(i, "value"));
  return ct(() => {
    const i = {};
    return n.forEach(([s], o) => {
      const a = r[o];
      i[s] = a;
    }), i;
  }, [...r, ...e]);
}
function u$(t) {
  t.forEach((e) => {
    Xt.setOneFeild(e, "value", "");
  });
}
function ID(t) {
  const e = Xt.getOne(t);
  vt(() => {
    e || Xt.add([
      {
        fieldId: t,
        selection: {
          direction: "forward",
          end: 0,
          start: 0
        },
        value: "",
        controls: {}
      }
    ]);
  }, [e]);
}
function SD(t, e) {
  return ct(() => {
    if (!e)
      return t || "";
    const r = Math.min(e.start, e.end);
    return (t == null ? void 0 : t.slice(0, r)) || "";
  }, [t, e]);
}
function AD(t, e) {
  return ct(() => {
    if (!e)
      return t || "";
    const r = Math.max(e.start, e.end);
    return (t == null ? void 0 : t.slice(r)) || "";
  }, [t, e]);
}
function RD(t, e) {
  return ct(() => {
    if (!e)
      return t || "";
    const r = Math.min(e.start, e.end), i = Math.max(e.start, e.end);
    return (t == null ? void 0 : t.slice(r, i)) || "";
  }, [t, e]);
}
function d$(t) {
  t.forEach(ID);
}
function f$(t) {
  const e = Xt.getOneFeild(t, "value"), n = Xt.getOneFeild(t, "selection");
  return SD(e, n);
}
function h$(t) {
  const e = Xt.getOneFeild(t, "value"), n = Xt.getOneFeild(t, "selection");
  return AD(e, n);
}
function p$(t) {
  const e = Xt.getOneFeild(t, "value"), n = Xt.getOneFeild(t, "selection");
  return RD(e, n);
}
function m$(t, e = Fe.getState()) {
  const n = t.map((r) => {
    const i = e.fields.entities[r], s = Object.keys((i == null ? void 0 : i.controls) || {});
    if (!i || !s.length)
      return {
        response: [],
        isValide: !0
      };
    const o = i.value, a = s.map((l) => o.match(new RegExp(l, "ig")));
    return { response: a, isValide: a.every(Boolean), fieldName: r };
  });
  return {
    controls: n,
    isValide: n.every(({ isValide: r }) => r)
  };
}
function CD(t, e = "info", { id: n = $t(), ...r } = {}) {
  return TS.add([
    {
      message: t,
      id: n,
      type: e,
      ...r
    }
  ]), n;
}
var kD = /* @__PURE__ */ ((t) => (t[t.short = 5] = "short", t[t.long = 10] = "long", t))(kD || {});
async function g$() {
  const t = $t();
  return ji.setTemp("id", t), ji.setTemp("type", "scanQr"), new Promise(async (e) => {
    const n = sp(
      "object.data.view.result",
      (r) => !!r,
      async ({ object: r }) => {
        var s;
        const i = (s = r.data) == null ? void 0 : s.camera;
        (i == null ? void 0 : i.id) == t && (n(), e(i.result));
      }
    );
  });
}
function y$(t) {
  return new Promise(async (e, n) => {
    var o, a;
    if ((a = (o = Fe.getState().object.data) == null ? void 0 : o.camera) == null ? void 0 : a.id) {
      n("Camera Is Work Now");
      return;
    }
    const i = $t();
    ji.setTemp("id", i), ji.setTemp("type", t), ji.setTemp("result", null), ji.setTemp("error", null);
    const s = sp(
      "object.data.camera",
      (l) => !!(l != null && l.result || l != null && l.error),
      async ({ object: l }) => {
        var d;
        const u = (d = l.data) == null ? void 0 : d.camera;
        (u == null ? void 0 : u.id) == i && (u.result ? e(u.result) : n(u.error), ["id", "type", "result"].forEach((f) => {
          ji.setTemp(f, null);
        }), s());
      }
    );
  });
}
function vn() {
  const t = fr.getEntity(), e = Bs("window/dark.boolean");
  return Bo(
    (...n) => {
      const r = {}, i = {};
      if (e == null)
        return i;
      n.forEach((s) => {
        if (s) {
          if (typeof s == "string") {
            r.backgroundColor = s;
            return;
          }
          Object.entries(s).forEach(([o, a]) => {
            if (typeof a == "function") {
              r[o] = a;
              return;
            }
            r[o] = a;
          });
        }
      });
      for (const s in r) {
        const o = r[s];
        if (typeof o == "function")
          i[s] = o(t, e);
        else if (typeof o == "string") {
          const a = t[o];
          a && (i[s] = hi(e, a));
        }
      }
      return i;
    },
    [e, t]
  );
}
function af(t, ...e) {
  return (n, r) => `linear-gradient(${t} , ${e.filter((i) => n[i]).map((i) => {
    const s = n[i];
    return hi(r, s);
  }).join(" , ")})`;
}
const ND = () => {
  const t = Er("status-bar-color");
  return OD(t);
};
function _$(t) {
  Et("status-bar-color", t);
}
function hi(t, e) {
  return t ? e.dark || e.default : e.light || e.default;
}
function OD(t = null) {
  const e = fr.getEntity();
  return ct(() => t ? e[t] : null, [t, e]);
}
function Xc(t = []) {
  return (e, n) => t.filter((r) => e[r.colorId]).map(({ colorId: r, x: i = 0, y: s = 0, blur: o = 3, size: a = 1, isInset: l = !1 }) => {
    const u = e[r];
    return `${i}px ${s}px ${o}px ${a}px ${hi(n, u)} ${l ? "inset" : ""}`;
  }).join(" , ");
}
function Qc(t, e, n) {
  const r = () => {
    const s = Fe.getState(), { value: o } = il(s, t);
    (typeof e == "function" ? e(o) : o == e) && (i(), n(s));
  }, i = Fe.subscribe(r);
  return i;
}
function sp(t, e, n) {
  const r = () => {
    const i = Fe.getState(), { value: s, isValide: o } = il(i, t);
    if (!o) {
      ur.warn("Invalid State Dir", t);
      return;
    }
    (typeof e == "function" ? e(s) : s == e) && (n == null || n(i));
  };
  return Fe.subscribe(r);
}
const PD = () => An.getAll(), xD = () => {
  const t = PD();
  return ct(() => t.filter(({ synced: n = !1 }) => n), [t]);
};
function MD() {
  const t = ov("user-is-loading"), e = at(null);
  vt(() => {
    var i;
    return (i = Ur()) == null ? void 0 : i.app.auth.onAuthStateChanged(async (s) => {
      t.set(!1), e.set(s);
    });
  }, []), Vs(async () => {
    if (e.get) {
      const i = Ur(), s = await (i == null ? void 0 : i.app.auth.setUserData());
      s && await (i == null ? void 0 : i.app.nosql.upsertDoc(["users", e.get], s));
    }
  }, [e.get]), vt(() => {
    var i;
    if (e.get)
      return (i = Ur()) == null ? void 0 : i.app.nosql.onDocSnapshot(["users", e.get], async (s) => {
        var a;
        const o = e.get ? await ((a = Ur()) == null ? void 0 : a.app.nosql.getDoc(["users", e.get, "private", "pin"])) : null;
        Et("user-info", s ? { ...s, uid: e.get, pin: o } : null);
      });
    Et("user-info", null);
  }, [e.get]);
  const n = at(!1), r = xD();
  Vs(async () => {
    if (e.get && !n.get) {
      const i = Ur(), s = await (i == null ? void 0 : i.app.nosql.getDoc(["users", e.get, "private", "settings"]));
      s && (Object.entries(s.data).map(([o, a]) => {
        ED(o, a);
      }), n.set(!0));
    }
  }, [e.get, n.get]), Vs(async () => {
    if (e.get && n.get && r.length) {
      const i = Ur();
      if (i) {
        const s = ["users", e.get, "private", "settings"];
        let o = {};
        r.forEach(({ settingId: a, value: l }) => {
          o[a] = l;
        }), await i.app.nosql.upsertDoc(s, { data: o });
      }
    }
  }, [r, e.get, n.get]);
}
function b$() {
  const t = Er("user-is-loading");
  return ct(() => t ?? !0, [t]);
}
function v$() {
  return Er("user-info");
}
function E$() {
  zr.setTemp("profile-view", !0);
}
function w$() {
  zr.setTemp("profile-view", !1);
}
function T$(t) {
  zr.setTemp("pdf", t);
}
function I$({ ...t }) {
  An.setOneFeild("visibility/notifays.boolean", "value", !0), Gs.add([
    {
      id: $t(),
      buttons: [],
      desc: " - ",
      showDesc: !1,
      removable: !0,
      status: "idle",
      title: "Untitled",
      ...t
    }
  ]);
}
function S$() {
  const t = An.getAll();
  return ct(() => t.filter(({ def: e, value: n }) => !Ni(e, n)), [t]);
}
function A$(t, e = $t()) {
  const n = "iframe-" + e;
  return Cc.setTemp("id", n), Cc.setTemp("src", t.toString()), n;
}
function R$() {
  Cc.setTemp("id", null), Cc.setTemp("src", null);
}
function C$() {
  zr.setTemp("applications", !0);
}
function k$() {
  zr.setTemp("applications", !1);
}
function op(t, e, n = "dark") {
  fr.setOneFeild(t, n, e);
}
function N$(t, e) {
  op(t, e, "dark");
}
function O$(t, e) {
  op(t, e, "light");
}
function P$(t, e) {
  op(t, e, "default");
}
function x$(t, e) {
  const n = wc(t, "normal", "cabab").toLowerCase();
  Hs.upsert([
    {
      word: n,
      ...e
    }
  ]);
}
async function DD(t) {
  var r;
  const e = await ((r = Ur()) == null ? void 0 : r.app.storage.getFileContent(["global", "themes", t.concat(".json")])), n = await (e == null ? void 0 : e.text());
  return n ? JSON.parse(n) : null;
}
function LD(t, e) {
  dv.add([t]), UD(t.commandId, e);
}
function UD(t, e) {
  const r = Fe.getState().keys.ids.length;
  ul.add(
    e.map((i, s) => ({
      keyId: (r + s).toString(),
      command: t,
      ...i
    }))
  );
}
async function M$(t) {
  const e = await DD(t);
  e && fr.upsert(e);
}
const D$ = (t) => Xt.getOneFeild(t, "value");
class Ll {
  static save(e, n) {
    this.list[e] = n;
  }
}
Ui(Ll, "list", {});
function L$(t, { force: e = !1, id: n = $t(), min: r = "80%", max: i = "80%", overscroll: s = !1 } = {}) {
  if (!e) {
    const o = zr.getTempFromStore("bottomSheet");
    if (o != null && o.id)
      throw "Bottom Sheet Opend Before";
  }
  Ll.save(n, t), zr.setTemp("bottomSheet", { id: n, min: r, max: i, overscroll: s });
}
function U$(t) {
  zr.setTemp("bottomSheet", null), t && delete Ll.list[t];
}
function F$(t, e = {}) {
  const { type: n = "down", id: r = $t() } = e;
  return Ll.save(r, typeof t == "function" ? t({ id: r }) : t), Et("popup", {
    id: r,
    type: n
  }), r;
}
function V$() {
  Et("popup", null);
}
const B$ = (t, e) => {
  document.cookie = `${t}=${e || ""}; path=/`;
};
function $$(t) {
  const e = document.cookie.split("; ");
  for (const n of e) {
    const [r, i] = n.split("=");
    if (r === t)
      return decodeURIComponent(i);
  }
  return null;
}
const j$ = () => {
  hv.setTemp("help-is-opened", !0);
}, q$ = () => {
  hv.setTemp("help-is-opened", !1);
}, z$ = (t, e) => {
  Xt.setOneFeild(t, "controls", e || {});
}, W$ = (t) => Xt.getOneFeild(t, "controls"), G$ = (t) => fa.getOne(t), H$ = (t, e) => {
  fa.setOneFeild(t, "bottom", e);
}, K$ = (t, e) => {
  fa.setOneFeild(t, "top", e);
}, Y$ = (t, e) => {
  fa.setOneFeild(t, "left", e);
}, X$ = (t, e) => {
  fa.setOneFeild(t, "right", e);
}, Q$ = (t, e) => {
  Gs.upsert([{ ...e, id: t }]);
}, J$ = (t, e) => {
  mi.setOneFeild(t, "length", e);
};
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
function FD(t, e, n) {
  return (e = BD(e)) in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Fy(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function H(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Fy(Object(n), !0).forEach(function(r) {
      FD(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Fy(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function VD(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function BD(t) {
  var e = VD(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
const Vy = () => {
};
let ap = {}, qw = {}, zw = null, Ww = {
  mark: Vy,
  measure: Vy
};
try {
  typeof window < "u" && (ap = window), typeof document < "u" && (qw = document), typeof MutationObserver < "u" && (zw = MutationObserver), typeof performance < "u" && (Ww = performance);
} catch {
}
const {
  userAgent: By = ""
} = ap.navigator || {}, Ai = ap, yt = qw, $y = zw, rc = Ww;
Ai.document;
const ei = !!yt.documentElement && !!yt.head && typeof yt.addEventListener == "function" && typeof yt.createElement == "function", Gw = ~By.indexOf("MSIE") || ~By.indexOf("Trident/");
var $D = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, jD = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i, Hw = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  }
}, qD = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, Kw = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], ln = "classic", Ul = "duotone", zD = "sharp", WD = "sharp-duotone", Yw = [ln, Ul, zD, WD], GD = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, HD = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, KD = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}]]), YD = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    brands: "fab"
  },
  duotone: {
    solid: "fad",
    regular: "fadr",
    light: "fadl",
    thin: "fadt"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds",
    regular: "fasdr",
    light: "fasdl",
    thin: "fasdt"
  }
}, XD = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], jy = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, QD = ["kit"], JD = {
  kit: {
    "fa-kit": "fak"
  }
}, ZD = ["fak", "fakd"], e1 = {
  kit: {
    fak: "fa-kit"
  }
}, qy = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, ic = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, t1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], n1 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], r1 = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, i1 = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  }
}, s1 = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
}, cf = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  }
}, o1 = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"], lf = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...t1, ...o1], a1 = ["solid", "regular", "light", "thin", "duotone", "brands"], Xw = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], c1 = Xw.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), l1 = [...Object.keys(s1), ...a1, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", ic.GROUP, ic.SWAP_OPACITY, ic.PRIMARY, ic.SECONDARY].concat(Xw.map((t) => "".concat(t, "x"))).concat(c1.map((t) => "w-".concat(t))), u1 = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
const Qr = "___FONT_AWESOME___", uf = 16, Qw = "fa", Jw = "svg-inline--fa", ss = "data-fa-i2svg", df = "data-fa-pseudo-element", d1 = "data-fa-pseudo-element-pending", cp = "data-prefix", lp = "data-icon", zy = "fontawesome-i2svg", f1 = "async", h1 = ["HTML", "HEAD", "STYLE", "SCRIPT"], Zw = (() => {
  try {
    return process.env.NODE_ENV === "production";
  } catch {
    return !1;
  }
})();
function Ra(t) {
  return new Proxy(t, {
    get(e, n) {
      return n in e ? e[n] : e[ln];
    }
  });
}
const eT = H({}, Hw);
eT[ln] = H(H(H(H({}, {
  "fa-duotone": "duotone"
}), Hw[ln]), jy.kit), jy["kit-duotone"]);
const p1 = Ra(eT), ff = H({}, YD);
ff[ln] = H(H(H(H({}, {
  duotone: "fad"
}), ff[ln]), qy.kit), qy["kit-duotone"]);
const Wy = Ra(ff), hf = H({}, cf);
hf[ln] = H(H({}, hf[ln]), e1.kit);
const up = Ra(hf), pf = H({}, i1);
pf[ln] = H(H({}, pf[ln]), JD.kit);
Ra(pf);
const m1 = $D, tT = "fa-layers-text", g1 = jD, y1 = H({}, GD);
Ra(y1);
const _1 = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], wu = qD, b1 = [...QD, ...l1], Ho = Ai.FontAwesomeConfig || {};
function v1(t) {
  var e = yt.querySelector("script[" + t + "]");
  if (e)
    return e.getAttribute(t);
}
function E1(t) {
  return t === "" ? !0 : t === "false" ? !1 : t === "true" ? !0 : t;
}
yt && typeof yt.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((e) => {
  let [n, r] = e;
  const i = E1(v1(n));
  i != null && (Ho[r] = i);
});
const nT = {
  styleDefault: "solid",
  familyDefault: ln,
  cssPrefix: Qw,
  replacementClass: Jw,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
Ho.familyPrefix && (Ho.cssPrefix = Ho.familyPrefix);
const ro = H(H({}, nT), Ho);
ro.autoReplaceSvg || (ro.observeMutations = !1);
const _e = {};
Object.keys(nT).forEach((t) => {
  Object.defineProperty(_e, t, {
    enumerable: !0,
    set: function(e) {
      ro[t] = e, Ko.forEach((n) => n(_e));
    },
    get: function() {
      return ro[t];
    }
  });
});
Object.defineProperty(_e, "familyPrefix", {
  enumerable: !0,
  set: function(t) {
    ro.cssPrefix = t, Ko.forEach((e) => e(_e));
  },
  get: function() {
    return ro.cssPrefix;
  }
});
Ai.FontAwesomeConfig = _e;
const Ko = [];
function w1(t) {
  return Ko.push(t), () => {
    Ko.splice(Ko.indexOf(t), 1);
  };
}
const si = uf, hr = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function T1(t) {
  if (!t || !ei)
    return;
  const e = yt.createElement("style");
  e.setAttribute("type", "text/css"), e.innerHTML = t;
  const n = yt.head.childNodes;
  let r = null;
  for (let i = n.length - 1; i > -1; i--) {
    const s = n[i], o = (s.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(o) > -1 && (r = s);
  }
  return yt.head.insertBefore(e, r), t;
}
const I1 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function aa() {
  let t = 12, e = "";
  for (; t-- > 0; )
    e += I1[Math.random() * 62 | 0];
  return e;
}
function mo(t) {
  const e = [];
  for (let n = (t || []).length >>> 0; n--; )
    e[n] = t[n];
  return e;
}
function dp(t) {
  return t.classList ? mo(t.classList) : (t.getAttribute("class") || "").split(" ").filter((e) => e);
}
function rT(t) {
  return "".concat(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function S1(t) {
  return Object.keys(t || {}).reduce((e, n) => e + "".concat(n, '="').concat(rT(t[n]), '" '), "").trim();
}
function Fl(t) {
  return Object.keys(t || {}).reduce((e, n) => e + "".concat(n, ": ").concat(t[n].trim(), ";"), "");
}
function fp(t) {
  return t.size !== hr.size || t.x !== hr.x || t.y !== hr.y || t.rotate !== hr.rotate || t.flipX || t.flipY;
}
function A1(t) {
  let {
    transform: e,
    containerWidth: n,
    iconWidth: r
  } = t;
  const i = {
    transform: "translate(".concat(n / 2, " 256)")
  }, s = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "), o = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "), a = "rotate(".concat(e.rotate, " 0 0)"), l = {
    transform: "".concat(s, " ").concat(o, " ").concat(a)
  }, u = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: i,
    inner: l,
    path: u
  };
}
function R1(t) {
  let {
    transform: e,
    width: n = uf,
    height: r = uf,
    startCentered: i = !1
  } = t, s = "";
  return i && Gw ? s += "translate(".concat(e.x / si - n / 2, "em, ").concat(e.y / si - r / 2, "em) ") : i ? s += "translate(calc(-50% + ".concat(e.x / si, "em), calc(-50% + ").concat(e.y / si, "em)) ") : s += "translate(".concat(e.x / si, "em, ").concat(e.y / si, "em) "), s += "scale(".concat(e.size / si * (e.flipX ? -1 : 1), ", ").concat(e.size / si * (e.flipY ? -1 : 1), ") "), s += "rotate(".concat(e.rotate, "deg) "), s;
}
var C1 = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`;
function iT() {
  const t = Qw, e = Jw, n = _e.cssPrefix, r = _e.replacementClass;
  let i = C1;
  if (n !== t || r !== e) {
    const s = new RegExp("\\.".concat(t, "\\-"), "g"), o = new RegExp("\\--".concat(t, "\\-"), "g"), a = new RegExp("\\.".concat(e), "g");
    i = i.replace(s, ".".concat(n, "-")).replace(o, "--".concat(n, "-")).replace(a, ".".concat(r));
  }
  return i;
}
let Gy = !1;
function Tu() {
  _e.autoAddCss && !Gy && (T1(iT()), Gy = !0);
}
var k1 = {
  mixout() {
    return {
      dom: {
        css: iT,
        insertCss: Tu
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        Tu();
      },
      beforeI2svg() {
        Tu();
      }
    };
  }
};
const Jr = Ai || {};
Jr[Qr] || (Jr[Qr] = {});
Jr[Qr].styles || (Jr[Qr].styles = {});
Jr[Qr].hooks || (Jr[Qr].hooks = {});
Jr[Qr].shims || (Jr[Qr].shims = []);
var pr = Jr[Qr];
const sT = [], oT = function() {
  yt.removeEventListener("DOMContentLoaded", oT), Jc = 1, sT.map((t) => t());
};
let Jc = !1;
ei && (Jc = (yt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(yt.readyState), Jc || yt.addEventListener("DOMContentLoaded", oT));
function N1(t) {
  ei && (Jc ? setTimeout(t, 0) : sT.push(t));
}
function Ca(t) {
  const {
    tag: e,
    attributes: n = {},
    children: r = []
  } = t;
  return typeof t == "string" ? rT(t) : "<".concat(e, " ").concat(S1(n), ">").concat(r.map(Ca).join(""), "</").concat(e, ">");
}
function Hy(t, e, n) {
  if (t && t[e] && t[e][n])
    return {
      prefix: e,
      iconName: n,
      icon: t[e][n]
    };
}
var Iu = function(e, n, r, i) {
  var s = Object.keys(e), o = s.length, a = n, l, u, d;
  for (r === void 0 ? (l = 1, d = e[s[0]]) : (l = 0, d = r); l < o; l++)
    u = s[l], d = a(d, e[u], u, e);
  return d;
};
function O1(t) {
  const e = [];
  let n = 0;
  const r = t.length;
  for (; n < r; ) {
    const i = t.charCodeAt(n++);
    if (i >= 55296 && i <= 56319 && n < r) {
      const s = t.charCodeAt(n++);
      (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), n--);
    } else
      e.push(i);
  }
  return e;
}
function mf(t) {
  const e = O1(t);
  return e.length === 1 ? e[0].toString(16) : null;
}
function P1(t, e) {
  const n = t.length;
  let r = t.charCodeAt(e), i;
  return r >= 55296 && r <= 56319 && n > e + 1 && (i = t.charCodeAt(e + 1), i >= 56320 && i <= 57343) ? (r - 55296) * 1024 + i - 56320 + 65536 : r;
}
function Ky(t) {
  return Object.keys(t).reduce((e, n) => {
    const r = t[n];
    return !!r.icon ? e[r.iconName] = r.icon : e[n] = r, e;
  }, {});
}
function gf(t, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks: r = !1
  } = n, i = Ky(e);
  typeof pr.hooks.addPack == "function" && !r ? pr.hooks.addPack(t, Ky(e)) : pr.styles[t] = H(H({}, pr.styles[t] || {}), i), t === "fas" && gf("fa", e);
}
const {
  styles: ca,
  shims: x1
} = pr, aT = Object.keys(up), M1 = aT.reduce((t, e) => (t[e] = Object.keys(up[e]), t), {});
let hp = null, cT = {}, lT = {}, uT = {}, dT = {}, fT = {};
function D1(t) {
  return ~b1.indexOf(t);
}
function L1(t, e) {
  const n = e.split("-"), r = n[0], i = n.slice(1).join("-");
  return r === t && i !== "" && !D1(i) ? i : null;
}
const hT = () => {
  const t = (r) => Iu(ca, (i, s, o) => (i[o] = Iu(s, r, {}), i), {});
  cT = t((r, i, s) => (i[3] && (r[i[3]] = s), i[2] && i[2].filter((a) => typeof a == "number").forEach((a) => {
    r[a.toString(16)] = s;
  }), r)), lT = t((r, i, s) => (r[s] = s, i[2] && i[2].filter((a) => typeof a == "string").forEach((a) => {
    r[a] = s;
  }), r)), fT = t((r, i, s) => {
    const o = i[2];
    return r[s] = s, o.forEach((a) => {
      r[a] = s;
    }), r;
  });
  const e = "far" in ca || _e.autoFetchSvg, n = Iu(x1, (r, i) => {
    const s = i[0];
    let o = i[1];
    const a = i[2];
    return o === "far" && !e && (o = "fas"), typeof s == "string" && (r.names[s] = {
      prefix: o,
      iconName: a
    }), typeof s == "number" && (r.unicodes[s.toString(16)] = {
      prefix: o,
      iconName: a
    }), r;
  }, {
    names: {},
    unicodes: {}
  });
  uT = n.names, dT = n.unicodes, hp = Vl(_e.styleDefault, {
    family: _e.familyDefault
  });
};
w1((t) => {
  hp = Vl(t.styleDefault, {
    family: _e.familyDefault
  });
});
hT();
function pp(t, e) {
  return (cT[t] || {})[e];
}
function U1(t, e) {
  return (lT[t] || {})[e];
}
function Wi(t, e) {
  return (fT[t] || {})[e];
}
function pT(t) {
  return uT[t] || {
    prefix: null,
    iconName: null
  };
}
function F1(t) {
  const e = dT[t], n = pp("fas", t);
  return e || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function Ri() {
  return hp;
}
const mT = () => ({
  prefix: null,
  iconName: null,
  rest: []
});
function V1(t) {
  let e = ln;
  const n = aT.reduce((r, i) => (r[i] = "".concat(_e.cssPrefix, "-").concat(i), r), {});
  return Yw.forEach((r) => {
    (t.includes(n[r]) || t.some((i) => M1[r].includes(i))) && (e = r);
  }), e;
}
function Vl(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family: n = ln
  } = e, r = p1[n][t];
  if (n === Ul && !t)
    return "fad";
  const i = Wy[n][t] || Wy[n][r], s = t in pr.styles ? t : null;
  return i || s || null;
}
function B1(t) {
  let e = [], n = null;
  return t.forEach((r) => {
    const i = L1(_e.cssPrefix, r);
    i ? n = i : r && e.push(r);
  }), {
    iconName: n,
    rest: e
  };
}
function Yy(t) {
  return t.sort().filter((e, n, r) => r.indexOf(e) === n);
}
function Bl(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups: n = !1
  } = e;
  let r = null;
  const i = lf.concat(n1), s = Yy(t.filter((f) => i.includes(f))), o = Yy(t.filter((f) => !lf.includes(f))), a = s.filter((f) => (r = f, !Kw.includes(f))), [l = null] = a, u = V1(s), d = H(H({}, B1(o)), {}, {
    prefix: Vl(l, {
      family: u
    })
  });
  return H(H(H({}, d), z1({
    values: t,
    family: u,
    styles: ca,
    config: _e,
    canonical: d,
    givenPrefix: r
  })), $1(n, r, d));
}
function $1(t, e, n) {
  let {
    prefix: r,
    iconName: i
  } = n;
  if (t || !r || !i)
    return {
      prefix: r,
      iconName: i
    };
  const s = e === "fa" ? pT(i) : {}, o = Wi(r, i);
  return i = s.iconName || o || i, r = s.prefix || r, r === "far" && !ca.far && ca.fas && !_e.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: i
  };
}
const j1 = Yw.filter((t) => t !== ln || t !== Ul), q1 = Object.keys(cf).filter((t) => t !== ln).map((t) => Object.keys(cf[t])).flat();
function z1(t) {
  const {
    values: e,
    family: n,
    canonical: r,
    givenPrefix: i = "",
    styles: s = {},
    config: o = {}
  } = t, a = n === Ul, l = e.includes("fa-duotone") || e.includes("fad"), u = o.familyDefault === "duotone", d = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!a && (l || u || d) && (r.prefix = "fad"), (e.includes("fa-brands") || e.includes("fab")) && (r.prefix = "fab"), !r.prefix && j1.includes(n) && (Object.keys(s).find((p) => q1.includes(p)) || o.autoFetchSvg)) {
    const p = KD.get(n).defaultShortPrefixId;
    r.prefix = p, r.iconName = Wi(r.prefix, r.iconName) || r.iconName;
  }
  return (r.prefix === "fa" || i === "fa") && (r.prefix = Ri() || "fas"), r;
}
class W1 {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
      n[r] = arguments[r];
    const i = n.reduce(this._pullDefinitions, {});
    Object.keys(i).forEach((s) => {
      this.definitions[s] = H(H({}, this.definitions[s] || {}), i[s]), gf(s, i[s]);
      const o = up[ln][s];
      o && gf(o, i[s]), hT();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(e, n) {
    const r = n.prefix && n.iconName && n.icon ? {
      0: n
    } : n;
    return Object.keys(r).map((i) => {
      const {
        prefix: s,
        iconName: o,
        icon: a
      } = r[i], l = a[2];
      e[s] || (e[s] = {}), l.length > 0 && l.forEach((u) => {
        typeof u == "string" && (e[s][u] = a);
      }), e[s][o] = a;
    }), e;
  }
}
let Xy = [], Rs = {};
const $s = {}, G1 = Object.keys($s);
function H1(t, e) {
  let {
    mixoutsTo: n
  } = e;
  return Xy = t, Rs = {}, Object.keys($s).forEach((r) => {
    G1.indexOf(r) === -1 && delete $s[r];
  }), Xy.forEach((r) => {
    const i = r.mixout ? r.mixout() : {};
    if (Object.keys(i).forEach((s) => {
      typeof i[s] == "function" && (n[s] = i[s]), typeof i[s] == "object" && Object.keys(i[s]).forEach((o) => {
        n[s] || (n[s] = {}), n[s][o] = i[s][o];
      });
    }), r.hooks) {
      const s = r.hooks();
      Object.keys(s).forEach((o) => {
        Rs[o] || (Rs[o] = []), Rs[o].push(s[o]);
      });
    }
    r.provides && r.provides($s);
  }), n;
}
function yf(t, e) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
    r[i - 2] = arguments[i];
  return (Rs[t] || []).forEach((o) => {
    e = o.apply(null, [e, ...r]);
  }), e;
}
function os(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  (Rs[t] || []).forEach((s) => {
    s.apply(null, n);
  });
}
function Ci() {
  const t = arguments[0], e = Array.prototype.slice.call(arguments, 1);
  return $s[t] ? $s[t].apply(null, e) : void 0;
}
function _f(t) {
  t.prefix === "fa" && (t.prefix = "fas");
  let {
    iconName: e
  } = t;
  const n = t.prefix || Ri();
  if (e)
    return e = Wi(n, e) || e, Hy(gT.definitions, n, e) || Hy(pr.styles, n, e);
}
const gT = new W1(), K1 = () => {
  _e.autoReplaceSvg = !1, _e.observeMutations = !1, os("noAuto");
}, Y1 = {
  i2svg: function() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ei ? (os("beforeI2svg", t), Ci("pseudoElements2svg", t), Ci("i2svg", t)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot: e
    } = t;
    _e.autoReplaceSvg === !1 && (_e.autoReplaceSvg = !0), _e.observeMutations = !0, N1(() => {
      Q1({
        autoReplaceSvgRoot: e
      }), os("watch", t);
    });
  }
}, X1 = {
  icon: (t) => {
    if (t === null)
      return null;
    if (typeof t == "object" && t.prefix && t.iconName)
      return {
        prefix: t.prefix,
        iconName: Wi(t.prefix, t.iconName) || t.iconName
      };
    if (Array.isArray(t) && t.length === 2) {
      const e = t[1].indexOf("fa-") === 0 ? t[1].slice(3) : t[1], n = Vl(t[0]);
      return {
        prefix: n,
        iconName: Wi(n, e) || e
      };
    }
    if (typeof t == "string" && (t.indexOf("".concat(_e.cssPrefix, "-")) > -1 || t.match(m1))) {
      const e = Bl(t.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: e.prefix || Ri(),
        iconName: Wi(e.prefix, e.iconName) || e.iconName
      };
    }
    if (typeof t == "string") {
      const e = Ri();
      return {
        prefix: e,
        iconName: Wi(e, t) || t
      };
    }
  }
}, Cn = {
  noAuto: K1,
  config: _e,
  dom: Y1,
  parse: X1,
  library: gT,
  findIconDefinition: _f,
  toHtml: Ca
}, Q1 = function() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot: e = yt
  } = t;
  (Object.keys(pr.styles).length > 0 || _e.autoFetchSvg) && ei && _e.autoReplaceSvg && Cn.dom.i2svg({
    node: e
  });
};
function $l(t, e) {
  return Object.defineProperty(t, "abstract", {
    get: e
  }), Object.defineProperty(t, "html", {
    get: function() {
      return t.abstract.map((n) => Ca(n));
    }
  }), Object.defineProperty(t, "node", {
    get: function() {
      if (!ei) return;
      const n = yt.createElement("div");
      return n.innerHTML = t.html, n.children;
    }
  }), t;
}
function J1(t) {
  let {
    children: e,
    main: n,
    mask: r,
    attributes: i,
    styles: s,
    transform: o
  } = t;
  if (fp(o) && n.found && !r.found) {
    const {
      width: a,
      height: l
    } = n, u = {
      x: a / l / 2,
      y: 0.5
    };
    i.style = Fl(H(H({}, s), {}, {
      "transform-origin": "".concat(u.x + o.x / 16, "em ").concat(u.y + o.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: i,
    children: e
  }];
}
function Z1(t) {
  let {
    prefix: e,
    iconName: n,
    children: r,
    attributes: i,
    symbol: s
  } = t;
  const o = s === !0 ? "".concat(e, "-").concat(_e.cssPrefix, "-").concat(n) : s;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: H(H({}, i), {}, {
        id: o
      }),
      children: r
    }]
  }];
}
function mp(t) {
  const {
    icons: {
      main: e,
      mask: n
    },
    prefix: r,
    iconName: i,
    transform: s,
    symbol: o,
    title: a,
    maskId: l,
    titleId: u,
    extra: d,
    watchable: f = !1
  } = t, {
    width: p,
    height: g
  } = n.found ? n : e, _ = ZD.includes(r), b = [_e.replacementClass, i ? "".concat(_e.cssPrefix, "-").concat(i) : ""].filter((k) => d.classes.indexOf(k) === -1).filter((k) => k !== "" || !!k).concat(d.classes).join(" ");
  let m = {
    children: [],
    attributes: H(H({}, d.attributes), {}, {
      "data-prefix": r,
      "data-icon": i,
      class: b,
      role: d.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(p, " ").concat(g)
    })
  };
  const v = _ && !~d.classes.indexOf("fa-fw") ? {
    width: "".concat(p / g * 16 * 0.0625, "em")
  } : {};
  f && (m.attributes[ss] = ""), a && (m.children.push({
    tag: "title",
    attributes: {
      id: m.attributes["aria-labelledby"] || "title-".concat(u || aa())
    },
    children: [a]
  }), delete m.attributes.title);
  const C = H(H({}, m), {}, {
    prefix: r,
    iconName: i,
    main: e,
    mask: n,
    maskId: l,
    transform: s,
    symbol: o,
    styles: H(H({}, v), d.styles)
  }), {
    children: x,
    attributes: P
  } = n.found && e.found ? Ci("generateAbstractMask", C) || {
    children: [],
    attributes: {}
  } : Ci("generateAbstractIcon", C) || {
    children: [],
    attributes: {}
  };
  return C.children = x, C.attributes = P, o ? Z1(C) : J1(C);
}
function Qy(t) {
  const {
    content: e,
    width: n,
    height: r,
    transform: i,
    title: s,
    extra: o,
    watchable: a = !1
  } = t, l = H(H(H({}, o.attributes), s ? {
    title: s
  } : {}), {}, {
    class: o.classes.join(" ")
  });
  a && (l[ss] = "");
  const u = H({}, o.styles);
  fp(i) && (u.transform = R1({
    transform: i,
    startCentered: !0,
    width: n,
    height: r
  }), u["-webkit-transform"] = u.transform);
  const d = Fl(u);
  d.length > 0 && (l.style = d);
  const f = [];
  return f.push({
    tag: "span",
    attributes: l,
    children: [e]
  }), s && f.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [s]
  }), f;
}
function eL(t) {
  const {
    content: e,
    title: n,
    extra: r
  } = t, i = H(H(H({}, r.attributes), n ? {
    title: n
  } : {}), {}, {
    class: r.classes.join(" ")
  }), s = Fl(r.styles);
  s.length > 0 && (i.style = s);
  const o = [];
  return o.push({
    tag: "span",
    attributes: i,
    children: [e]
  }), n && o.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [n]
  }), o;
}
const {
  styles: Su
} = pr;
function bf(t) {
  const e = t[0], n = t[1], [r] = t.slice(4);
  let i = null;
  return Array.isArray(r) ? i = {
    tag: "g",
    attributes: {
      class: "".concat(_e.cssPrefix, "-").concat(wu.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(_e.cssPrefix, "-").concat(wu.SECONDARY),
        fill: "currentColor",
        d: r[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(_e.cssPrefix, "-").concat(wu.PRIMARY),
        fill: "currentColor",
        d: r[1]
      }
    }]
  } : i = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: r
    }
  }, {
    found: !0,
    width: e,
    height: n,
    icon: i
  };
}
const tL = {
  found: !1,
  width: 512,
  height: 512
};
function nL(t, e) {
  !Zw && !_e.showMissingIcons && t && console.error('Icon with name "'.concat(t, '" and prefix "').concat(e, '" is missing.'));
}
function vf(t, e) {
  let n = e;
  return e === "fa" && _e.styleDefault !== null && (e = Ri()), new Promise((r, i) => {
    if (n === "fa") {
      const s = pT(t) || {};
      t = s.iconName || t, e = s.prefix || e;
    }
    if (t && e && Su[e] && Su[e][t]) {
      const s = Su[e][t];
      return r(bf(s));
    }
    nL(t, e), r(H(H({}, tL), {}, {
      icon: _e.showMissingIcons && t ? Ci("missingIconAbstract") || {} : {}
    }));
  });
}
const Jy = () => {
}, Ef = _e.measurePerformance && rc && rc.mark && rc.measure ? rc : {
  mark: Jy,
  measure: Jy
}, Fo = 'FA "6.7.2"', rL = (t) => (Ef.mark("".concat(Fo, " ").concat(t, " begins")), () => yT(t)), yT = (t) => {
  Ef.mark("".concat(Fo, " ").concat(t, " ends")), Ef.measure("".concat(Fo, " ").concat(t), "".concat(Fo, " ").concat(t, " begins"), "".concat(Fo, " ").concat(t, " ends"));
};
var gp = {
  begin: rL,
  end: yT
};
const vc = () => {
};
function Zy(t) {
  return typeof (t.getAttribute ? t.getAttribute(ss) : null) == "string";
}
function iL(t) {
  const e = t.getAttribute ? t.getAttribute(cp) : null, n = t.getAttribute ? t.getAttribute(lp) : null;
  return e && n;
}
function sL(t) {
  return t && t.classList && t.classList.contains && t.classList.contains(_e.replacementClass);
}
function oL() {
  return _e.autoReplaceSvg === !0 ? Ec.replace : Ec[_e.autoReplaceSvg] || Ec.replace;
}
function aL(t) {
  return yt.createElementNS("http://www.w3.org/2000/svg", t);
}
function cL(t) {
  return yt.createElement(t);
}
function _T(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn: n = t.tag === "svg" ? aL : cL
  } = e;
  if (typeof t == "string")
    return yt.createTextNode(t);
  const r = n(t.tag);
  return Object.keys(t.attributes || []).forEach(function(s) {
    r.setAttribute(s, t.attributes[s]);
  }), (t.children || []).forEach(function(s) {
    r.appendChild(_T(s, {
      ceFn: n
    }));
  }), r;
}
function lL(t) {
  let e = " ".concat(t.outerHTML, " ");
  return e = "".concat(e, "Font Awesome fontawesome.com "), e;
}
const Ec = {
  replace: function(t) {
    const e = t[0];
    if (e.parentNode)
      if (t[1].forEach((n) => {
        e.parentNode.insertBefore(_T(n), e);
      }), e.getAttribute(ss) === null && _e.keepOriginalSource) {
        let n = yt.createComment(lL(e));
        e.parentNode.replaceChild(n, e);
      } else
        e.remove();
  },
  nest: function(t) {
    const e = t[0], n = t[1];
    if (~dp(e).indexOf(_e.replacementClass))
      return Ec.replace(t);
    const r = new RegExp("".concat(_e.cssPrefix, "-.*"));
    if (delete n[0].attributes.id, n[0].attributes.class) {
      const s = n[0].attributes.class.split(" ").reduce((o, a) => (a === _e.replacementClass || a.match(r) ? o.toSvg.push(a) : o.toNode.push(a), o), {
        toNode: [],
        toSvg: []
      });
      n[0].attributes.class = s.toSvg.join(" "), s.toNode.length === 0 ? e.removeAttribute("class") : e.setAttribute("class", s.toNode.join(" "));
    }
    const i = n.map((s) => Ca(s)).join(`
`);
    e.setAttribute(ss, ""), e.innerHTML = i;
  }
};
function e_(t) {
  t();
}
function bT(t, e) {
  const n = typeof e == "function" ? e : vc;
  if (t.length === 0)
    n();
  else {
    let r = e_;
    _e.mutateApproach === f1 && (r = Ai.requestAnimationFrame || e_), r(() => {
      const i = oL(), s = gp.begin("mutate");
      t.map(i), s(), n();
    });
  }
}
let yp = !1;
function vT() {
  yp = !0;
}
function wf() {
  yp = !1;
}
let Zc = null;
function t_(t) {
  if (!$y || !_e.observeMutations)
    return;
  const {
    treeCallback: e = vc,
    nodeCallback: n = vc,
    pseudoElementsCallback: r = vc,
    observeMutationsRoot: i = yt
  } = t;
  Zc = new $y((s) => {
    if (yp) return;
    const o = Ri();
    mo(s).forEach((a) => {
      if (a.type === "childList" && a.addedNodes.length > 0 && !Zy(a.addedNodes[0]) && (_e.searchPseudoElements && r(a.target), e(a.target)), a.type === "attributes" && a.target.parentNode && _e.searchPseudoElements && r(a.target.parentNode), a.type === "attributes" && Zy(a.target) && ~_1.indexOf(a.attributeName))
        if (a.attributeName === "class" && iL(a.target)) {
          const {
            prefix: l,
            iconName: u
          } = Bl(dp(a.target));
          a.target.setAttribute(cp, l || o), u && a.target.setAttribute(lp, u);
        } else sL(a.target) && n(a.target);
    });
  }), ei && Zc.observe(i, {
    childList: !0,
    attributes: !0,
    characterData: !0,
    subtree: !0
  });
}
function uL() {
  Zc && Zc.disconnect();
}
function dL(t) {
  const e = t.getAttribute("style");
  let n = [];
  return e && (n = e.split(";").reduce((r, i) => {
    const s = i.split(":"), o = s[0], a = s.slice(1);
    return o && a.length > 0 && (r[o] = a.join(":").trim()), r;
  }, {})), n;
}
function fL(t) {
  const e = t.getAttribute("data-prefix"), n = t.getAttribute("data-icon"), r = t.innerText !== void 0 ? t.innerText.trim() : "";
  let i = Bl(dp(t));
  return i.prefix || (i.prefix = Ri()), e && n && (i.prefix = e, i.iconName = n), i.iconName && i.prefix || (i.prefix && r.length > 0 && (i.iconName = U1(i.prefix, t.innerText) || pp(i.prefix, mf(t.innerText))), !i.iconName && _e.autoFetchSvg && t.firstChild && t.firstChild.nodeType === Node.TEXT_NODE && (i.iconName = t.firstChild.data)), i;
}
function hL(t) {
  const e = mo(t.attributes).reduce((i, s) => (i.name !== "class" && i.name !== "style" && (i[s.name] = s.value), i), {}), n = t.getAttribute("title"), r = t.getAttribute("data-fa-title-id");
  return _e.autoA11y && (n ? e["aria-labelledby"] = "".concat(_e.replacementClass, "-title-").concat(r || aa()) : (e["aria-hidden"] = "true", e.focusable = "false")), e;
}
function pL() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: hr,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function n_(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  };
  const {
    iconName: n,
    prefix: r,
    rest: i
  } = fL(t), s = hL(t), o = yf("parseNodeAttributes", {}, t);
  let a = e.styleParser ? dL(t) : [];
  return H({
    iconName: n,
    title: t.getAttribute("title"),
    titleId: t.getAttribute("data-fa-title-id"),
    prefix: r,
    transform: hr,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: i,
      styles: a,
      attributes: s
    }
  }, o);
}
const {
  styles: mL
} = pr;
function ET(t) {
  const e = _e.autoReplaceSvg === "nest" ? n_(t, {
    styleParser: !1
  }) : n_(t);
  return ~e.extra.classes.indexOf(tT) ? Ci("generateLayersText", t, e) : Ci("generateSvgReplacementMutation", t, e);
}
function gL() {
  return [...XD, ...lf];
}
function r_(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!ei) return Promise.resolve();
  const n = yt.documentElement.classList, r = (d) => n.add("".concat(zy, "-").concat(d)), i = (d) => n.remove("".concat(zy, "-").concat(d)), s = _e.autoFetchSvg ? gL() : Kw.concat(Object.keys(mL));
  s.includes("fa") || s.push("fa");
  const o = [".".concat(tT, ":not([").concat(ss, "])")].concat(s.map((d) => ".".concat(d, ":not([").concat(ss, "])"))).join(", ");
  if (o.length === 0)
    return Promise.resolve();
  let a = [];
  try {
    a = mo(t.querySelectorAll(o));
  } catch {
  }
  if (a.length > 0)
    r("pending"), i("complete");
  else
    return Promise.resolve();
  const l = gp.begin("onTree"), u = a.reduce((d, f) => {
    try {
      const p = ET(f);
      p && d.push(p);
    } catch (p) {
      Zw || p.name === "MissingIcon" && console.error(p);
    }
    return d;
  }, []);
  return new Promise((d, f) => {
    Promise.all(u).then((p) => {
      bT(p, () => {
        r("active"), r("complete"), i("pending"), typeof e == "function" && e(), l(), d();
      });
    }).catch((p) => {
      l(), f(p);
    });
  });
}
function yL(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  ET(t).then((n) => {
    n && bT([n], e);
  });
}
function _L(t) {
  return function(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = (e || {}).icon ? e : _f(e || {});
    let {
      mask: i
    } = n;
    return i && (i = (i || {}).icon ? i : _f(i || {})), t(r, H(H({}, n), {}, {
      mask: i
    }));
  };
}
const bL = function(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: n = hr,
    symbol: r = !1,
    mask: i = null,
    maskId: s = null,
    title: o = null,
    titleId: a = null,
    classes: l = [],
    attributes: u = {},
    styles: d = {}
  } = e;
  if (!t) return;
  const {
    prefix: f,
    iconName: p,
    icon: g
  } = t;
  return $l(H({
    type: "icon"
  }, t), () => (os("beforeDOMElementCreation", {
    iconDefinition: t,
    params: e
  }), _e.autoA11y && (o ? u["aria-labelledby"] = "".concat(_e.replacementClass, "-title-").concat(a || aa()) : (u["aria-hidden"] = "true", u.focusable = "false")), mp({
    icons: {
      main: bf(g),
      mask: i ? bf(i.icon) : {
        found: !1,
        width: null,
        height: null,
        icon: {}
      }
    },
    prefix: f,
    iconName: p,
    transform: H(H({}, hr), n),
    symbol: r,
    title: o,
    maskId: s,
    titleId: a,
    extra: {
      attributes: u,
      styles: d,
      classes: l
    }
  })));
};
var vL = {
  mixout() {
    return {
      icon: _L(bL)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(t) {
        return t.treeCallback = r_, t.nodeCallback = yL, t;
      }
    };
  },
  provides(t) {
    t.i2svg = function(e) {
      const {
        node: n = yt,
        callback: r = () => {
        }
      } = e;
      return r_(n, r);
    }, t.generateSvgReplacementMutation = function(e, n) {
      const {
        iconName: r,
        title: i,
        titleId: s,
        prefix: o,
        transform: a,
        symbol: l,
        mask: u,
        maskId: d,
        extra: f
      } = n;
      return new Promise((p, g) => {
        Promise.all([vf(r, o), u.iconName ? vf(u.iconName, u.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then((_) => {
          let [b, m] = _;
          p([e, mp({
            icons: {
              main: b,
              mask: m
            },
            prefix: o,
            iconName: r,
            transform: a,
            symbol: l,
            maskId: d,
            title: i,
            titleId: s,
            extra: f,
            watchable: !0
          })]);
        }).catch(g);
      });
    }, t.generateAbstractIcon = function(e) {
      let {
        children: n,
        attributes: r,
        main: i,
        transform: s,
        styles: o
      } = e;
      const a = Fl(o);
      a.length > 0 && (r.style = a);
      let l;
      return fp(s) && (l = Ci("generateAbstractTransformGrouping", {
        main: i,
        transform: s,
        containerWidth: i.width,
        iconWidth: i.width
      })), n.push(l || i.icon), {
        children: n,
        attributes: r
      };
    };
  }
}, EL = {
  mixout() {
    return {
      layer(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes: n = []
        } = e;
        return $l({
          type: "layer"
        }, () => {
          os("beforeDOMElementCreation", {
            assembler: t,
            params: e
          });
          let r = [];
          return t((i) => {
            Array.isArray(i) ? i.map((s) => {
              r = r.concat(s.abstract);
            }) : r = r.concat(i.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(_e.cssPrefix, "-layers"), ...n].join(" ")
            },
            children: r
          }];
        });
      }
    };
  }
}, wL = {
  mixout() {
    return {
      counter(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title: n = null,
          classes: r = [],
          attributes: i = {},
          styles: s = {}
        } = e;
        return $l({
          type: "counter",
          content: t
        }, () => (os("beforeDOMElementCreation", {
          content: t,
          params: e
        }), eL({
          content: t.toString(),
          title: n,
          extra: {
            attributes: i,
            styles: s,
            classes: ["".concat(_e.cssPrefix, "-layers-counter"), ...r]
          }
        })));
      }
    };
  }
}, TL = {
  mixout() {
    return {
      text(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: n = hr,
          title: r = null,
          classes: i = [],
          attributes: s = {},
          styles: o = {}
        } = e;
        return $l({
          type: "text",
          content: t
        }, () => (os("beforeDOMElementCreation", {
          content: t,
          params: e
        }), Qy({
          content: t,
          transform: H(H({}, hr), n),
          title: r,
          extra: {
            attributes: s,
            styles: o,
            classes: ["".concat(_e.cssPrefix, "-layers-text"), ...i]
          }
        })));
      }
    };
  },
  provides(t) {
    t.generateLayersText = function(e, n) {
      const {
        title: r,
        transform: i,
        extra: s
      } = n;
      let o = null, a = null;
      if (Gw) {
        const l = parseInt(getComputedStyle(e).fontSize, 10), u = e.getBoundingClientRect();
        o = u.width / l, a = u.height / l;
      }
      return _e.autoA11y && !r && (s.attributes["aria-hidden"] = "true"), Promise.resolve([e, Qy({
        content: e.innerHTML,
        width: o,
        height: a,
        transform: i,
        title: r,
        extra: s,
        watchable: !0
      })]);
    };
  }
};
const IL = new RegExp('"', "ug"), i_ = [1105920, 1112319], s_ = H(H(H(H({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), HD), u1), r1), Tf = Object.keys(s_).reduce((t, e) => (t[e.toLowerCase()] = s_[e], t), {}), SL = Object.keys(Tf).reduce((t, e) => {
  const n = Tf[e];
  return t[e] = n[900] || [...Object.entries(n)][0][1], t;
}, {});
function AL(t) {
  const e = t.replace(IL, ""), n = P1(e, 0), r = n >= i_[0] && n <= i_[1], i = e.length === 2 ? e[0] === e[1] : !1;
  return {
    value: mf(i ? e[0] : e),
    isSecondary: r || i
  };
}
function RL(t, e) {
  const n = t.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(e), i = isNaN(r) ? "normal" : r;
  return (Tf[n] || {})[i] || SL[n];
}
function o_(t, e) {
  const n = "".concat(d1).concat(e.replace(":", "-"));
  return new Promise((r, i) => {
    if (t.getAttribute(n) !== null)
      return r();
    const o = mo(t.children).filter((p) => p.getAttribute(df) === e)[0], a = Ai.getComputedStyle(t, e), l = a.getPropertyValue("font-family"), u = l.match(g1), d = a.getPropertyValue("font-weight"), f = a.getPropertyValue("content");
    if (o && !u)
      return t.removeChild(o), r();
    if (u && f !== "none" && f !== "") {
      const p = a.getPropertyValue("content");
      let g = RL(l, d);
      const {
        value: _,
        isSecondary: b
      } = AL(p), m = u[0].startsWith("FontAwesome");
      let v = pp(g, _), C = v;
      if (m) {
        const x = F1(_);
        x.iconName && x.prefix && (v = x.iconName, g = x.prefix);
      }
      if (v && !b && (!o || o.getAttribute(cp) !== g || o.getAttribute(lp) !== C)) {
        t.setAttribute(n, C), o && t.removeChild(o);
        const x = pL(), {
          extra: P
        } = x;
        P.attributes[df] = e, vf(v, g).then((k) => {
          const U = mp(H(H({}, x), {}, {
            icons: {
              main: k,
              mask: mT()
            },
            prefix: g,
            iconName: C,
            extra: P,
            watchable: !0
          })), I = yt.createElementNS("http://www.w3.org/2000/svg", "svg");
          e === "::before" ? t.insertBefore(I, t.firstChild) : t.appendChild(I), I.outerHTML = U.map((E) => Ca(E)).join(`
`), t.removeAttribute(n), r();
        }).catch(i);
      } else
        r();
    } else
      r();
  });
}
function CL(t) {
  return Promise.all([o_(t, "::before"), o_(t, "::after")]);
}
function kL(t) {
  return t.parentNode !== document.head && !~h1.indexOf(t.tagName.toUpperCase()) && !t.getAttribute(df) && (!t.parentNode || t.parentNode.tagName !== "svg");
}
function a_(t) {
  if (ei)
    return new Promise((e, n) => {
      const r = mo(t.querySelectorAll("*")).filter(kL).map(CL), i = gp.begin("searchPseudoElements");
      vT(), Promise.all(r).then(() => {
        i(), wf(), e();
      }).catch(() => {
        i(), wf(), n();
      });
    });
}
var NL = {
  hooks() {
    return {
      mutationObserverCallbacks(t) {
        return t.pseudoElementsCallback = a_, t;
      }
    };
  },
  provides(t) {
    t.pseudoElements2svg = function(e) {
      const {
        node: n = yt
      } = e;
      _e.searchPseudoElements && a_(n);
    };
  }
};
let c_ = !1;
var OL = {
  mixout() {
    return {
      dom: {
        unwatch() {
          vT(), c_ = !0;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        t_(yf("mutationObserverCallbacks", {}));
      },
      noAuto() {
        uL();
      },
      watch(t) {
        const {
          observeMutationsRoot: e
        } = t;
        c_ ? wf() : t_(yf("mutationObserverCallbacks", {
          observeMutationsRoot: e
        }));
      }
    };
  }
};
const l_ = (t) => {
  let e = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return t.toLowerCase().split(" ").reduce((n, r) => {
    const i = r.toLowerCase().split("-"), s = i[0];
    let o = i.slice(1).join("-");
    if (s && o === "h")
      return n.flipX = !0, n;
    if (s && o === "v")
      return n.flipY = !0, n;
    if (o = parseFloat(o), isNaN(o))
      return n;
    switch (s) {
      case "grow":
        n.size = n.size + o;
        break;
      case "shrink":
        n.size = n.size - o;
        break;
      case "left":
        n.x = n.x - o;
        break;
      case "right":
        n.x = n.x + o;
        break;
      case "up":
        n.y = n.y - o;
        break;
      case "down":
        n.y = n.y + o;
        break;
      case "rotate":
        n.rotate = n.rotate + o;
        break;
    }
    return n;
  }, e);
};
var PL = {
  mixout() {
    return {
      parse: {
        transform: (t) => l_(t)
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(t, e) {
        const n = e.getAttribute("data-fa-transform");
        return n && (t.transform = l_(n)), t;
      }
    };
  },
  provides(t) {
    t.generateAbstractTransformGrouping = function(e) {
      let {
        main: n,
        transform: r,
        containerWidth: i,
        iconWidth: s
      } = e;
      const o = {
        transform: "translate(".concat(i / 2, " 256)")
      }, a = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), l = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), u = "rotate(".concat(r.rotate, " 0 0)"), d = {
        transform: "".concat(a, " ").concat(l, " ").concat(u)
      }, f = {
        transform: "translate(".concat(s / 2 * -1, " -256)")
      }, p = {
        outer: o,
        inner: d,
        path: f
      };
      return {
        tag: "g",
        attributes: H({}, p.outer),
        children: [{
          tag: "g",
          attributes: H({}, p.inner),
          children: [{
            tag: n.icon.tag,
            children: n.icon.children,
            attributes: H(H({}, n.icon.attributes), p.path)
          }]
        }]
      };
    };
  }
};
const Au = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function u_(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return t.attributes && (t.attributes.fill || e) && (t.attributes.fill = "black"), t;
}
function xL(t) {
  return t.tag === "g" ? t.children : [t];
}
var ML = {
  hooks() {
    return {
      parseNodeAttributes(t, e) {
        const n = e.getAttribute("data-fa-mask"), r = n ? Bl(n.split(" ").map((i) => i.trim())) : mT();
        return r.prefix || (r.prefix = Ri()), t.mask = r, t.maskId = e.getAttribute("data-fa-mask-id"), t;
      }
    };
  },
  provides(t) {
    t.generateAbstractMask = function(e) {
      let {
        children: n,
        attributes: r,
        main: i,
        mask: s,
        maskId: o,
        transform: a
      } = e;
      const {
        width: l,
        icon: u
      } = i, {
        width: d,
        icon: f
      } = s, p = A1({
        transform: a,
        containerWidth: d,
        iconWidth: l
      }), g = {
        tag: "rect",
        attributes: H(H({}, Au), {}, {
          fill: "white"
        })
      }, _ = u.children ? {
        children: u.children.map(u_)
      } : {}, b = {
        tag: "g",
        attributes: H({}, p.inner),
        children: [u_(H({
          tag: u.tag,
          attributes: H(H({}, u.attributes), p.path)
        }, _))]
      }, m = {
        tag: "g",
        attributes: H({}, p.outer),
        children: [b]
      }, v = "mask-".concat(o || aa()), C = "clip-".concat(o || aa()), x = {
        tag: "mask",
        attributes: H(H({}, Au), {}, {
          id: v,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [g, m]
      }, P = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: C
          },
          children: xL(f)
        }, x]
      };
      return n.push(P, {
        tag: "rect",
        attributes: H({
          fill: "currentColor",
          "clip-path": "url(#".concat(C, ")"),
          mask: "url(#".concat(v, ")")
        }, Au)
      }), {
        children: n,
        attributes: r
      };
    };
  }
}, DL = {
  provides(t) {
    let e = !1;
    Ai.matchMedia && (e = Ai.matchMedia("(prefers-reduced-motion: reduce)").matches), t.missingIconAbstract = function() {
      const n = [], r = {
        fill: "currentColor"
      }, i = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      n.push({
        tag: "path",
        attributes: H(H({}, r), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      const s = H(H({}, i), {}, {
        attributeName: "opacity"
      }), o = {
        tag: "circle",
        attributes: H(H({}, r), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return e || o.children.push({
        tag: "animate",
        attributes: H(H({}, i), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: H(H({}, s), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), n.push(o), n.push({
        tag: "path",
        attributes: H(H({}, r), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: e ? [] : [{
          tag: "animate",
          attributes: H(H({}, s), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), e || n.push({
        tag: "path",
        attributes: H(H({}, r), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: H(H({}, s), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: n
      };
    };
  }
}, LL = {
  hooks() {
    return {
      parseNodeAttributes(t, e) {
        const n = e.getAttribute("data-fa-symbol"), r = n === null ? !1 : n === "" ? !0 : n;
        return t.symbol = r, t;
      }
    };
  }
}, UL = [k1, vL, EL, wL, TL, NL, OL, PL, ML, DL, LL];
H1(UL, {
  mixoutsTo: Cn
});
Cn.noAuto;
Cn.config;
Cn.library;
Cn.dom;
const If = Cn.parse;
Cn.findIconDefinition;
Cn.toHtml;
const FL = Cn.icon;
Cn.layer;
Cn.text;
Cn.counter;
var sc = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Ru, d_;
function VL() {
  if (d_) return Ru;
  d_ = 1;
  var t = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(o).map(function(d) {
        return o[d];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(d) {
        u[d] = d;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Ru = i() ? Object.assign : function(s, o) {
    for (var a, l = r(s), u, d = 1; d < arguments.length; d++) {
      a = Object(arguments[d]);
      for (var f in a)
        e.call(a, f) && (l[f] = a[f]);
      if (t) {
        u = t(a);
        for (var p = 0; p < u.length; p++)
          n.call(a, u[p]) && (l[u[p]] = a[u[p]]);
      }
    }
    return l;
  }, Ru;
}
var Cu, f_;
function _p() {
  if (f_) return Cu;
  f_ = 1;
  var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Cu = t, Cu;
}
var ku, h_;
function wT() {
  return h_ || (h_ = 1, ku = Function.call.bind(Object.prototype.hasOwnProperty)), ku;
}
var Nu, p_;
function BL() {
  if (p_) return Nu;
  p_ = 1;
  var t = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = /* @__PURE__ */ _p(), n = {}, r = /* @__PURE__ */ wT();
    t = function(s) {
      var o = "Warning: " + s;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(s, o, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var d in s)
        if (r(s, d)) {
          var f;
          try {
            if (typeof s[d] != "function") {
              var p = Error(
                (l || "React class") + ": " + a + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            f = s[d](o, d, l, a, null, e);
          } catch (_) {
            f = _;
          }
          if (f && !(f instanceof Error) && t(
            (l || "React class") + ": type specification of " + a + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var g = u ? u() : "";
            t(
              "Failed " + a + " type: " + f.message + (g ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Nu = i, Nu;
}
var Ou, m_;
function $L() {
  if (m_) return Ou;
  m_ = 1;
  var t = Hf(), e = VL(), n = /* @__PURE__ */ _p(), r = /* @__PURE__ */ wT(), i = /* @__PURE__ */ BL(), s = function() {
  };
  process.env.NODE_ENV !== "production" && (s = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return Ou = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";
    function f(B) {
      var q = B && (u && B[u] || B[d]);
      if (typeof q == "function")
        return q;
    }
    var p = "<<anonymous>>", g = {
      array: v("array"),
      bigint: v("bigint"),
      bool: v("boolean"),
      func: v("function"),
      number: v("number"),
      object: v("object"),
      string: v("string"),
      symbol: v("symbol"),
      any: C(),
      arrayOf: x,
      element: P(),
      elementType: k(),
      instanceOf: U,
      node: A(),
      objectOf: E,
      oneOf: I,
      oneOfType: T,
      shape: M,
      exact: S
    };
    function _(B, q) {
      return B === q ? B !== 0 || 1 / B === 1 / q : B !== B && q !== q;
    }
    function b(B, q) {
      this.message = B, this.data = q && typeof q == "object" ? q : {}, this.stack = "";
    }
    b.prototype = Error.prototype;
    function m(B) {
      if (process.env.NODE_ENV !== "production")
        var q = {}, se = 0;
      function re(ce, pe, ie, le, Se, de, Le) {
        if (le = le || p, de = de || ie, Le !== n) {
          if (l) {
            var K = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw K.name = "Invariant Violation", K;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Qe = le + ":" + ie;
            !q[Qe] && // Avoid spamming the console because they are often not actionable except for lib authors
            se < 3 && (s(
              "You are manually calling a React.PropTypes validation function for the `" + de + "` prop on `" + le + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), q[Qe] = !0, se++);
          }
        }
        return pe[ie] == null ? ce ? pe[ie] === null ? new b("The " + Se + " `" + de + "` is marked as required " + ("in `" + le + "`, but its value is `null`.")) : new b("The " + Se + " `" + de + "` is marked as required in " + ("`" + le + "`, but its value is `undefined`.")) : null : B(pe, ie, le, Se, de);
      }
      var ae = re.bind(null, !1);
      return ae.isRequired = re.bind(null, !0), ae;
    }
    function v(B) {
      function q(se, re, ae, ce, pe, ie) {
        var le = se[re], Se = X(le);
        if (Se !== B) {
          var de = ge(le);
          return new b(
            "Invalid " + ce + " `" + pe + "` of type " + ("`" + de + "` supplied to `" + ae + "`, expected ") + ("`" + B + "`."),
            { expectedType: B }
          );
        }
        return null;
      }
      return m(q);
    }
    function C() {
      return m(o);
    }
    function x(B) {
      function q(se, re, ae, ce, pe) {
        if (typeof B != "function")
          return new b("Property `" + pe + "` of component `" + ae + "` has invalid PropType notation inside arrayOf.");
        var ie = se[re];
        if (!Array.isArray(ie)) {
          var le = X(ie);
          return new b("Invalid " + ce + " `" + pe + "` of type " + ("`" + le + "` supplied to `" + ae + "`, expected an array."));
        }
        for (var Se = 0; Se < ie.length; Se++) {
          var de = B(ie, Se, ae, ce, pe + "[" + Se + "]", n);
          if (de instanceof Error)
            return de;
        }
        return null;
      }
      return m(q);
    }
    function P() {
      function B(q, se, re, ae, ce) {
        var pe = q[se];
        if (!a(pe)) {
          var ie = X(pe);
          return new b("Invalid " + ae + " `" + ce + "` of type " + ("`" + ie + "` supplied to `" + re + "`, expected a single ReactElement."));
        }
        return null;
      }
      return m(B);
    }
    function k() {
      function B(q, se, re, ae, ce) {
        var pe = q[se];
        if (!t.isValidElementType(pe)) {
          var ie = X(pe);
          return new b("Invalid " + ae + " `" + ce + "` of type " + ("`" + ie + "` supplied to `" + re + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return m(B);
    }
    function U(B) {
      function q(se, re, ae, ce, pe) {
        if (!(se[re] instanceof B)) {
          var ie = B.name || p, le = Ie(se[re]);
          return new b("Invalid " + ce + " `" + pe + "` of type " + ("`" + le + "` supplied to `" + ae + "`, expected ") + ("instance of `" + ie + "`."));
        }
        return null;
      }
      return m(q);
    }
    function I(B) {
      if (!Array.isArray(B))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? s(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : s("Invalid argument supplied to oneOf, expected an array.")), o;
      function q(se, re, ae, ce, pe) {
        for (var ie = se[re], le = 0; le < B.length; le++)
          if (_(ie, B[le]))
            return null;
        var Se = JSON.stringify(B, function(Le, K) {
          var Qe = ge(K);
          return Qe === "symbol" ? String(K) : K;
        });
        return new b("Invalid " + ce + " `" + pe + "` of value `" + String(ie) + "` " + ("supplied to `" + ae + "`, expected one of " + Se + "."));
      }
      return m(q);
    }
    function E(B) {
      function q(se, re, ae, ce, pe) {
        if (typeof B != "function")
          return new b("Property `" + pe + "` of component `" + ae + "` has invalid PropType notation inside objectOf.");
        var ie = se[re], le = X(ie);
        if (le !== "object")
          return new b("Invalid " + ce + " `" + pe + "` of type " + ("`" + le + "` supplied to `" + ae + "`, expected an object."));
        for (var Se in ie)
          if (r(ie, Se)) {
            var de = B(ie, Se, ae, ce, pe + "." + Se, n);
            if (de instanceof Error)
              return de;
          }
        return null;
      }
      return m(q);
    }
    function T(B) {
      if (!Array.isArray(B))
        return process.env.NODE_ENV !== "production" && s("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var q = 0; q < B.length; q++) {
        var se = B[q];
        if (typeof se != "function")
          return s(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Te(se) + " at index " + q + "."
          ), o;
      }
      function re(ae, ce, pe, ie, le) {
        for (var Se = [], de = 0; de < B.length; de++) {
          var Le = B[de], K = Le(ae, ce, pe, ie, le, n);
          if (K == null)
            return null;
          K.data && r(K.data, "expectedType") && Se.push(K.data.expectedType);
        }
        var Qe = Se.length > 0 ? ", expected one of type [" + Se.join(", ") + "]" : "";
        return new b("Invalid " + ie + " `" + le + "` supplied to " + ("`" + pe + "`" + Qe + "."));
      }
      return m(re);
    }
    function A() {
      function B(q, se, re, ae, ce) {
        return D(q[se]) ? null : new b("Invalid " + ae + " `" + ce + "` supplied to " + ("`" + re + "`, expected a ReactNode."));
      }
      return m(B);
    }
    function R(B, q, se, re, ae) {
      return new b(
        (B || "React class") + ": " + q + " type `" + se + "." + re + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + ae + "`."
      );
    }
    function M(B) {
      function q(se, re, ae, ce, pe) {
        var ie = se[re], le = X(ie);
        if (le !== "object")
          return new b("Invalid " + ce + " `" + pe + "` of type `" + le + "` " + ("supplied to `" + ae + "`, expected `object`."));
        for (var Se in B) {
          var de = B[Se];
          if (typeof de != "function")
            return R(ae, ce, pe, Se, ge(de));
          var Le = de(ie, Se, ae, ce, pe + "." + Se, n);
          if (Le)
            return Le;
        }
        return null;
      }
      return m(q);
    }
    function S(B) {
      function q(se, re, ae, ce, pe) {
        var ie = se[re], le = X(ie);
        if (le !== "object")
          return new b("Invalid " + ce + " `" + pe + "` of type `" + le + "` " + ("supplied to `" + ae + "`, expected `object`."));
        var Se = e({}, se[re], B);
        for (var de in Se) {
          var Le = B[de];
          if (r(B, de) && typeof Le != "function")
            return R(ae, ce, pe, de, ge(Le));
          if (!Le)
            return new b(
              "Invalid " + ce + " `" + pe + "` key `" + de + "` supplied to `" + ae + "`.\nBad object: " + JSON.stringify(se[re], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(B), null, "  ")
            );
          var K = Le(ie, de, ae, ce, pe + "." + de, n);
          if (K)
            return K;
        }
        return null;
      }
      return m(q);
    }
    function D(B) {
      switch (typeof B) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !B;
        case "object":
          if (Array.isArray(B))
            return B.every(D);
          if (B === null || a(B))
            return !0;
          var q = f(B);
          if (q) {
            var se = q.call(B), re;
            if (q !== B.entries) {
              for (; !(re = se.next()).done; )
                if (!D(re.value))
                  return !1;
            } else
              for (; !(re = se.next()).done; ) {
                var ae = re.value;
                if (ae && !D(ae[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function V(B, q) {
      return B === "symbol" ? !0 : q ? q["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && q instanceof Symbol : !1;
    }
    function X(B) {
      var q = typeof B;
      return Array.isArray(B) ? "array" : B instanceof RegExp ? "object" : V(q, B) ? "symbol" : q;
    }
    function ge(B) {
      if (typeof B > "u" || B === null)
        return "" + B;
      var q = X(B);
      if (q === "object") {
        if (B instanceof Date)
          return "date";
        if (B instanceof RegExp)
          return "regexp";
      }
      return q;
    }
    function Te(B) {
      var q = ge(B);
      switch (q) {
        case "array":
        case "object":
          return "an " + q;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + q;
        default:
          return q;
      }
    }
    function Ie(B) {
      return !B.constructor || !B.constructor.name ? p : B.constructor.name;
    }
    return g.checkPropTypes = i, g.resetWarningCache = i.resetWarningCache, g.PropTypes = g, g;
  }, Ou;
}
var Pu, g_;
function jL() {
  if (g_) return Pu;
  g_ = 1;
  var t = /* @__PURE__ */ _p();
  function e() {
  }
  function n() {
  }
  return n.resetWarningCache = e, Pu = function() {
    function r(o, a, l, u, d, f) {
      if (f !== t) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var s = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: e
    };
    return s.PropTypes = s, s;
  }, Pu;
}
var y_;
function qL() {
  if (y_) return sc.exports;
  if (y_ = 1, process.env.NODE_ENV !== "production") {
    var t = Hf(), e = !0;
    sc.exports = /* @__PURE__ */ $L()(t.isElement, e);
  } else
    sc.exports = /* @__PURE__ */ jL()();
  return sc.exports;
}
var zL = /* @__PURE__ */ qL();
const Be = /* @__PURE__ */ Lb(zL);
function __(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dr(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? __(Object(n), !0).forEach(function(r) {
      Cs(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : __(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function el(t) {
  "@babel/helpers - typeof";
  return el = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, el(t);
}
function Cs(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function WL(t, e) {
  if (t == null) return {};
  var n = {}, r = Object.keys(t), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
function GL(t, e) {
  if (t == null) return {};
  var n = WL(t, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t);
    for (i = 0; i < s.length; i++)
      r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
function Sf(t) {
  return HL(t) || KL(t) || YL(t) || XL();
}
function HL(t) {
  if (Array.isArray(t)) return Af(t);
}
function KL(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function YL(t, e) {
  if (t) {
    if (typeof t == "string") return Af(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Af(t, e);
  }
}
function Af(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function XL() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function QL(t) {
  var e, n = t.beat, r = t.fade, i = t.beatFade, s = t.bounce, o = t.shake, a = t.flash, l = t.spin, u = t.spinPulse, d = t.spinReverse, f = t.pulse, p = t.fixedWidth, g = t.inverse, _ = t.border, b = t.listItem, m = t.flip, v = t.size, C = t.rotation, x = t.pull, P = (e = {
    "fa-beat": n,
    "fa-fade": r,
    "fa-beat-fade": i,
    "fa-bounce": s,
    "fa-shake": o,
    "fa-flash": a,
    "fa-spin": l,
    "fa-spin-reverse": d,
    "fa-spin-pulse": u,
    "fa-pulse": f,
    "fa-fw": p,
    "fa-inverse": g,
    "fa-border": _,
    "fa-li": b,
    "fa-flip": m === !0,
    "fa-flip-horizontal": m === "horizontal" || m === "both",
    "fa-flip-vertical": m === "vertical" || m === "both"
  }, Cs(e, "fa-".concat(v), typeof v < "u" && v !== null), Cs(e, "fa-rotate-".concat(C), typeof C < "u" && C !== null && C !== 0), Cs(e, "fa-pull-".concat(x), typeof x < "u" && x !== null), Cs(e, "fa-swap-opacity", t.swapOpacity), e);
  return Object.keys(P).map(function(k) {
    return P[k] ? k : null;
  }).filter(function(k) {
    return k;
  });
}
function JL(t) {
  return t = t - 0, t === t;
}
function TT(t) {
  return JL(t) ? t : (t = t.replace(/[\-_\s]+(.)?/g, function(e, n) {
    return n ? n.toUpperCase() : "";
  }), t.substr(0, 1).toLowerCase() + t.substr(1));
}
var ZL = ["style"];
function eU(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function tU(t) {
  return t.split(";").map(function(e) {
    return e.trim();
  }).filter(function(e) {
    return e;
  }).reduce(function(e, n) {
    var r = n.indexOf(":"), i = TT(n.slice(0, r)), s = n.slice(r + 1).trim();
    return i.startsWith("webkit") ? e[eU(i)] = s : e[i] = s, e;
  }, {});
}
function IT(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof e == "string")
    return e;
  var r = (e.children || []).map(function(l) {
    return IT(t, l);
  }), i = Object.keys(e.attributes || {}).reduce(function(l, u) {
    var d = e.attributes[u];
    switch (u) {
      case "class":
        l.attrs.className = d, delete e.attributes.class;
        break;
      case "style":
        l.attrs.style = tU(d);
        break;
      default:
        u.indexOf("aria-") === 0 || u.indexOf("data-") === 0 ? l.attrs[u.toLowerCase()] = d : l.attrs[TT(u)] = d;
    }
    return l;
  }, {
    attrs: {}
  }), s = n.style, o = s === void 0 ? {} : s, a = GL(n, ZL);
  return i.attrs.style = dr(dr({}, i.attrs.style), o), t.apply(void 0, [e.tag, dr(dr({}, i.attrs), a)].concat(Sf(r)));
}
var ST = !1;
try {
  ST = process.env.NODE_ENV === "production";
} catch {
}
function nU() {
  if (!ST && console && typeof console.error == "function") {
    var t;
    (t = console).error.apply(t, arguments);
  }
}
function b_(t) {
  if (t && el(t) === "object" && t.prefix && t.iconName && t.icon)
    return t;
  if (If.icon)
    return If.icon(t);
  if (t === null)
    return null;
  if (t && el(t) === "object" && t.prefix && t.iconName)
    return t;
  if (Array.isArray(t) && t.length === 2)
    return {
      prefix: t[0],
      iconName: t[1]
    };
  if (typeof t == "string")
    return {
      prefix: "fas",
      iconName: t
    };
}
function xu(t, e) {
  return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? Cs({}, t, e) : {};
}
var v_ = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1
}, bp = /* @__PURE__ */ Me.forwardRef(function(t, e) {
  var n = dr(dr({}, v_), t), r = n.icon, i = n.mask, s = n.symbol, o = n.className, a = n.title, l = n.titleId, u = n.maskId, d = b_(r), f = xu("classes", [].concat(Sf(QL(n)), Sf((o || "").split(" ")))), p = xu("transform", typeof n.transform == "string" ? If.transform(n.transform) : n.transform), g = xu("mask", b_(i)), _ = FL(d, dr(dr(dr(dr({}, f), p), g), {}, {
    symbol: s,
    title: a,
    titleId: l,
    maskId: u
  }));
  if (!_)
    return nU("Could not find icon", d), null;
  var b = _.abstract, m = {
    ref: e
  };
  return Object.keys(n).forEach(function(v) {
    v_.hasOwnProperty(v) || (m[v] = n[v]);
  }), rU(b[0], m);
});
bp.displayName = "FontAwesomeIcon";
bp.propTypes = {
  beat: Be.bool,
  border: Be.bool,
  beatFade: Be.bool,
  bounce: Be.bool,
  className: Be.string,
  fade: Be.bool,
  flash: Be.bool,
  mask: Be.oneOfType([Be.object, Be.array, Be.string]),
  maskId: Be.string,
  fixedWidth: Be.bool,
  inverse: Be.bool,
  flip: Be.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: Be.oneOfType([Be.object, Be.array, Be.string]),
  listItem: Be.bool,
  pull: Be.oneOf(["right", "left"]),
  pulse: Be.bool,
  rotation: Be.oneOf([0, 90, 180, 270]),
  shake: Be.bool,
  size: Be.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: Be.bool,
  spinPulse: Be.bool,
  spinReverse: Be.bool,
  symbol: Be.oneOfType([Be.bool, Be.string]),
  title: Be.string,
  titleId: Be.string,
  transform: Be.oneOfType([Be.string, Be.object]),
  swapOpacity: Be.bool
};
var rU = IT.bind(null, Me.createElement);
const Vo = ({ icon: t, iconClassName: e }) => t ? /* @__PURE__ */ he(bp, { icon: t, className: Yt("pointer-events-none", e) }) : /* @__PURE__ */ he(Si, {});
function iU({
  children: t,
  leftIcon: e,
  rightIcon: n,
  topIcon: r,
  bottomIcon: i,
  className: s,
  icon: o,
  iconClassName: a,
  onPointerDown: l,
  onPointerLeave: u,
  onPointerUp: d,
  onMouseEnter: f,
  onMouseLeave: p,
  ...g
}) {
  const _ = at(!1), b = at(!1), m = at(!1);
  return vt(() => () => {
    _.set(!1), b.set(!1), m.set(!1);
  }, []), /* @__PURE__ */ bn(
    "button",
    {
      onFocus: () => {
        _.set(!0);
      },
      onBlur: () => {
        _.set(!1);
      },
      onMouseEnter: (v) => {
        m.set(!0), f == null || f(v);
      },
      onMouseLeave: (v) => {
        m.set(!1), p == null || p(v);
      },
      onPointerDown: (v) => {
        b.set(!0), l == null || l(v);
      },
      onPointerUp: (v) => {
        b.set(!1), d == null || d(v);
      },
      onPointerLeave: (v) => {
        b.set(!1), u == null || u(v);
      },
      type: "button",
      className: Yt(
        "relative bg-[--biqpod-primary] px-3 py-2 rounded-md w-full overflow-hidden text-[--biqpod-primary-content] capitalize active:scale-95 transition-[transform] cursor-pointer btn",
        s
      ),
      ...g,
      children: [
        /* @__PURE__ */ he("i", { className: "bg-[--biqpod-opacity] btn_bg" }),
        /* @__PURE__ */ bn("div", { className: "flex flex-col flex-none justify-center items-center gap-2 btn-content", children: [
          /* @__PURE__ */ he(Vo, { iconClassName: a, icon: r }),
          /* @__PURE__ */ bn("div", { className: "flex justify-center items-center gap-2", children: [
            /* @__PURE__ */ he(Vo, { iconClassName: a, icon: e || o }),
            t,
            /* @__PURE__ */ he(Vo, { iconClassName: a, icon: n })
          ] }),
          /* @__PURE__ */ he(Vo, { iconClassName: a, icon: i })
        ] })
      ]
    }
  );
}
const sU = ({ className: t, style: e, ...n }) => /* @__PURE__ */ he(
  "div",
  {
    ...n,
    className: gI("flex flex-col bg-[--biqpod-secondary-background] shadow-lg border border-[--biqpod-borders] border-solid rounded-2xl", t),
    style: {
      ...e
    }
  }
), oU = pI(({ children: t, className: e, style: n, onPointerDown: r, onPointerLeave: i, onPointerUp: s, onMouseEnter: o, onMouseLeave: a, ...l }, u) => {
  const d = vn(), f = at(!1), p = at(!1), g = at(!1);
  vt(() => () => {
    f.set(!1), p.set(!1), g.set(!1);
  }, []);
  const _ = Me.useMemo(() => ({
    ...d(
      f.get && {
        boxShadow: Xc([
          {
            colorId: "shadow.color",
            isInset: !0,
            blur: 1
          }
        ])
      }
    )
  }), [d, f.get, Xc]);
  return /* @__PURE__ */ bn(
    "div",
    {
      ref: u,
      onFocus: () => {
        f.set(!0);
      },
      onBlur: () => {
        f.set(!1);
      },
      onMouseEnter: (b) => {
        g.set(!0), o == null || o(b);
      },
      onMouseLeave: (b) => {
        g.set(!1), a == null || a(b);
      },
      onPointerDown: (b) => {
        p.set(!0), r == null || r(b);
      },
      onPointerUp: (b) => {
        p.set(!1), s == null || s(b);
      },
      onPointerLeave: (b) => {
        p.set(!1), i == null || i(b);
      },
      style: {
        ...Db(_, n)
      },
      className: Yt("relative w-full overflow-hidden transition-[transform] select-none btn", e),
      ...l,
      children: [
        /* @__PURE__ */ he("i", { className: "bg-[--biqpod-opacity] btn_bg" }),
        /* @__PURE__ */ he("div", { className: "w-full h-full btn-content", children: t })
      ]
    }
  );
});
oU.displayName = "ClickedView";
const Z$ = Me.forwardRef(
  ({ focusId: t = $t(30), id: e, children: n, onFocus: r, onBlur: i, style: s, className: o, ignoreOutline: a = !1, ...l }, u) => {
    const d = at(!1), f = vn();
    return /* @__PURE__ */ bn(
      "div",
      {
        ref: u,
        tabIndex: 1,
        id: t,
        onFocus: (p) => {
          d.set(!0), r == null || r(p);
        },
        onBlur: (p) => {
          d.set(!1), i == null || i(p);
        },
        style: {
          ...s
        },
        className: Yt("relative", o),
        ...l,
        children: [
          n,
          /* @__PURE__ */ he(
            "div",
            {
              hidden: a,
              className: Yt(
                o,
                `
              inset-0
              absolute
              pointer-events-none
              border
              border-solid
              border-transparent
              block
              m-0
              p-0
              bg-transparent
              w-auto
              h-auto
            `
              ),
              style: {
                ...f(d.get && { borderColor: "primary" })
              }
            }
          )
        ]
      }
    );
  }
), ej = Me.forwardRef(
  ({ className: t, selectOnFocus: e, onFocus: n, onBlur: r, onValueChange: i, onChange: s, style: o, ...a }, l) => {
    const u = vn(), d = at(!1);
    return /* @__PURE__ */ he(
      "input",
      {
        ...a,
        ref: l,
        onFocus: (f) => {
          d.set(!0), e && f.currentTarget.select(), n == null || n(f);
        },
        onBlur: (f) => {
          d.set(!1), r == null || r(f);
        },
        className: Yt("p-2 border border-solid border-transparent font-[inherit] resize-none whitespace-nowrap rounded-sm w-full", t),
        style: {
          ...u(
            {
              borderColor: "borders",
              backgroundColor: "field.background"
            },
            d.get && {
              borderColor: "primary"
            }
          ),
          ...o
        },
        onChange: (f) => {
          i == null || i(f.currentTarget.value, f.currentTarget.valueAsNumber), s == null || s(f);
        }
      }
    );
  }
);
function AT({ joinComponent: t, list: e }) {
  return Me.useMemo(() => {
    const r = [], i = e.length;
    let s = 0;
    return e.forEach((o, a) => {
      r.push(/* @__PURE__ */ he(Si, { children: o }, s)), a + 1 != i && r.push(/* @__PURE__ */ he(Si, { children: t }, s + 1)), s += 2;
    }), r;
  }, [e, t]);
}
const RT = (t, e) => {
  const n = Hs.getEntity(), r = at(!1), i = Er("system.base"), s = Bs("window/lang.enum"), o = Me.useMemo(() => e || s, [e, s]);
  Me.useEffect(() => {
    r.get && (VS(), r.set(!1));
  }, [i, r.get]);
  const a = Me.useMemo(() => wc(t, "normal", "cabab").toLowerCase(), [t]), l = Me.useMemo(() => {
    var f;
    return o ? (f = n[a]) == null ? void 0 : f[o] : void 0;
  }, [n, a]), u = Vs(async () => {
    if (o && !l && o != "en") {
      const f = Ur();
      if (!f)
        return;
      await new Promise((p) => {
        Qc(
          "langs.isTranslateBefore",
          (g) => !g,
          () => {
            p(!0);
          }
        );
      }), Et("langs.isTranslateBefore", !0);
      try {
        const p = await f.app.ai.translate(t, o);
        p && (r.set(!0), Hs.upsert([{ word: a, [o]: p }]));
      } catch {
      }
      Et("langs.isTranslateBefore", !1);
    }
  }, [l, a, o, t]);
  return [Me.useMemo(() => l || t, [l, t]), u];
};
function E_({ content: t, lang: e }) {
  const [n, r] = RT(t, e);
  return /* @__PURE__ */ he(Si, { children: r ? "..." : n });
}
function tj({ component: t, content: e, lang: n }) {
  const [r, i] = RT(e, n);
  return /* @__PURE__ */ he(Si, { children: t({ result: r, isLoading: i }) });
}
function aU() {
  const t = vn();
  return /* @__PURE__ */ he(
    "div",
    {
      className: "w-full h-[1px]",
      style: {
        ...t("borders")
      }
    }
  );
}
const nj = () => {
  const t = vn();
  return /* @__PURE__ */ he(
    "div",
    {
      className: "w-[1px] h-full",
      style: {
        ...t("borders")
      }
    }
  );
}, rj = () => {
  const t = vn();
  return /* @__PURE__ */ he(
    "div",
    {
      className: "w-full h-[1px]",
      style: {
        ...t("borders")
      }
    }
  );
};
var Mu, w_;
function cU() {
  if (w_) return Mu;
  w_ = 1;
  function t(N) {
    return N instanceof Map ? N.clear = N.delete = N.set = function() {
      throw new Error("map is read-only");
    } : N instanceof Set && (N.add = N.clear = N.delete = function() {
      throw new Error("set is read-only");
    }), Object.freeze(N), Object.getOwnPropertyNames(N).forEach(($) => {
      const Q = N[$], Re = typeof Q;
      (Re === "object" || Re === "function") && !Object.isFrozen(Q) && t(Q);
    }), N;
  }
  class e {
    /**
     * @param {CompiledMode} mode
     */
    constructor($) {
      $.data === void 0 && ($.data = {}), this.data = $.data, this.isMatchIgnored = !1;
    }
    ignoreMatch() {
      this.isMatchIgnored = !0;
    }
  }
  function n(N) {
    return N.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function r(N, ...$) {
    const Q = /* @__PURE__ */ Object.create(null);
    for (const Re in N)
      Q[Re] = N[Re];
    return $.forEach(function(Re) {
      for (const Je in Re)
        Q[Je] = Re[Je];
    }), /** @type {T} */
    Q;
  }
  const i = "</span>", s = (N) => !!N.scope, o = (N, { prefix: $ }) => {
    if (N.startsWith("language:"))
      return N.replace("language:", "language-");
    if (N.includes(".")) {
      const Q = N.split(".");
      return [
        `${$}${Q.shift()}`,
        ...Q.map((Re, Je) => `${Re}${"_".repeat(Je + 1)}`)
      ].join(" ");
    }
    return `${$}${N}`;
  };
  class a {
    /**
     * Creates a new HTMLRenderer
     *
     * @param {Tree} parseTree - the parse tree (must support `walk` API)
     * @param {{classPrefix: string}} options
     */
    constructor($, Q) {
      this.buffer = "", this.classPrefix = Q.classPrefix, $.walk(this);
    }
    /**
     * Adds texts to the output stream
     *
     * @param {string} text */
    addText($) {
      this.buffer += n($);
    }
    /**
     * Adds a node open to the output stream (if needed)
     *
     * @param {Node} node */
    openNode($) {
      if (!s($)) return;
      const Q = o(
        $.scope,
        { prefix: this.classPrefix }
      );
      this.span(Q);
    }
    /**
     * Adds a node close to the output stream (if needed)
     *
     * @param {Node} node */
    closeNode($) {
      s($) && (this.buffer += i);
    }
    /**
     * returns the accumulated buffer
    */
    value() {
      return this.buffer;
    }
    // helpers
    /**
     * Builds a span element
     *
     * @param {string} className */
    span($) {
      this.buffer += `<span class="${$}">`;
    }
  }
  const l = (N = {}) => {
    const $ = { children: [] };
    return Object.assign($, N), $;
  };
  class u {
    constructor() {
      this.rootNode = l(), this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    /** @param {Node} node */
    add($) {
      this.top.children.push($);
    }
    /** @param {string} scope */
    openNode($) {
      const Q = l({ scope: $ });
      this.add(Q), this.stack.push(Q);
    }
    closeNode() {
      if (this.stack.length > 1)
        return this.stack.pop();
    }
    closeAllNodes() {
      for (; this.closeNode(); ) ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    /**
     * @typedef { import("./html_renderer").Renderer } Renderer
     * @param {Renderer} builder
     */
    walk($) {
      return this.constructor._walk($, this.rootNode);
    }
    /**
     * @param {Renderer} builder
     * @param {Node} node
     */
    static _walk($, Q) {
      return typeof Q == "string" ? $.addText(Q) : Q.children && ($.openNode(Q), Q.children.forEach((Re) => this._walk($, Re)), $.closeNode(Q)), $;
    }
    /**
     * @param {Node} node
     */
    static _collapse($) {
      typeof $ != "string" && $.children && ($.children.every((Q) => typeof Q == "string") ? $.children = [$.children.join("")] : $.children.forEach((Q) => {
        u._collapse(Q);
      }));
    }
  }
  class d extends u {
    /**
     * @param {*} options
     */
    constructor($) {
      super(), this.options = $;
    }
    /**
     * @param {string} text
     */
    addText($) {
      $ !== "" && this.add($);
    }
    /** @param {string} scope */
    startScope($) {
      this.openNode($);
    }
    endScope() {
      this.closeNode();
    }
    /**
     * @param {Emitter & {root: DataNode}} emitter
     * @param {string} name
     */
    __addSublanguage($, Q) {
      const Re = $.root;
      Q && (Re.scope = `language:${Q}`), this.add(Re);
    }
    toHTML() {
      return new a(this, this.options).value();
    }
    finalize() {
      return this.closeAllNodes(), !0;
    }
  }
  function f(N) {
    return N ? typeof N == "string" ? N : N.source : null;
  }
  function p(N) {
    return b("(?=", N, ")");
  }
  function g(N) {
    return b("(?:", N, ")*");
  }
  function _(N) {
    return b("(?:", N, ")?");
  }
  function b(...N) {
    return N.map((Q) => f(Q)).join("");
  }
  function m(N) {
    const $ = N[N.length - 1];
    return typeof $ == "object" && $.constructor === Object ? (N.splice(N.length - 1, 1), $) : {};
  }
  function v(...N) {
    return "(" + (m(N).capture ? "" : "?:") + N.map((Re) => f(Re)).join("|") + ")";
  }
  function C(N) {
    return new RegExp(N.toString() + "|").exec("").length - 1;
  }
  function x(N, $) {
    const Q = N && N.exec($);
    return Q && Q.index === 0;
  }
  const P = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function k(N, { joinWith: $ }) {
    let Q = 0;
    return N.map((Re) => {
      Q += 1;
      const Je = Q;
      let dt = f(Re), ee = "";
      for (; dt.length > 0; ) {
        const oe = P.exec(dt);
        if (!oe) {
          ee += dt;
          break;
        }
        ee += dt.substring(0, oe.index), dt = dt.substring(oe.index + oe[0].length), oe[0][0] === "\\" && oe[1] ? ee += "\\" + String(Number(oe[1]) + Je) : (ee += oe[0], oe[0] === "(" && Q++);
      }
      return ee;
    }).map((Re) => `(${Re})`).join($);
  }
  const U = /\b\B/, I = "[a-zA-Z]\\w*", E = "[a-zA-Z_]\\w*", T = "\\b\\d+(\\.\\d+)?", A = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", R = "\\b(0b[01]+)", M = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", S = (N = {}) => {
    const $ = /^#![ ]*\//;
    return N.binary && (N.begin = b(
      $,
      /.*\b/,
      N.binary,
      /\b.*/
    )), r({
      scope: "meta",
      begin: $,
      end: /$/,
      relevance: 0,
      /** @type {ModeCallback} */
      "on:begin": (Q, Re) => {
        Q.index !== 0 && Re.ignoreMatch();
      }
    }, N);
  }, D = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  }, V = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [D]
  }, X = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [D]
  }, ge = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  }, Te = function(N, $, Q = {}) {
    const Re = r(
      {
        scope: "comment",
        begin: N,
        end: $,
        contains: []
      },
      Q
    );
    Re.contains.push({
      scope: "doctag",
      // hack to avoid the space from being included. the space is necessary to
      // match here to prevent the plain text rule below from gobbling up doctags
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0
    });
    const Je = v(
      // list of common 1 and 2 letter words in English
      "I",
      "a",
      "is",
      "so",
      "us",
      "to",
      "at",
      "if",
      "in",
      "it",
      "on",
      // note: this is not an exhaustive list of contractions, just popular ones
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      // contractions - can't we'd they're let's, etc
      /[A-Za-z]+[-][a-z]+/,
      // `no-way`, etc.
      /[A-Za-z][a-z]{2,}/
      // allow capitalized words at beginning of sentences
    );
    return Re.contains.push(
      {
        // TODO: how to include ", (, ) without breaking grammars that use these for
        // comment delimiters?
        // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
        // ---
        // this tries to find sequences of 3 english words in a row (without any
        // "programming" type syntax) this gives us a strong signal that we've
        // TRULY found a comment - vs perhaps scanning with the wrong language.
        // It's possible to find something that LOOKS like the start of the
        // comment - but then if there is no readable text - good chance it is a
        // false match and not a comment.
        //
        // for a visual example please see:
        // https://github.com/highlightjs/highlight.js/issues/2827
        begin: b(
          /[ ]+/,
          // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
          "(",
          Je,
          /[.]?[:]?([.][ ]|[ ])/,
          "){3}"
        )
        // look for 3 words in a row
      }
    ), Re;
  }, Ie = Te("//", "$"), B = Te("/\\*", "\\*/"), q = Te("#", "$"), se = {
    scope: "number",
    begin: T,
    relevance: 0
  }, re = {
    scope: "number",
    begin: A,
    relevance: 0
  }, ae = {
    scope: "number",
    begin: R,
    relevance: 0
  }, ce = {
    scope: "regexp",
    begin: /\/(?=[^/\n]*\/)/,
    end: /\/[gimuy]*/,
    contains: [
      D,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [D]
      }
    ]
  }, pe = {
    scope: "title",
    begin: I,
    relevance: 0
  }, ie = {
    scope: "title",
    begin: E,
    relevance: 0
  }, le = {
    // excludes method names from keyword processing
    begin: "\\.\\s*" + E,
    relevance: 0
  };
  var de = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    APOS_STRING_MODE: V,
    BACKSLASH_ESCAPE: D,
    BINARY_NUMBER_MODE: ae,
    BINARY_NUMBER_RE: R,
    COMMENT: Te,
    C_BLOCK_COMMENT_MODE: B,
    C_LINE_COMMENT_MODE: Ie,
    C_NUMBER_MODE: re,
    C_NUMBER_RE: A,
    END_SAME_AS_BEGIN: function(N) {
      return Object.assign(
        N,
        {
          /** @type {ModeCallback} */
          "on:begin": ($, Q) => {
            Q.data._beginMatch = $[1];
          },
          /** @type {ModeCallback} */
          "on:end": ($, Q) => {
            Q.data._beginMatch !== $[1] && Q.ignoreMatch();
          }
        }
      );
    },
    HASH_COMMENT_MODE: q,
    IDENT_RE: I,
    MATCH_NOTHING_RE: U,
    METHOD_GUARD: le,
    NUMBER_MODE: se,
    NUMBER_RE: T,
    PHRASAL_WORDS_MODE: ge,
    QUOTE_STRING_MODE: X,
    REGEXP_MODE: ce,
    RE_STARTERS_RE: M,
    SHEBANG: S,
    TITLE_MODE: pe,
    UNDERSCORE_IDENT_RE: E,
    UNDERSCORE_TITLE_MODE: ie
  });
  function Le(N, $) {
    N.input[N.index - 1] === "." && $.ignoreMatch();
  }
  function K(N, $) {
    N.className !== void 0 && (N.scope = N.className, delete N.className);
  }
  function Qe(N, $) {
    $ && N.beginKeywords && (N.begin = "\\b(" + N.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", N.__beforeBegin = Le, N.keywords = N.keywords || N.beginKeywords, delete N.beginKeywords, N.relevance === void 0 && (N.relevance = 0));
  }
  function ue(N, $) {
    Array.isArray(N.illegal) && (N.illegal = v(...N.illegal));
  }
  function Ut(N, $) {
    if (N.match) {
      if (N.begin || N.end) throw new Error("begin & end are not supported with match");
      N.begin = N.match, delete N.match;
    }
  }
  function Ft(N, $) {
    N.relevance === void 0 && (N.relevance = 1);
  }
  const kn = (N, $) => {
    if (!N.beforeMatch) return;
    if (N.starts) throw new Error("beforeMatch cannot be used with starts");
    const Q = Object.assign({}, N);
    Object.keys(N).forEach((Re) => {
      delete N[Re];
    }), N.keywords = Q.keywords, N.begin = b(Q.beforeMatch, p(Q.begin)), N.starts = {
      relevance: 0,
      contains: [
        Object.assign(Q, { endsParent: !0 })
      ]
    }, N.relevance = 0, delete Q.beforeMatch;
  }, Ir = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    // common variable name
    "list",
    // common variable name
    "value"
    // common variable name
  ], zn = "keyword";
  function sr(N, $, Q = zn) {
    const Re = /* @__PURE__ */ Object.create(null);
    return typeof N == "string" ? Je(Q, N.split(" ")) : Array.isArray(N) ? Je(Q, N) : Object.keys(N).forEach(function(dt) {
      Object.assign(
        Re,
        sr(N[dt], $, dt)
      );
    }), Re;
    function Je(dt, ee) {
      $ && (ee = ee.map((oe) => oe.toLowerCase())), ee.forEach(function(oe) {
        const Ee = oe.split("|");
        Re[Ee[0]] = [dt, or(Ee[0], Ee[1])];
      });
    }
  }
  function or(N, $) {
    return $ ? Number($) : Sr(N) ? 0 : 1;
  }
  function Sr(N) {
    return Ir.includes(N.toLowerCase());
  }
  const ar = {}, un = (N) => {
    console.error(N);
  }, En = (N, ...$) => {
    console.log(`WARN: ${N}`, ...$);
  }, We = (N, $) => {
    ar[`${N}/${$}`] || (console.log(`Deprecated as of ${N}. ${$}`), ar[`${N}/${$}`] = !0);
  }, gt = new Error();
  function Wn(N, $, { key: Q }) {
    let Re = 0;
    const Je = N[Q], dt = {}, ee = {};
    for (let oe = 1; oe <= $.length; oe++)
      ee[oe + Re] = Je[oe], dt[oe + Re] = !0, Re += C($[oe - 1]);
    N[Q] = ee, N[Q]._emit = dt, N[Q]._multi = !0;
  }
  function cr(N) {
    if (Array.isArray(N.begin)) {
      if (N.skip || N.excludeBegin || N.returnBegin)
        throw un("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), gt;
      if (typeof N.beginScope != "object" || N.beginScope === null)
        throw un("beginScope must be object"), gt;
      Wn(N, N.begin, { key: "beginScope" }), N.begin = k(N.begin, { joinWith: "" });
    }
  }
  function Gn(N) {
    if (Array.isArray(N.end)) {
      if (N.skip || N.excludeEnd || N.returnEnd)
        throw un("skip, excludeEnd, returnEnd not compatible with endScope: {}"), gt;
      if (typeof N.endScope != "object" || N.endScope === null)
        throw un("endScope must be object"), gt;
      Wn(N, N.end, { key: "endScope" }), N.end = k(N.end, { joinWith: "" });
    }
  }
  function Oi(N) {
    N.scope && typeof N.scope == "object" && N.scope !== null && (N.beginScope = N.scope, delete N.scope);
  }
  function Nn(N) {
    Oi(N), typeof N.beginScope == "string" && (N.beginScope = { _wrap: N.beginScope }), typeof N.endScope == "string" && (N.endScope = { _wrap: N.endScope }), cr(N), Gn(N);
  }
  function ti(N) {
    function $(ee, oe) {
      return new RegExp(
        f(ee),
        "m" + (N.case_insensitive ? "i" : "") + (N.unicodeRegex ? "u" : "") + (oe ? "g" : "")
      );
    }
    class Q {
      constructor() {
        this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
      }
      // @ts-ignore
      addRule(oe, Ee) {
        Ee.position = this.position++, this.matchIndexes[this.matchAt] = Ee, this.regexes.push([Ee, oe]), this.matchAt += C(oe) + 1;
      }
      compile() {
        this.regexes.length === 0 && (this.exec = () => null);
        const oe = this.regexes.map((Ee) => Ee[1]);
        this.matcherRe = $(k(oe, { joinWith: "|" }), !0), this.lastIndex = 0;
      }
      /** @param {string} s */
      exec(oe) {
        this.matcherRe.lastIndex = this.lastIndex;
        const Ee = this.matcherRe.exec(oe);
        if (!Ee)
          return null;
        const ft = Ee.findIndex((Cr, On) => On > 0 && Cr !== void 0), _t = this.matchIndexes[ft];
        return Ee.splice(0, ft), Object.assign(Ee, _t);
      }
    }
    class Re {
      constructor() {
        this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
      }
      // @ts-ignore
      getMatcher(oe) {
        if (this.multiRegexes[oe]) return this.multiRegexes[oe];
        const Ee = new Q();
        return this.rules.slice(oe).forEach(([ft, _t]) => Ee.addRule(ft, _t)), Ee.compile(), this.multiRegexes[oe] = Ee, Ee;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      // @ts-ignore
      addRule(oe, Ee) {
        this.rules.push([oe, Ee]), Ee.type === "begin" && this.count++;
      }
      /** @param {string} s */
      exec(oe) {
        const Ee = this.getMatcher(this.regexIndex);
        Ee.lastIndex = this.lastIndex;
        let ft = Ee.exec(oe);
        if (this.resumingScanAtSamePosition() && !(ft && ft.index === this.lastIndex)) {
          const _t = this.getMatcher(0);
          _t.lastIndex = this.lastIndex + 1, ft = _t.exec(oe);
        }
        return ft && (this.regexIndex += ft.position + 1, this.regexIndex === this.count && this.considerAll()), ft;
      }
    }
    function Je(ee) {
      const oe = new Re();
      return ee.contains.forEach((Ee) => oe.addRule(Ee.begin, { rule: Ee, type: "begin" })), ee.terminatorEnd && oe.addRule(ee.terminatorEnd, { type: "end" }), ee.illegal && oe.addRule(ee.illegal, { type: "illegal" }), oe;
    }
    function dt(ee, oe) {
      const Ee = (
        /** @type CompiledMode */
        ee
      );
      if (ee.isCompiled) return Ee;
      [
        K,
        // do this early so compiler extensions generally don't have to worry about
        // the distinction between match/begin
        Ut,
        Nn,
        kn
      ].forEach((_t) => _t(ee, oe)), N.compilerExtensions.forEach((_t) => _t(ee, oe)), ee.__beforeBegin = null, [
        Qe,
        // do this later so compiler extensions that come earlier have access to the
        // raw array if they wanted to perhaps manipulate it, etc.
        ue,
        // default to 1 relevance if not specified
        Ft
      ].forEach((_t) => _t(ee, oe)), ee.isCompiled = !0;
      let ft = null;
      return typeof ee.keywords == "object" && ee.keywords.$pattern && (ee.keywords = Object.assign({}, ee.keywords), ft = ee.keywords.$pattern, delete ee.keywords.$pattern), ft = ft || /\w+/, ee.keywords && (ee.keywords = sr(ee.keywords, N.case_insensitive)), Ee.keywordPatternRe = $(ft, !0), oe && (ee.begin || (ee.begin = /\B|\b/), Ee.beginRe = $(Ee.begin), !ee.end && !ee.endsWithParent && (ee.end = /\B|\b/), ee.end && (Ee.endRe = $(Ee.end)), Ee.terminatorEnd = f(Ee.end) || "", ee.endsWithParent && oe.terminatorEnd && (Ee.terminatorEnd += (ee.end ? "|" : "") + oe.terminatorEnd)), ee.illegal && (Ee.illegalRe = $(
        /** @type {RegExp | string} */
        ee.illegal
      )), ee.contains || (ee.contains = []), ee.contains = [].concat(...ee.contains.map(function(_t) {
        return Rr(_t === "self" ? ee : _t);
      })), ee.contains.forEach(function(_t) {
        dt(
          /** @type Mode */
          _t,
          Ee
        );
      }), ee.starts && dt(ee.starts, oe), Ee.matcher = Je(Ee), Ee;
    }
    if (N.compilerExtensions || (N.compilerExtensions = []), N.contains && N.contains.includes("self"))
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    return N.classNameAliases = r(N.classNameAliases || {}), dt(
      /** @type Mode */
      N
    );
  }
  function Ar(N) {
    return N ? N.endsWithParent || Ar(N.starts) : !1;
  }
  function Rr(N) {
    return N.variants && !N.cachedVariants && (N.cachedVariants = N.variants.map(function($) {
      return r(N, { variants: null }, $);
    })), N.cachedVariants ? N.cachedVariants : Ar(N) ? r(N, { starts: N.starts ? r(N.starts) : null }) : Object.isFrozen(N) ? r(N) : N;
  }
  var Pi = "11.11.1";
  class xi extends Error {
    constructor($, Q) {
      super($), this.name = "HTMLInjectionError", this.html = Q;
    }
  }
  const wn = n, lr = r, Ue = Symbol("nomatch"), Zt = 7, en = function(N) {
    const $ = /* @__PURE__ */ Object.create(null), Q = /* @__PURE__ */ Object.create(null), Re = [];
    let Je = !0;
    const dt = "Could not find the language '{}', did you forget to load/include a language module?", ee = { disableAutodetect: !0, name: "Plain text", contains: [] };
    let oe = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      // beta configuration options, subject to change, welcome to discuss
      // https://github.com/highlightjs/highlight.js/issues/1086
      __emitter: d
    };
    function Ee(Y) {
      return oe.noHighlightRe.test(Y);
    }
    function ft(Y) {
      let be = Y.className + " ";
      be += Y.parentNode ? Y.parentNode.className : "";
      const Ve = oe.languageDetectRe.exec(be);
      if (Ve) {
        const rt = bt(Ve[1]);
        return rt || (En(dt.replace("{}", Ve[1])), En("Falling back to no-highlight mode for this block.", Y)), rt ? Ve[1] : "no-highlight";
      }
      return be.split(/\s+/).find((rt) => Ee(rt) || bt(rt));
    }
    function _t(Y, be, Ve) {
      let rt = "", It = "";
      typeof be == "object" ? (rt = Y, Ve = be.ignoreIllegals, It = be.language) : (We("10.7.0", "highlight(lang, code, ...args) has been deprecated."), We("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), It = Y, rt = be), Ve === void 0 && (Ve = !0);
      const fn = {
        code: rt,
        language: It
      };
      Mn("before:highlight", fn);
      const Dn = fn.result ? fn.result : Cr(fn.language, fn.code, Ve);
      return Dn.code = fn.code, Mn("after:highlight", Dn), Dn;
    }
    function Cr(Y, be, Ve, rt) {
      const It = /* @__PURE__ */ Object.create(null);
      function fn(J, me) {
        return J.keywords[me];
      }
      function Dn() {
        if (!Ce.keywords) {
          Mt.addText(ot);
          return;
        }
        let J = 0;
        Ce.keywordPatternRe.lastIndex = 0;
        let me = Ce.keywordPatternRe.exec(ot), De = "";
        for (; me; ) {
          De += ot.substring(J, me.index);
          const Ke = je.case_insensitive ? me[0].toLowerCase() : me[0], wt = fn(Ce, Ke);
          if (wt) {
            const [Kn, Hl] = wt;
            if (Mt.addText(De), De = "", It[Ke] = (It[Ke] || 0) + 1, It[Ke] <= Zt && (ms += Hl), Kn.startsWith("_"))
              De += me[0];
            else {
              const Kl = je.classNameAliases[Kn] || Kn;
              Ln(me[0], Kl);
            }
          } else
            De += me[0];
          J = Ce.keywordPatternRe.lastIndex, me = Ce.keywordPatternRe.exec(ot);
        }
        De += ot.substring(J), Mt.addText(De);
      }
      function Di() {
        if (ot === "") return;
        let J = null;
        if (typeof Ce.subLanguage == "string") {
          if (!$[Ce.subLanguage]) {
            Mt.addText(ot);
            return;
          }
          J = Cr(Ce.subLanguage, ot, !0, Oa[Ce.subLanguage]), Oa[Ce.subLanguage] = /** @type {CompiledMode} */
          J._top;
        } else
          J = O(ot, Ce.subLanguage.length ? Ce.subLanguage : null);
        Ce.relevance > 0 && (ms += J.relevance), Mt.__addSublanguage(J._emitter, J.language);
      }
      function tn() {
        Ce.subLanguage != null ? Di() : Dn(), ot = "";
      }
      function Ln(J, me) {
        J !== "" && (Mt.startScope(me), Mt.addText(J), Mt.endScope());
      }
      function Na(J, me) {
        let De = 1;
        const Ke = me.length - 1;
        for (; De <= Ke; ) {
          if (!J._emit[De]) {
            De++;
            continue;
          }
          const wt = je.classNameAliases[J[De]] || J[De], Kn = me[De];
          wt ? Ln(Kn, wt) : (ot = Kn, Dn(), ot = ""), De++;
        }
      }
      function go(J, me) {
        return J.scope && typeof J.scope == "string" && Mt.openNode(je.classNameAliases[J.scope] || J.scope), J.beginScope && (J.beginScope._wrap ? (Ln(ot, je.classNameAliases[J.beginScope._wrap] || J.beginScope._wrap), ot = "") : J.beginScope._multi && (Na(J.beginScope, me), ot = "")), Ce = Object.create(J, { parent: { value: Ce } }), Ce;
      }
      function yo(J, me, De) {
        let Ke = x(J.endRe, De);
        if (Ke) {
          if (J["on:end"]) {
            const wt = new e(J);
            J["on:end"](me, wt), wt.isMatchIgnored && (Ke = !1);
          }
          if (Ke) {
            for (; J.endsParent && J.parent; )
              J = J.parent;
            return J;
          }
        }
        if (J.endsWithParent)
          return yo(J.parent, me, De);
      }
      function Gl(J) {
        return Ce.matcher.regexIndex === 0 ? (ot += J[0], 1) : (Mr = !0, 0);
      }
      function Nr(J) {
        const me = J[0], De = J.rule, Ke = new e(De), wt = [De.__beforeBegin, De["on:begin"]];
        for (const Kn of wt)
          if (Kn && (Kn(J, Ke), Ke.isMatchIgnored))
            return Gl(me);
        return De.skip ? ot += me : (De.excludeBegin && (ot += me), tn(), !De.returnBegin && !De.excludeBegin && (ot = me)), go(De, J), De.returnBegin ? 0 : me.length;
      }
      function Hn(J) {
        const me = J[0], De = be.substring(J.index), Ke = yo(Ce, J, De);
        if (!Ke)
          return Ue;
        const wt = Ce;
        Ce.endScope && Ce.endScope._wrap ? (tn(), Ln(me, Ce.endScope._wrap)) : Ce.endScope && Ce.endScope._multi ? (tn(), Na(Ce.endScope, J)) : wt.skip ? ot += me : (wt.returnEnd || wt.excludeEnd || (ot += me), tn(), wt.excludeEnd && (ot = me));
        do
          Ce.scope && Mt.closeNode(), !Ce.skip && !Ce.subLanguage && (ms += Ce.relevance), Ce = Ce.parent;
        while (Ce !== Ke.parent);
        return Ke.starts && go(Ke.starts, J), wt.returnEnd ? 0 : me.length;
      }
      function hs() {
        const J = [];
        for (let me = Ce; me !== je; me = me.parent)
          me.scope && J.unshift(me.scope);
        J.forEach((me) => Mt.openNode(me));
      }
      let Or = {};
      function _o(J, me) {
        const De = me && me[0];
        if (ot += J, De == null)
          return tn(), 0;
        if (Or.type === "begin" && me.type === "end" && Or.index === me.index && De === "") {
          if (ot += be.slice(me.index, me.index + 1), !Je) {
            const Ke = new Error(`0 width match regex (${Y})`);
            throw Ke.languageName = Y, Ke.badRule = Or.rule, Ke;
          }
          return 1;
        }
        if (Or = me, me.type === "begin")
          return Nr(me);
        if (me.type === "illegal" && !Ve) {
          const Ke = new Error('Illegal lexeme "' + De + '" for mode "' + (Ce.scope || "<unnamed>") + '"');
          throw Ke.mode = Ce, Ke;
        } else if (me.type === "end") {
          const Ke = Hn(me);
          if (Ke !== Ue)
            return Ke;
        }
        if (me.type === "illegal" && De === "")
          return ot += `
`, 1;
        if (bo > 1e5 && bo > me.index * 3)
          throw new Error("potential infinite loop, way more iterations than matches");
        return ot += De, De.length;
      }
      const je = bt(Y);
      if (!je)
        throw un(dt.replace("{}", Y)), new Error('Unknown language: "' + Y + '"');
      const ps = ti(je);
      let Pr = "", Ce = rt || ps;
      const Oa = {}, Mt = new oe.__emitter(oe);
      hs();
      let ot = "", ms = 0, xr = 0, bo = 0, Mr = !1;
      try {
        if (je.__emitTokens)
          je.__emitTokens(be, Mt);
        else {
          for (Ce.matcher.considerAll(); ; ) {
            bo++, Mr ? Mr = !1 : Ce.matcher.considerAll(), Ce.matcher.lastIndex = xr;
            const J = Ce.matcher.exec(be);
            if (!J) break;
            const me = be.substring(xr, J.index), De = _o(me, J);
            xr = J.index + De;
          }
          _o(be.substring(xr));
        }
        return Mt.finalize(), Pr = Mt.toHTML(), {
          language: Y,
          value: Pr,
          relevance: ms,
          illegal: !1,
          _emitter: Mt,
          _top: Ce
        };
      } catch (J) {
        if (J.message && J.message.includes("Illegal"))
          return {
            language: Y,
            value: wn(be),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: J.message,
              index: xr,
              context: be.slice(xr - 100, xr + 100),
              mode: J.mode,
              resultSoFar: Pr
            },
            _emitter: Mt
          };
        if (Je)
          return {
            language: Y,
            value: wn(be),
            illegal: !1,
            relevance: 0,
            errorRaised: J,
            _emitter: Mt,
            _top: Ce
          };
        throw J;
      }
    }
    function On(Y) {
      const be = {
        value: wn(Y),
        illegal: !1,
        relevance: 0,
        _top: ee,
        _emitter: new oe.__emitter(oe)
      };
      return be._emitter.addText(Y), be;
    }
    function O(Y, be) {
      be = be || oe.languages || Object.keys($);
      const Ve = On(Y), rt = be.filter(bt).filter(xn).map(
        (tn) => Cr(tn, Y, !1)
      );
      rt.unshift(Ve);
      const It = rt.sort((tn, Ln) => {
        if (tn.relevance !== Ln.relevance) return Ln.relevance - tn.relevance;
        if (tn.language && Ln.language) {
          if (bt(tn.language).supersetOf === Ln.language)
            return 1;
          if (bt(Ln.language).supersetOf === tn.language)
            return -1;
        }
        return 0;
      }), [fn, Dn] = It, Di = fn;
      return Di.secondBest = Dn, Di;
    }
    function z(Y, be, Ve) {
      const rt = be && Q[be] || Ve;
      Y.classList.add("hljs"), Y.classList.add(`language-${rt}`);
    }
    function te(Y) {
      let be = null;
      const Ve = ft(Y);
      if (Ee(Ve)) return;
      if (Mn(
        "before:highlightElement",
        { el: Y, language: Ve }
      ), Y.dataset.highlighted) {
        console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", Y);
        return;
      }
      if (Y.children.length > 0 && (oe.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(Y)), oe.throwUnescapedHTML))
        throw new xi(
          "One of your code blocks includes unescaped HTML.",
          Y.innerHTML
        );
      be = Y;
      const rt = be.textContent, It = Ve ? _t(rt, { language: Ve, ignoreIllegals: !0 }) : O(rt);
      Y.innerHTML = It.value, Y.dataset.highlighted = "yes", z(Y, Ve, It.language), Y.result = {
        language: It.language,
        // TODO: remove with version 11.0
        re: It.relevance,
        relevance: It.relevance
      }, It.secondBest && (Y.secondBest = {
        language: It.secondBest.language,
        relevance: It.secondBest.relevance
      }), Mn("after:highlightElement", { el: Y, result: It, text: rt });
    }
    function Ae(Y) {
      oe = lr(oe, Y);
    }
    const $e = () => {
      Oe(), We("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    };
    function Ge() {
      Oe(), We("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }
    let ke = !1;
    function Oe() {
      function Y() {
        Oe();
      }
      if (document.readyState === "loading") {
        ke || window.addEventListener("DOMContentLoaded", Y, !1), ke = !0;
        return;
      }
      document.querySelectorAll(oe.cssSelector).forEach(te);
    }
    function xt(Y, be) {
      let Ve = null;
      try {
        Ve = be(N);
      } catch (rt) {
        if (un("Language definition for '{}' could not be registered.".replace("{}", Y)), Je)
          un(rt);
        else
          throw rt;
        Ve = ee;
      }
      Ve.name || (Ve.name = Y), $[Y] = Ve, Ve.rawDefinition = be.bind(null, N), Ve.aliases && Pn(Ve.aliases, { languageName: Y });
    }
    function lt(Y) {
      delete $[Y];
      for (const be of Object.keys(Q))
        Q[be] === Y && delete Q[be];
    }
    function ht() {
      return Object.keys($);
    }
    function bt(Y) {
      return Y = (Y || "").toLowerCase(), $[Y] || $[Q[Y]];
    }
    function Pn(Y, { languageName: be }) {
      typeof Y == "string" && (Y = [Y]), Y.forEach((Ve) => {
        Q[Ve.toLowerCase()] = be;
      });
    }
    function xn(Y) {
      const be = bt(Y);
      return be && !be.disableAutodetect;
    }
    function Nt(Y) {
      Y["before:highlightBlock"] && !Y["before:highlightElement"] && (Y["before:highlightElement"] = (be) => {
        Y["before:highlightBlock"](
          Object.assign({ block: be.el }, be)
        );
      }), Y["after:highlightBlock"] && !Y["after:highlightElement"] && (Y["after:highlightElement"] = (be) => {
        Y["after:highlightBlock"](
          Object.assign({ block: be.el }, be)
        );
      });
    }
    function ni(Y) {
      Nt(Y), Re.push(Y);
    }
    function Mi(Y) {
      const be = Re.indexOf(Y);
      be !== -1 && Re.splice(be, 1);
    }
    function Mn(Y, be) {
      const Ve = Y;
      Re.forEach(function(rt) {
        rt[Ve] && rt[Ve](be);
      });
    }
    function kr(Y) {
      return We("10.7.0", "highlightBlock will be removed entirely in v12.0"), We("10.7.0", "Please use highlightElement now."), te(Y);
    }
    Object.assign(N, {
      highlight: _t,
      highlightAuto: O,
      highlightAll: Oe,
      highlightElement: te,
      // TODO: Remove with v12 API
      highlightBlock: kr,
      configure: Ae,
      initHighlighting: $e,
      initHighlightingOnLoad: Ge,
      registerLanguage: xt,
      unregisterLanguage: lt,
      listLanguages: ht,
      getLanguage: bt,
      registerAliases: Pn,
      autoDetection: xn,
      inherit: lr,
      addPlugin: ni,
      removePlugin: Mi
    }), N.debugMode = function() {
      Je = !1;
    }, N.safeMode = function() {
      Je = !0;
    }, N.versionString = Pi, N.regex = {
      concat: b,
      lookahead: p,
      either: v,
      optional: _,
      anyNumberOfTimes: g
    };
    for (const Y in de)
      typeof de[Y] == "object" && t(de[Y]);
    return Object.assign(N, de), N;
  }, dn = en({});
  return dn.newInstance = () => en({}), Mu = dn, dn.HighlightJS = dn, dn.default = dn, Mu;
}
var Du, T_;
function lU() {
  if (T_) return Du;
  T_ = 1;
  function t(e) {
    const n = e.regex, r = n.concat(/[\p{L}_]/u, n.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), i = /[\p{L}0-9._:-]+/u, s = {
      className: "symbol",
      begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
    }, o = {
      begin: /\s/,
      contains: [
        {
          className: "keyword",
          begin: /#?[a-z_][a-z1-9_-]+/,
          illegal: /\n/
        }
      ]
    }, a = e.inherit(o, {
      begin: /\(/,
      end: /\)/
    }), l = e.inherit(e.APOS_STRING_MODE, { className: "string" }), u = e.inherit(e.QUOTE_STRING_MODE, { className: "string" }), d = {
      endsWithParent: !0,
      illegal: /</,
      relevance: 0,
      contains: [
        {
          className: "attr",
          begin: i,
          relevance: 0
        },
        {
          begin: /=\s*/,
          relevance: 0,
          contains: [
            {
              className: "string",
              endsParent: !0,
              variants: [
                {
                  begin: /"/,
                  end: /"/,
                  contains: [s]
                },
                {
                  begin: /'/,
                  end: /'/,
                  contains: [s]
                },
                { begin: /[^\s"'=<>`]+/ }
              ]
            }
          ]
        }
      ]
    };
    return {
      name: "HTML, XML",
      aliases: [
        "html",
        "xhtml",
        "rss",
        "atom",
        "xjb",
        "xsd",
        "xsl",
        "plist",
        "wsf",
        "svg"
      ],
      case_insensitive: !0,
      unicodeRegex: !0,
      contains: [
        {
          className: "meta",
          begin: /<![a-z]/,
          end: />/,
          relevance: 10,
          contains: [
            o,
            u,
            l,
            a,
            {
              begin: /\[/,
              end: /\]/,
              contains: [
                {
                  className: "meta",
                  begin: /<![a-z]/,
                  end: />/,
                  contains: [
                    o,
                    a,
                    u,
                    l
                  ]
                }
              ]
            }
          ]
        },
        e.COMMENT(
          /<!--/,
          /-->/,
          { relevance: 10 }
        ),
        {
          begin: /<!\[CDATA\[/,
          end: /\]\]>/,
          relevance: 10
        },
        s,
        // xml processing instructions
        {
          className: "meta",
          end: /\?>/,
          variants: [
            {
              begin: /<\?xml/,
              relevance: 10,
              contains: [
                u
              ]
            },
            {
              begin: /<\?[a-z][a-z0-9]+/
            }
          ]
        },
        {
          className: "tag",
          /*
          The lookahead pattern (?=...) ensures that 'begin' only matches
          '<style' as a single word, followed by a whitespace or an
          ending bracket.
          */
          begin: /<style(?=\s|>)/,
          end: />/,
          keywords: { name: "style" },
          contains: [d],
          starts: {
            end: /<\/style>/,
            returnEnd: !0,
            subLanguage: [
              "css",
              "xml"
            ]
          }
        },
        {
          className: "tag",
          // See the comment in the <style tag about the lookahead pattern
          begin: /<script(?=\s|>)/,
          end: />/,
          keywords: { name: "script" },
          contains: [d],
          starts: {
            end: /<\/script>/,
            returnEnd: !0,
            subLanguage: [
              "javascript",
              "handlebars",
              "xml"
            ]
          }
        },
        // we need this for now for jSX
        {
          className: "tag",
          begin: /<>|<\/>/
        },
        // open tag
        {
          className: "tag",
          begin: n.concat(
            /</,
            n.lookahead(n.concat(
              r,
              // <tag/>
              // <tag>
              // <tag ...
              n.either(/\/>/, />/, /\s/)
            ))
          ),
          end: /\/?>/,
          contains: [
            {
              className: "name",
              begin: r,
              relevance: 0,
              starts: d
            }
          ]
        },
        // close tag
        {
          className: "tag",
          begin: n.concat(
            /<\//,
            n.lookahead(n.concat(
              r,
              />/
            ))
          ),
          contains: [
            {
              className: "name",
              begin: r,
              relevance: 0
            },
            {
              begin: />/,
              relevance: 0,
              endsParent: !0
            }
          ]
        }
      ]
    };
  }
  return Du = t, Du;
}
var Lu, I_;
function uU() {
  if (I_) return Lu;
  I_ = 1;
  function t(e) {
    const n = e.regex, r = {}, i = {
      begin: /\$\{/,
      end: /\}/,
      contains: [
        "self",
        {
          begin: /:-/,
          contains: [r]
        }
        // default values
      ]
    };
    Object.assign(r, {
      className: "variable",
      variants: [
        { begin: n.concat(
          /\$[\w\d#@][\w\d_]*/,
          // negative look-ahead tries to avoid matching patterns that are not
          // Perl at all like $ident$, @ident@, etc.
          "(?![\\w\\d])(?![$])"
        ) },
        i
      ]
    });
    const s = {
      className: "subst",
      begin: /\$\(/,
      end: /\)/,
      contains: [e.BACKSLASH_ESCAPE]
    }, o = e.inherit(
      e.COMMENT(),
      {
        match: [
          /(^|\s)/,
          /#.*$/
        ],
        scope: {
          2: "comment"
        }
      }
    ), a = {
      begin: /<<-?\s*(?=\w+)/,
      starts: { contains: [
        e.END_SAME_AS_BEGIN({
          begin: /(\w+)/,
          end: /(\w+)/,
          className: "string"
        })
      ] }
    }, l = {
      className: "string",
      begin: /"/,
      end: /"/,
      contains: [
        e.BACKSLASH_ESCAPE,
        r,
        s
      ]
    };
    s.contains.push(l);
    const u = {
      match: /\\"/
    }, d = {
      className: "string",
      begin: /'/,
      end: /'/
    }, f = {
      match: /\\'/
    }, p = {
      begin: /\$?\(\(/,
      end: /\)\)/,
      contains: [
        {
          begin: /\d+#[0-9a-f]+/,
          className: "number"
        },
        e.NUMBER_MODE,
        r
      ]
    }, g = [
      "fish",
      "bash",
      "zsh",
      "sh",
      "csh",
      "ksh",
      "tcsh",
      "dash",
      "scsh"
    ], _ = e.SHEBANG({
      binary: `(${g.join("|")})`,
      relevance: 10
    }), b = {
      className: "function",
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: !0,
      contains: [e.inherit(e.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
      relevance: 0
    }, m = [
      "if",
      "then",
      "else",
      "elif",
      "fi",
      "time",
      "for",
      "while",
      "until",
      "in",
      "do",
      "done",
      "case",
      "esac",
      "coproc",
      "function",
      "select"
    ], v = [
      "true",
      "false"
    ], C = { match: /(\/[a-z._-]+)+/ }, x = [
      "break",
      "cd",
      "continue",
      "eval",
      "exec",
      "exit",
      "export",
      "getopts",
      "hash",
      "pwd",
      "readonly",
      "return",
      "shift",
      "test",
      "times",
      "trap",
      "umask",
      "unset"
    ], P = [
      "alias",
      "bind",
      "builtin",
      "caller",
      "command",
      "declare",
      "echo",
      "enable",
      "help",
      "let",
      "local",
      "logout",
      "mapfile",
      "printf",
      "read",
      "readarray",
      "source",
      "sudo",
      "type",
      "typeset",
      "ulimit",
      "unalias"
    ], k = [
      "autoload",
      "bg",
      "bindkey",
      "bye",
      "cap",
      "chdir",
      "clone",
      "comparguments",
      "compcall",
      "compctl",
      "compdescribe",
      "compfiles",
      "compgroups",
      "compquote",
      "comptags",
      "comptry",
      "compvalues",
      "dirs",
      "disable",
      "disown",
      "echotc",
      "echoti",
      "emulate",
      "fc",
      "fg",
      "float",
      "functions",
      "getcap",
      "getln",
      "history",
      "integer",
      "jobs",
      "kill",
      "limit",
      "log",
      "noglob",
      "popd",
      "print",
      "pushd",
      "pushln",
      "rehash",
      "sched",
      "setcap",
      "setopt",
      "stat",
      "suspend",
      "ttyctl",
      "unfunction",
      "unhash",
      "unlimit",
      "unsetopt",
      "vared",
      "wait",
      "whence",
      "where",
      "which",
      "zcompile",
      "zformat",
      "zftp",
      "zle",
      "zmodload",
      "zparseopts",
      "zprof",
      "zpty",
      "zregexparse",
      "zsocket",
      "zstyle",
      "ztcp"
    ], U = [
      "chcon",
      "chgrp",
      "chown",
      "chmod",
      "cp",
      "dd",
      "df",
      "dir",
      "dircolors",
      "ln",
      "ls",
      "mkdir",
      "mkfifo",
      "mknod",
      "mktemp",
      "mv",
      "realpath",
      "rm",
      "rmdir",
      "shred",
      "sync",
      "touch",
      "truncate",
      "vdir",
      "b2sum",
      "base32",
      "base64",
      "cat",
      "cksum",
      "comm",
      "csplit",
      "cut",
      "expand",
      "fmt",
      "fold",
      "head",
      "join",
      "md5sum",
      "nl",
      "numfmt",
      "od",
      "paste",
      "ptx",
      "pr",
      "sha1sum",
      "sha224sum",
      "sha256sum",
      "sha384sum",
      "sha512sum",
      "shuf",
      "sort",
      "split",
      "sum",
      "tac",
      "tail",
      "tr",
      "tsort",
      "unexpand",
      "uniq",
      "wc",
      "arch",
      "basename",
      "chroot",
      "date",
      "dirname",
      "du",
      "echo",
      "env",
      "expr",
      "factor",
      // "false", // keyword literal already
      "groups",
      "hostid",
      "id",
      "link",
      "logname",
      "nice",
      "nohup",
      "nproc",
      "pathchk",
      "pinky",
      "printenv",
      "printf",
      "pwd",
      "readlink",
      "runcon",
      "seq",
      "sleep",
      "stat",
      "stdbuf",
      "stty",
      "tee",
      "test",
      "timeout",
      // "true", // keyword literal already
      "tty",
      "uname",
      "unlink",
      "uptime",
      "users",
      "who",
      "whoami",
      "yes"
    ];
    return {
      name: "Bash",
      aliases: [
        "sh",
        "zsh"
      ],
      keywords: {
        $pattern: /\b[a-z][a-z0-9._-]+\b/,
        keyword: m,
        literal: v,
        built_in: [
          ...x,
          ...P,
          // Shell modifiers
          "set",
          "shopt",
          ...k,
          ...U
        ]
      },
      contains: [
        _,
        // to catch known shells and boost relevancy
        e.SHEBANG(),
        // to catch unknown shells but still highlight the shebang
        b,
        p,
        o,
        a,
        C,
        l,
        u,
        d,
        f,
        r
      ]
    };
  }
  return Lu = t, Lu;
}
var Uu, S_;
function dU() {
  if (S_) return Uu;
  S_ = 1;
  function t(e) {
    const n = e.regex, r = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), i = "decltype\\(auto\\)", s = "[a-zA-Z_]\\w*::", a = "(" + i + "|" + n.optional(s) + "[a-zA-Z_]\\w*" + n.optional("<[^<>]+>") + ")", l = {
      className: "type",
      variants: [
        { begin: "\\b[a-z\\d_]*_t\\b" },
        { match: /\batomic_[a-z]{3,6}\b/ }
      ]
    }, d = {
      className: "string",
      variants: [
        {
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e.BACKSLASH_ESCAPE]
        },
        {
          begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
          end: "'",
          illegal: "."
        },
        e.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/
        })
      ]
    }, f = {
      className: "number",
      variants: [
        { match: /\b(0b[01']+)/ },
        { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
        { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
        { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
      ],
      relevance: 0
    }, p = {
      className: "meta",
      begin: /#\s*[a-z]+\b/,
      end: /$/,
      keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
      contains: [
        {
          begin: /\\\n/,
          relevance: 0
        },
        e.inherit(d, { className: "string" }),
        {
          className: "string",
          begin: /<.*?>/
        },
        r,
        e.C_BLOCK_COMMENT_MODE
      ]
    }, g = {
      className: "title",
      begin: n.optional(s) + e.IDENT_RE,
      relevance: 0
    }, _ = n.optional(s) + e.IDENT_RE + "\\s*\\(", v = {
      keyword: [
        "asm",
        "auto",
        "break",
        "case",
        "continue",
        "default",
        "do",
        "else",
        "enum",
        "extern",
        "for",
        "fortran",
        "goto",
        "if",
        "inline",
        "register",
        "restrict",
        "return",
        "sizeof",
        "typeof",
        "typeof_unqual",
        "struct",
        "switch",
        "typedef",
        "union",
        "volatile",
        "while",
        "_Alignas",
        "_Alignof",
        "_Atomic",
        "_Generic",
        "_Noreturn",
        "_Static_assert",
        "_Thread_local",
        // aliases
        "alignas",
        "alignof",
        "noreturn",
        "static_assert",
        "thread_local",
        // not a C keyword but is, for all intents and purposes, treated exactly like one.
        "_Pragma"
      ],
      type: [
        "float",
        "double",
        "signed",
        "unsigned",
        "int",
        "short",
        "long",
        "char",
        "void",
        "_Bool",
        "_BitInt",
        "_Complex",
        "_Imaginary",
        "_Decimal32",
        "_Decimal64",
        "_Decimal96",
        "_Decimal128",
        "_Decimal64x",
        "_Decimal128x",
        "_Float16",
        "_Float32",
        "_Float64",
        "_Float128",
        "_Float32x",
        "_Float64x",
        "_Float128x",
        // modifiers
        "const",
        "static",
        "constexpr",
        // aliases
        "complex",
        "bool",
        "imaginary"
      ],
      literal: "true false NULL",
      // TODO: apply hinting work similar to what was done in cpp.js
      built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
    }, C = [
      p,
      l,
      r,
      e.C_BLOCK_COMMENT_MODE,
      f,
      d
    ], x = {
      // This mode covers expression context where we can't expect a function
      // definition and shouldn't highlight anything that looks like one:
      // `return some()`, `else if()`, `(x*sum(1, 2))`
      variants: [
        {
          begin: /=/,
          end: /;/
        },
        {
          begin: /\(/,
          end: /\)/
        },
        {
          beginKeywords: "new throw return else",
          end: /;/
        }
      ],
      keywords: v,
      contains: C.concat([
        {
          begin: /\(/,
          end: /\)/,
          keywords: v,
          contains: C.concat(["self"]),
          relevance: 0
        }
      ]),
      relevance: 0
    }, P = {
      begin: "(" + a + "[\\*&\\s]+)+" + _,
      returnBegin: !0,
      end: /[{;=]/,
      excludeEnd: !0,
      keywords: v,
      illegal: /[^\w\s\*&:<>.]/,
      contains: [
        {
          // to prevent it from being confused as the function title
          begin: i,
          keywords: v,
          relevance: 0
        },
        {
          begin: _,
          returnBegin: !0,
          contains: [e.inherit(g, { className: "title.function" })],
          relevance: 0
        },
        // allow for multiple declarations, e.g.:
        // extern void f(int), g(char);
        {
          relevance: 0,
          match: /,/
        },
        {
          className: "params",
          begin: /\(/,
          end: /\)/,
          keywords: v,
          relevance: 0,
          contains: [
            r,
            e.C_BLOCK_COMMENT_MODE,
            d,
            f,
            l,
            // Count matching parentheses.
            {
              begin: /\(/,
              end: /\)/,
              keywords: v,
              relevance: 0,
              contains: [
                "self",
                r,
                e.C_BLOCK_COMMENT_MODE,
                d,
                f,
                l
              ]
            }
          ]
        },
        l,
        r,
        e.C_BLOCK_COMMENT_MODE,
        p
      ]
    };
    return {
      name: "C",
      aliases: ["h"],
      keywords: v,
      // Until differentiations are added between `c` and `cpp`, `c` will
      // not be auto-detected to avoid auto-detect conflicts between C and C++
      disableAutodetect: !0,
      illegal: "</",
      contains: [].concat(
        x,
        P,
        C,
        [
          p,
          {
            begin: e.IDENT_RE + "::",
            keywords: v
          },
          {
            className: "class",
            beginKeywords: "enum class struct union",
            end: /[{;:<>=]/,
            contains: [
              { beginKeywords: "final class struct" },
              e.TITLE_MODE
            ]
          }
        ]
      ),
      exports: {
        preprocessor: p,
        strings: d,
        keywords: v
      }
    };
  }
  return Uu = t, Uu;
}
var Fu, A_;
function fU() {
  if (A_) return Fu;
  A_ = 1;
  function t(e) {
    const n = e.regex, r = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), i = "decltype\\(auto\\)", s = "[a-zA-Z_]\\w*::", a = "(?!struct)(" + i + "|" + n.optional(s) + "[a-zA-Z_]\\w*" + n.optional("<[^<>]+>") + ")", l = {
      className: "type",
      begin: "\\b[a-z\\d_]*_t\\b"
    }, d = {
      className: "string",
      variants: [
        {
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e.BACKSLASH_ESCAPE]
        },
        {
          begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
          end: "'",
          illegal: "."
        },
        e.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/
        })
      ]
    }, f = {
      className: "number",
      variants: [
        // Floating-point literal.
        {
          begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
        },
        // Integer literal.
        {
          begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
          // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
          // literal highlight actually makes it stand out more.
        }
      ],
      relevance: 0
    }, p = {
      className: "meta",
      begin: /#\s*[a-z]+\b/,
      end: /$/,
      keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
      contains: [
        {
          begin: /\\\n/,
          relevance: 0
        },
        e.inherit(d, { className: "string" }),
        {
          className: "string",
          begin: /<.*?>/
        },
        r,
        e.C_BLOCK_COMMENT_MODE
      ]
    }, g = {
      className: "title",
      begin: n.optional(s) + e.IDENT_RE,
      relevance: 0
    }, _ = n.optional(s) + e.IDENT_RE + "\\s*\\(", b = [
      "alignas",
      "alignof",
      "and",
      "and_eq",
      "asm",
      "atomic_cancel",
      "atomic_commit",
      "atomic_noexcept",
      "auto",
      "bitand",
      "bitor",
      "break",
      "case",
      "catch",
      "class",
      "co_await",
      "co_return",
      "co_yield",
      "compl",
      "concept",
      "const_cast|10",
      "consteval",
      "constexpr",
      "constinit",
      "continue",
      "decltype",
      "default",
      "delete",
      "do",
      "dynamic_cast|10",
      "else",
      "enum",
      "explicit",
      "export",
      "extern",
      "false",
      "final",
      "for",
      "friend",
      "goto",
      "if",
      "import",
      "inline",
      "module",
      "mutable",
      "namespace",
      "new",
      "noexcept",
      "not",
      "not_eq",
      "nullptr",
      "operator",
      "or",
      "or_eq",
      "override",
      "private",
      "protected",
      "public",
      "reflexpr",
      "register",
      "reinterpret_cast|10",
      "requires",
      "return",
      "sizeof",
      "static_assert",
      "static_cast|10",
      "struct",
      "switch",
      "synchronized",
      "template",
      "this",
      "thread_local",
      "throw",
      "transaction_safe",
      "transaction_safe_dynamic",
      "true",
      "try",
      "typedef",
      "typeid",
      "typename",
      "union",
      "using",
      "virtual",
      "volatile",
      "while",
      "xor",
      "xor_eq"
    ], m = [
      "bool",
      "char",
      "char16_t",
      "char32_t",
      "char8_t",
      "double",
      "float",
      "int",
      "long",
      "short",
      "void",
      "wchar_t",
      "unsigned",
      "signed",
      "const",
      "static"
    ], v = [
      "any",
      "auto_ptr",
      "barrier",
      "binary_semaphore",
      "bitset",
      "complex",
      "condition_variable",
      "condition_variable_any",
      "counting_semaphore",
      "deque",
      "false_type",
      "flat_map",
      "flat_set",
      "future",
      "imaginary",
      "initializer_list",
      "istringstream",
      "jthread",
      "latch",
      "lock_guard",
      "multimap",
      "multiset",
      "mutex",
      "optional",
      "ostringstream",
      "packaged_task",
      "pair",
      "promise",
      "priority_queue",
      "queue",
      "recursive_mutex",
      "recursive_timed_mutex",
      "scoped_lock",
      "set",
      "shared_future",
      "shared_lock",
      "shared_mutex",
      "shared_timed_mutex",
      "shared_ptr",
      "stack",
      "string_view",
      "stringstream",
      "timed_mutex",
      "thread",
      "true_type",
      "tuple",
      "unique_lock",
      "unique_ptr",
      "unordered_map",
      "unordered_multimap",
      "unordered_multiset",
      "unordered_set",
      "variant",
      "vector",
      "weak_ptr",
      "wstring",
      "wstring_view"
    ], C = [
      "abort",
      "abs",
      "acos",
      "apply",
      "as_const",
      "asin",
      "atan",
      "atan2",
      "calloc",
      "ceil",
      "cerr",
      "cin",
      "clog",
      "cos",
      "cosh",
      "cout",
      "declval",
      "endl",
      "exchange",
      "exit",
      "exp",
      "fabs",
      "floor",
      "fmod",
      "forward",
      "fprintf",
      "fputs",
      "free",
      "frexp",
      "fscanf",
      "future",
      "invoke",
      "isalnum",
      "isalpha",
      "iscntrl",
      "isdigit",
      "isgraph",
      "islower",
      "isprint",
      "ispunct",
      "isspace",
      "isupper",
      "isxdigit",
      "labs",
      "launder",
      "ldexp",
      "log",
      "log10",
      "make_pair",
      "make_shared",
      "make_shared_for_overwrite",
      "make_tuple",
      "make_unique",
      "malloc",
      "memchr",
      "memcmp",
      "memcpy",
      "memset",
      "modf",
      "move",
      "pow",
      "printf",
      "putchar",
      "puts",
      "realloc",
      "scanf",
      "sin",
      "sinh",
      "snprintf",
      "sprintf",
      "sqrt",
      "sscanf",
      "std",
      "stderr",
      "stdin",
      "stdout",
      "strcat",
      "strchr",
      "strcmp",
      "strcpy",
      "strcspn",
      "strlen",
      "strncat",
      "strncmp",
      "strncpy",
      "strpbrk",
      "strrchr",
      "strspn",
      "strstr",
      "swap",
      "tan",
      "tanh",
      "terminate",
      "to_underlying",
      "tolower",
      "toupper",
      "vfprintf",
      "visit",
      "vprintf",
      "vsprintf"
    ], k = {
      type: m,
      keyword: b,
      literal: [
        "NULL",
        "false",
        "nullopt",
        "nullptr",
        "true"
      ],
      built_in: ["_Pragma"],
      _type_hints: v
    }, U = {
      className: "function.dispatch",
      relevance: 0,
      keywords: {
        // Only for relevance, not highlighting.
        _hint: C
      },
      begin: n.concat(
        /\b/,
        /(?!decltype)/,
        /(?!if)/,
        /(?!for)/,
        /(?!switch)/,
        /(?!while)/,
        e.IDENT_RE,
        n.lookahead(/(<[^<>]+>|)\s*\(/)
      )
    }, I = [
      U,
      p,
      l,
      r,
      e.C_BLOCK_COMMENT_MODE,
      f,
      d
    ], E = {
      // This mode covers expression context where we can't expect a function
      // definition and shouldn't highlight anything that looks like one:
      // `return some()`, `else if()`, `(x*sum(1, 2))`
      variants: [
        {
          begin: /=/,
          end: /;/
        },
        {
          begin: /\(/,
          end: /\)/
        },
        {
          beginKeywords: "new throw return else",
          end: /;/
        }
      ],
      keywords: k,
      contains: I.concat([
        {
          begin: /\(/,
          end: /\)/,
          keywords: k,
          contains: I.concat(["self"]),
          relevance: 0
        }
      ]),
      relevance: 0
    }, T = {
      className: "function",
      begin: "(" + a + "[\\*&\\s]+)+" + _,
      returnBegin: !0,
      end: /[{;=]/,
      excludeEnd: !0,
      keywords: k,
      illegal: /[^\w\s\*&:<>.]/,
      contains: [
        {
          // to prevent it from being confused as the function title
          begin: i,
          keywords: k,
          relevance: 0
        },
        {
          begin: _,
          returnBegin: !0,
          contains: [g],
          relevance: 0
        },
        // needed because we do not have look-behind on the below rule
        // to prevent it from grabbing the final : in a :: pair
        {
          begin: /::/,
          relevance: 0
        },
        // initializers
        {
          begin: /:/,
          endsWithParent: !0,
          contains: [
            d,
            f
          ]
        },
        // allow for multiple declarations, e.g.:
        // extern void f(int), g(char);
        {
          relevance: 0,
          match: /,/
        },
        {
          className: "params",
          begin: /\(/,
          end: /\)/,
          keywords: k,
          relevance: 0,
          contains: [
            r,
            e.C_BLOCK_COMMENT_MODE,
            d,
            f,
            l,
            // Count matching parentheses.
            {
              begin: /\(/,
              end: /\)/,
              keywords: k,
              relevance: 0,
              contains: [
                "self",
                r,
                e.C_BLOCK_COMMENT_MODE,
                d,
                f,
                l
              ]
            }
          ]
        },
        l,
        r,
        e.C_BLOCK_COMMENT_MODE,
        p
      ]
    };
    return {
      name: "C++",
      aliases: [
        "cc",
        "c++",
        "h++",
        "hpp",
        "hh",
        "hxx",
        "cxx"
      ],
      keywords: k,
      illegal: "</",
      classNameAliases: { "function.dispatch": "built_in" },
      contains: [].concat(
        E,
        T,
        U,
        I,
        [
          p,
          {
            // containers: ie, `vector <int> rooms (9);`
            begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
            end: ">",
            keywords: k,
            contains: [
              "self",
              l
            ]
          },
          {
            begin: e.IDENT_RE + "::",
            keywords: k
          },
          {
            match: [
              // extra complexity to deal with `enum class` and `enum struct`
              /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
              /\s+/,
              /\w+/
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      )
    };
  }
  return Fu = t, Fu;
}
var Vu, R_;
function hU() {
  if (R_) return Vu;
  R_ = 1;
  function t(e) {
    const n = [
      "bool",
      "byte",
      "char",
      "decimal",
      "delegate",
      "double",
      "dynamic",
      "enum",
      "float",
      "int",
      "long",
      "nint",
      "nuint",
      "object",
      "sbyte",
      "short",
      "string",
      "ulong",
      "uint",
      "ushort"
    ], r = [
      "public",
      "private",
      "protected",
      "static",
      "internal",
      "protected",
      "abstract",
      "async",
      "extern",
      "override",
      "unsafe",
      "virtual",
      "new",
      "sealed",
      "partial"
    ], i = [
      "default",
      "false",
      "null",
      "true"
    ], s = [
      "abstract",
      "as",
      "base",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "do",
      "else",
      "event",
      "explicit",
      "extern",
      "finally",
      "fixed",
      "for",
      "foreach",
      "goto",
      "if",
      "implicit",
      "in",
      "interface",
      "internal",
      "is",
      "lock",
      "namespace",
      "new",
      "operator",
      "out",
      "override",
      "params",
      "private",
      "protected",
      "public",
      "readonly",
      "record",
      "ref",
      "return",
      "scoped",
      "sealed",
      "sizeof",
      "stackalloc",
      "static",
      "struct",
      "switch",
      "this",
      "throw",
      "try",
      "typeof",
      "unchecked",
      "unsafe",
      "using",
      "virtual",
      "void",
      "volatile",
      "while"
    ], o = [
      "add",
      "alias",
      "and",
      "ascending",
      "args",
      "async",
      "await",
      "by",
      "descending",
      "dynamic",
      "equals",
      "file",
      "from",
      "get",
      "global",
      "group",
      "init",
      "into",
      "join",
      "let",
      "nameof",
      "not",
      "notnull",
      "on",
      "or",
      "orderby",
      "partial",
      "record",
      "remove",
      "required",
      "scoped",
      "select",
      "set",
      "unmanaged",
      "value|0",
      "var",
      "when",
      "where",
      "with",
      "yield"
    ], a = {
      keyword: s.concat(o),
      built_in: n,
      literal: i
    }, l = e.inherit(e.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), u = {
      className: "number",
      variants: [
        { begin: "\\b(0b[01']+)" },
        { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
        { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
      ],
      relevance: 0
    }, d = {
      className: "string",
      begin: /"""("*)(?!")(.|\n)*?"""\1/,
      relevance: 1
    }, f = {
      className: "string",
      begin: '@"',
      end: '"',
      contains: [{ begin: '""' }]
    }, p = e.inherit(f, { illegal: /\n/ }), g = {
      className: "subst",
      begin: /\{/,
      end: /\}/,
      keywords: a
    }, _ = e.inherit(g, { illegal: /\n/ }), b = {
      className: "string",
      begin: /\$"/,
      end: '"',
      illegal: /\n/,
      contains: [
        { begin: /\{\{/ },
        { begin: /\}\}/ },
        e.BACKSLASH_ESCAPE,
        _
      ]
    }, m = {
      className: "string",
      begin: /\$@"/,
      end: '"',
      contains: [
        { begin: /\{\{/ },
        { begin: /\}\}/ },
        { begin: '""' },
        g
      ]
    }, v = e.inherit(m, {
      illegal: /\n/,
      contains: [
        { begin: /\{\{/ },
        { begin: /\}\}/ },
        { begin: '""' },
        _
      ]
    });
    g.contains = [
      m,
      b,
      f,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      u,
      e.C_BLOCK_COMMENT_MODE
    ], _.contains = [
      v,
      b,
      p,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      u,
      e.inherit(e.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
    ];
    const C = { variants: [
      d,
      m,
      b,
      f,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ] }, x = {
      begin: "<",
      end: ">",
      contains: [
        { beginKeywords: "in out" },
        l
      ]
    }, P = e.IDENT_RE + "(<" + e.IDENT_RE + "(\\s*,\\s*" + e.IDENT_RE + ")*>)?(\\[\\])?", k = {
      // prevents expressions like `@class` from incorrect flagging
      // `class` as a keyword
      begin: "@" + e.IDENT_RE,
      relevance: 0
    };
    return {
      name: "C#",
      aliases: [
        "cs",
        "c#"
      ],
      keywords: a,
      illegal: /::/,
      contains: [
        e.COMMENT(
          "///",
          "$",
          {
            returnBegin: !0,
            contains: [
              {
                className: "doctag",
                variants: [
                  {
                    begin: "///",
                    relevance: 0
                  },
                  { begin: "<!--|-->" },
                  {
                    begin: "</?",
                    end: ">"
                  }
                ]
              }
            ]
          }
        ),
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        {
          className: "meta",
          begin: "#",
          end: "$",
          keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
        },
        C,
        u,
        {
          beginKeywords: "class interface",
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:,]/,
          contains: [
            { beginKeywords: "where class" },
            l,
            x,
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE
          ]
        },
        {
          beginKeywords: "namespace",
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:]/,
          contains: [
            l,
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE
          ]
        },
        {
          beginKeywords: "record",
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:]/,
          contains: [
            l,
            x,
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE
          ]
        },
        {
          // [Attributes("")]
          className: "meta",
          begin: "^\\s*\\[(?=[\\w])",
          excludeBegin: !0,
          end: "\\]",
          excludeEnd: !0,
          contains: [
            {
              className: "string",
              begin: /"/,
              end: /"/
            }
          ]
        },
        {
          // Expression keywords prevent 'keyword Name(...)' from being
          // recognized as a function definition
          beginKeywords: "new return throw await else",
          relevance: 0
        },
        {
          className: "function",
          begin: "(" + P + "\\s+)+" + e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
          returnBegin: !0,
          end: /\s*[{;=]/,
          excludeEnd: !0,
          keywords: a,
          contains: [
            // prevents these from being highlighted `title`
            {
              beginKeywords: r.join(" "),
              relevance: 0
            },
            {
              begin: e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
              returnBegin: !0,
              contains: [
                e.TITLE_MODE,
                x
              ],
              relevance: 0
            },
            { match: /\(\)/ },
            {
              className: "params",
              begin: /\(/,
              end: /\)/,
              excludeBegin: !0,
              excludeEnd: !0,
              keywords: a,
              relevance: 0,
              contains: [
                C,
                u,
                e.C_BLOCK_COMMENT_MODE
              ]
            },
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE
          ]
        },
        k
      ]
    };
  }
  return Vu = t, Vu;
}
var Bu, C_;
function pU() {
  if (C_) return Bu;
  C_ = 1;
  const t = (u) => ({
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: u.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        u.APOS_STRING_MODE,
        u.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: u.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z_][A-Za-z0-9_-]*/
    }
  }), e = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "audio",
    "b",
    "blockquote",
    "body",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "dd",
    "del",
    "details",
    "dfn",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "mark",
    "menu",
    "nav",
    "object",
    "ol",
    "optgroup",
    "option",
    "p",
    "picture",
    "q",
    "quote",
    "samp",
    "section",
    "select",
    "source",
    "span",
    "strong",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "ul",
    "var",
    "video"
  ], n = [
    "defs",
    "g",
    "marker",
    "mask",
    "pattern",
    "svg",
    "switch",
    "symbol",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feFlood",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMorphology",
    "feOffset",
    "feSpecularLighting",
    "feTile",
    "feTurbulence",
    "linearGradient",
    "radialGradient",
    "stop",
    "circle",
    "ellipse",
    "image",
    "line",
    "path",
    "polygon",
    "polyline",
    "rect",
    "text",
    "use",
    "textPath",
    "tspan",
    "foreignObject",
    "clipPath"
  ], r = [
    ...e,
    ...n
  ], i = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    // TODO: find a better solution?
    "min-width",
    "max-width",
    "min-height",
    "max-height"
  ].sort().reverse(), s = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    // dir()
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    // has()
    "host",
    // host or host()
    "host-context",
    // host-context()
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    // is()
    "lang",
    // lang()
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    // not()
    "nth-child",
    // nth-child()
    "nth-col",
    // nth-col()
    "nth-last-child",
    // nth-last-child()
    "nth-last-col",
    // nth-last-col()
    "nth-last-of-type",
    //nth-last-of-type()
    "nth-of-type",
    //nth-of-type()
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where"
    // where()
  ].sort().reverse(), o = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error"
  ].sort().reverse(), a = [
    "accent-color",
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "all",
    "anchor-name",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-range",
    "animation-range-end",
    "animation-range-start",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "aspect-ratio",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "block-size",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-align",
    "box-decoration-break",
    "box-direction",
    "box-flex",
    "box-flex-group",
    "box-lines",
    "box-ordinal-group",
    "box-orient",
    "box-pack",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret-color",
    "clear",
    "clip",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "color-scheme",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "content-visibility",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "cx",
    "cy",
    "direction",
    "display",
    "dominant-baseline",
    "empty-cells",
    "enable-background",
    "field-sizing",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "flood-color",
    "flood-opacity",
    "flow",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-smooth",
    "font-smoothing",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-position",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "forced-color-adjust",
    "gap",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "ime-mode",
    "initial-letter",
    "initial-letter-align",
    "inline-size",
    "inset",
    "inset-area",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "kerning",
    "left",
    "letter-spacing",
    "lighting-color",
    "line-break",
    "line-height",
    "line-height-step",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "margin-trim",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-start",
    "marks",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "masonry-auto-flow",
    "math-depth",
    "math-shift",
    "math-style",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "none",
    "normal",
    "object-fit",
    "object-position",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overlay",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "paint-order",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "place-content",
    "place-items",
    "place-self",
    "pointer-events",
    "position",
    "position-anchor",
    "position-visibility",
    "print-color-adjust",
    "quotes",
    "r",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "rotate",
    "row-gap",
    "ruby-align",
    "ruby-position",
    "scale",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scroll-timeline",
    "scroll-timeline-axis",
    "scroll-timeline-name",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "shape-rendering",
    "speak",
    "speak-as",
    "src",
    // @font-face
    "stop-color",
    "stop-opacity",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text-wrap",
    "text-wrap-mode",
    "text-wrap-style",
    "timeline-scope",
    "top",
    "touch-action",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-behavior",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "translate",
    "unicode-bidi",
    "user-modify",
    "user-select",
    "vector-effect",
    "vertical-align",
    "view-timeline",
    "view-timeline-axis",
    "view-timeline-inset",
    "view-timeline-name",
    "view-transition-name",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "white-space-collapse",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode",
    "x",
    "y",
    "z-index",
    "zoom"
  ].sort().reverse();
  function l(u) {
    const d = u.regex, f = t(u), p = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, g = "and or not only", _ = /@-?\w[\w]*(-\w+)*/, b = "[a-zA-Z-][a-zA-Z0-9_-]*", m = [
      u.APOS_STRING_MODE,
      u.QUOTE_STRING_MODE
    ];
    return {
      name: "CSS",
      case_insensitive: !0,
      illegal: /[=|'\$]/,
      keywords: { keyframePosition: "from to" },
      classNameAliases: {
        // for visual continuity with `tag {}` and because we
        // don't have a great class for this?
        keyframePosition: "selector-tag"
      },
      contains: [
        f.BLOCK_COMMENT,
        p,
        // to recognize keyframe 40% etc which are outside the scope of our
        // attribute value mode
        f.CSS_NUMBER_MODE,
        {
          className: "selector-id",
          begin: /#[A-Za-z0-9_-]+/,
          relevance: 0
        },
        {
          className: "selector-class",
          begin: "\\." + b,
          relevance: 0
        },
        f.ATTRIBUTE_SELECTOR_MODE,
        {
          className: "selector-pseudo",
          variants: [
            { begin: ":(" + s.join("|") + ")" },
            { begin: ":(:)?(" + o.join("|") + ")" }
          ]
        },
        // we may actually need this (12/2020)
        // { // pseudo-selector params
        //   begin: /\(/,
        //   end: /\)/,
        //   contains: [ hljs.CSS_NUMBER_MODE ]
        // },
        f.CSS_VARIABLE,
        {
          className: "attribute",
          begin: "\\b(" + a.join("|") + ")\\b"
        },
        // attribute values
        {
          begin: /:/,
          end: /[;}{]/,
          contains: [
            f.BLOCK_COMMENT,
            f.HEXCOLOR,
            f.IMPORTANT,
            f.CSS_NUMBER_MODE,
            ...m,
            // needed to highlight these as strings and to avoid issues with
            // illegal characters that might be inside urls that would tigger the
            // languages illegal stack
            {
              begin: /(url|data-uri)\(/,
              end: /\)/,
              relevance: 0,
              // from keywords
              keywords: { built_in: "url data-uri" },
              contains: [
                ...m,
                {
                  className: "string",
                  // any character other than `)` as in `url()` will be the start
                  // of a string, which ends with `)` (from the parent mode)
                  begin: /[^)]/,
                  endsWithParent: !0,
                  excludeEnd: !0
                }
              ]
            },
            f.FUNCTION_DISPATCH
          ]
        },
        {
          begin: d.lookahead(/@/),
          end: "[{;]",
          relevance: 0,
          illegal: /:/,
          // break on Less variables @var: ...
          contains: [
            {
              className: "keyword",
              begin: _
            },
            {
              begin: /\s/,
              endsWithParent: !0,
              excludeEnd: !0,
              relevance: 0,
              keywords: {
                $pattern: /[a-z-]+/,
                keyword: g,
                attribute: i.join(" ")
              },
              contains: [
                {
                  begin: /[a-z-]+(?=:)/,
                  className: "attribute"
                },
                ...m,
                f.CSS_NUMBER_MODE
              ]
            }
          ]
        },
        {
          className: "selector-tag",
          begin: "\\b(" + r.join("|") + ")\\b"
        }
      ]
    };
  }
  return Bu = l, Bu;
}
var $u, k_;
function mU() {
  if (k_) return $u;
  k_ = 1;
  function t(e) {
    const n = e.regex, r = {
      begin: /<\/?[A-Za-z_]/,
      end: ">",
      subLanguage: "xml",
      relevance: 0
    }, i = {
      begin: "^[-\\*]{3,}",
      end: "$"
    }, s = {
      className: "code",
      variants: [
        // TODO: fix to allow these to work with sublanguage also
        { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
        { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
        // needed to allow markdown as a sublanguage to work
        {
          begin: "```",
          end: "```+[ ]*$"
        },
        {
          begin: "~~~",
          end: "~~~+[ ]*$"
        },
        { begin: "`.+?`" },
        {
          begin: "(?=^( {4}|\\t))",
          // use contains to gobble up multiple lines to allow the block to be whatever size
          // but only have a single open/close tag vs one per line
          contains: [
            {
              begin: "^( {4}|\\t)",
              end: "(\\n)$"
            }
          ],
          relevance: 0
        }
      ]
    }, o = {
      className: "bullet",
      begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
      end: "\\s+",
      excludeEnd: !0
    }, a = {
      begin: /^\[[^\n]+\]:/,
      returnBegin: !0,
      contains: [
        {
          className: "symbol",
          begin: /\[/,
          end: /\]/,
          excludeBegin: !0,
          excludeEnd: !0
        },
        {
          className: "link",
          begin: /:\s*/,
          end: /$/,
          excludeBegin: !0
        }
      ]
    }, l = /[A-Za-z][A-Za-z0-9+.-]*/, u = {
      variants: [
        // too much like nested array access in so many languages
        // to have any real relevance
        {
          begin: /\[.+?\]\[.*?\]/,
          relevance: 0
        },
        // popular internet URLs
        {
          begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
          relevance: 2
        },
        {
          begin: n.concat(/\[.+?\]\(/, l, /:\/\/.*?\)/),
          relevance: 2
        },
        // relative urls
        {
          begin: /\[.+?\]\([./?&#].*?\)/,
          relevance: 1
        },
        // whatever else, lower relevance (might not be a link at all)
        {
          begin: /\[.*?\]\(.*?\)/,
          relevance: 0
        }
      ],
      returnBegin: !0,
      contains: [
        {
          // empty strings for alt or link text
          match: /\[(?=\])/
        },
        {
          className: "string",
          relevance: 0,
          begin: "\\[",
          end: "\\]",
          excludeBegin: !0,
          returnEnd: !0
        },
        {
          className: "link",
          relevance: 0,
          begin: "\\]\\(",
          end: "\\)",
          excludeBegin: !0,
          excludeEnd: !0
        },
        {
          className: "symbol",
          relevance: 0,
          begin: "\\]\\[",
          end: "\\]",
          excludeBegin: !0,
          excludeEnd: !0
        }
      ]
    }, d = {
      className: "strong",
      contains: [],
      // defined later
      variants: [
        {
          begin: /_{2}(?!\s)/,
          end: /_{2}/
        },
        {
          begin: /\*{2}(?!\s)/,
          end: /\*{2}/
        }
      ]
    }, f = {
      className: "emphasis",
      contains: [],
      // defined later
      variants: [
        {
          begin: /\*(?![*\s])/,
          end: /\*/
        },
        {
          begin: /_(?![_\s])/,
          end: /_/,
          relevance: 0
        }
      ]
    }, p = e.inherit(d, { contains: [] }), g = e.inherit(f, { contains: [] });
    d.contains.push(g), f.contains.push(p);
    let _ = [
      r,
      u
    ];
    return [
      d,
      f,
      p,
      g
    ].forEach((C) => {
      C.contains = C.contains.concat(_);
    }), _ = _.concat(d, f), {
      name: "Markdown",
      aliases: [
        "md",
        "mkdown",
        "mkd"
      ],
      contains: [
        {
          className: "section",
          variants: [
            {
              begin: "^#{1,6}",
              end: "$",
              contains: _
            },
            {
              begin: "(?=^.+?\\n[=-]{2,}$)",
              contains: [
                { begin: "^[=-]*$" },
                {
                  begin: "^",
                  end: "\\n",
                  contains: _
                }
              ]
            }
          ]
        },
        r,
        o,
        d,
        f,
        {
          className: "quote",
          begin: "^>\\s+",
          contains: _,
          end: "$"
        },
        s,
        i,
        u,
        a,
        {
          //https://spec.commonmark.org/0.31.2/#entity-references
          scope: "literal",
          match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
        }
      ]
    };
  }
  return $u = t, $u;
}
var ju, N_;
function gU() {
  if (N_) return ju;
  N_ = 1;
  function t(e) {
    const n = e.regex;
    return {
      name: "Diff",
      aliases: ["patch"],
      contains: [
        {
          className: "meta",
          relevance: 10,
          match: n.either(
            /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
            /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
            /^--- +\d+,\d+ +----$/
          )
        },
        {
          className: "comment",
          variants: [
            {
              begin: n.either(
                /Index: /,
                /^index/,
                /={3,}/,
                /^-{3}/,
                /^\*{3} /,
                /^\+{3}/,
                /^diff --git/
              ),
              end: /$/
            },
            { match: /^\*{15}$/ }
          ]
        },
        {
          className: "addition",
          begin: /^\+/,
          end: /$/
        },
        {
          className: "deletion",
          begin: /^-/,
          end: /$/
        },
        {
          className: "addition",
          begin: /^!/,
          end: /$/
        }
      ]
    };
  }
  return ju = t, ju;
}
var qu, O_;
function yU() {
  if (O_) return qu;
  O_ = 1;
  function t(e) {
    const n = e.regex, r = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", i = n.either(
      /\b([A-Z]+[a-z0-9]+)+/,
      // ends in caps
      /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
    ), s = n.concat(i, /(::\w+)*/), a = {
      "variable.constant": [
        "__FILE__",
        "__LINE__",
        "__ENCODING__"
      ],
      "variable.language": [
        "self",
        "super"
      ],
      keyword: [
        "alias",
        "and",
        "begin",
        "BEGIN",
        "break",
        "case",
        "class",
        "defined",
        "do",
        "else",
        "elsif",
        "end",
        "END",
        "ensure",
        "for",
        "if",
        "in",
        "module",
        "next",
        "not",
        "or",
        "redo",
        "require",
        "rescue",
        "retry",
        "return",
        "then",
        "undef",
        "unless",
        "until",
        "when",
        "while",
        "yield",
        ...[
          "include",
          "extend",
          "prepend",
          "public",
          "private",
          "protected",
          "raise",
          "throw"
        ]
      ],
      built_in: [
        "proc",
        "lambda",
        "attr_accessor",
        "attr_reader",
        "attr_writer",
        "define_method",
        "private_constant",
        "module_function"
      ],
      literal: [
        "true",
        "false",
        "nil"
      ]
    }, l = {
      className: "doctag",
      begin: "@[A-Za-z]+"
    }, u = {
      begin: "#<",
      end: ">"
    }, d = [
      e.COMMENT(
        "#",
        "$",
        { contains: [l] }
      ),
      e.COMMENT(
        "^=begin",
        "^=end",
        {
          contains: [l],
          relevance: 10
        }
      ),
      e.COMMENT("^__END__", e.MATCH_NOTHING_RE)
    ], f = {
      className: "subst",
      begin: /#\{/,
      end: /\}/,
      keywords: a
    }, p = {
      className: "string",
      contains: [
        e.BACKSLASH_ESCAPE,
        f
      ],
      variants: [
        {
          begin: /'/,
          end: /'/
        },
        {
          begin: /"/,
          end: /"/
        },
        {
          begin: /`/,
          end: /`/
        },
        {
          begin: /%[qQwWx]?\(/,
          end: /\)/
        },
        {
          begin: /%[qQwWx]?\[/,
          end: /\]/
        },
        {
          begin: /%[qQwWx]?\{/,
          end: /\}/
        },
        {
          begin: /%[qQwWx]?</,
          end: />/
        },
        {
          begin: /%[qQwWx]?\//,
          end: /\//
        },
        {
          begin: /%[qQwWx]?%/,
          end: /%/
        },
        {
          begin: /%[qQwWx]?-/,
          end: /-/
        },
        {
          begin: /%[qQwWx]?\|/,
          end: /\|/
        },
        // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
        // where ? is the last character of a preceding identifier, as in: `func?4`
        { begin: /\B\?(\\\d{1,3})/ },
        { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
        { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
        { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
        { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
        { begin: /\B\?\\?\S/ },
        // heredocs
        {
          // this guard makes sure that we have an entire heredoc and not a false
          // positive (auto-detect, etc.)
          begin: n.concat(
            /<<[-~]?'?/,
            n.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
          ),
          contains: [
            e.END_SAME_AS_BEGIN({
              begin: /(\w+)/,
              end: /(\w+)/,
              contains: [
                e.BACKSLASH_ESCAPE,
                f
              ]
            })
          ]
        }
      ]
    }, g = "[1-9](_?[0-9])*|0", _ = "[0-9](_?[0-9])*", b = {
      className: "number",
      relevance: 0,
      variants: [
        // decimal integer/float, optionally exponential or rational, optionally imaginary
        { begin: `\\b(${g})(\\.(${_}))?([eE][+-]?(${_})|r)?i?\\b` },
        // explicit decimal/binary/octal/hexadecimal integer,
        // optionally rational and/or imaginary
        { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
        // 0-prefixed implicit octal integer, optionally rational and/or imaginary
        { begin: "\\b0(_?[0-7])+r?i?\\b" }
      ]
    }, m = {
      variants: [
        {
          match: /\(\)/
        },
        {
          className: "params",
          begin: /\(/,
          end: /(?=\))/,
          excludeBegin: !0,
          endsParent: !0,
          keywords: a
        }
      ]
    }, I = [
      p,
      {
        variants: [
          {
            match: [
              /class\s+/,
              s,
              /\s+<\s+/,
              s
            ]
          },
          {
            match: [
              /\b(class|module)\s+/,
              s
            ]
          }
        ],
        scope: {
          2: "title.class",
          4: "title.class.inherited"
        },
        keywords: a
      },
      {
        match: [
          /(include|extend)\s+/,
          s
        ],
        scope: {
          2: "title.class"
        },
        keywords: a
      },
      {
        relevance: 0,
        match: [
          s,
          /\.new[. (]/
        ],
        scope: {
          1: "title.class"
        }
      },
      {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      },
      {
        relevance: 0,
        match: i,
        scope: "title.class"
      },
      {
        match: [
          /def/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          m
        ]
      },
      {
        // swallow namespace qualifiers before symbols
        begin: e.IDENT_RE + "::"
      },
      {
        className: "symbol",
        begin: e.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
        relevance: 0
      },
      {
        className: "symbol",
        begin: ":(?!\\s)",
        contains: [
          p,
          { begin: r }
        ],
        relevance: 0
      },
      b,
      {
        // negative-look forward attempts to prevent false matches like:
        // @ident@ or $ident$ that might indicate this is not ruby at all
        className: "variable",
        begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
      },
      {
        className: "params",
        begin: /\|(?!=)/,
        end: /\|/,
        excludeBegin: !0,
        excludeEnd: !0,
        relevance: 0,
        // this could be a lot of things (in other languages) other than params
        keywords: a
      },
      {
        // regexp container
        begin: "(" + e.RE_STARTERS_RE + "|unless)\\s*",
        keywords: "unless",
        contains: [
          {
            className: "regexp",
            contains: [
              e.BACKSLASH_ESCAPE,
              f
            ],
            illegal: /\n/,
            variants: [
              {
                begin: "/",
                end: "/[a-z]*"
              },
              {
                begin: /%r\{/,
                end: /\}[a-z]*/
              },
              {
                begin: "%r\\(",
                end: "\\)[a-z]*"
              },
              {
                begin: "%r!",
                end: "![a-z]*"
              },
              {
                begin: "%r\\[",
                end: "\\][a-z]*"
              }
            ]
          }
        ].concat(u, d),
        relevance: 0
      }
    ].concat(u, d);
    f.contains = I, m.contains = I;
    const R = [
      {
        begin: /^\s*=>/,
        starts: {
          end: "$",
          contains: I
        }
      },
      {
        className: "meta.prompt",
        begin: "^(" + "[>?]>" + "|" + "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]" + "|" + "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>" + ")(?=[ ])",
        starts: {
          end: "$",
          keywords: a,
          contains: I
        }
      }
    ];
    return d.unshift(u), {
      name: "Ruby",
      aliases: [
        "rb",
        "gemspec",
        "podspec",
        "thor",
        "irb"
      ],
      keywords: a,
      illegal: /\/\*/,
      contains: [e.SHEBANG({ binary: "ruby" })].concat(R).concat(d).concat(I)
    };
  }
  return qu = t, qu;
}
var zu, P_;
function _U() {
  if (P_) return zu;
  P_ = 1;
  function t(e) {
    const o = {
      keyword: [
        "break",
        "case",
        "chan",
        "const",
        "continue",
        "default",
        "defer",
        "else",
        "fallthrough",
        "for",
        "func",
        "go",
        "goto",
        "if",
        "import",
        "interface",
        "map",
        "package",
        "range",
        "return",
        "select",
        "struct",
        "switch",
        "type",
        "var"
      ],
      type: [
        "bool",
        "byte",
        "complex64",
        "complex128",
        "error",
        "float32",
        "float64",
        "int8",
        "int16",
        "int32",
        "int64",
        "string",
        "uint8",
        "uint16",
        "uint32",
        "uint64",
        "int",
        "uint",
        "uintptr",
        "rune"
      ],
      literal: [
        "true",
        "false",
        "iota",
        "nil"
      ],
      built_in: [
        "append",
        "cap",
        "close",
        "complex",
        "copy",
        "imag",
        "len",
        "make",
        "new",
        "panic",
        "print",
        "println",
        "real",
        "recover",
        "delete"
      ]
    };
    return {
      name: "Go",
      aliases: ["golang"],
      keywords: o,
      illegal: "</",
      contains: [
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        {
          className: "string",
          variants: [
            e.QUOTE_STRING_MODE,
            e.APOS_STRING_MODE,
            {
              begin: "`",
              end: "`"
            }
          ]
        },
        {
          className: "number",
          variants: [
            {
              match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
              // hex without a present digit before . (making a digit afterwards required)
              relevance: 0
            },
            {
              match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
              // hex with a present digit before . (making a digit afterwards optional)
              relevance: 0
            },
            {
              match: /-?\b0[oO](_?[0-7])*i?/,
              // leading 0o octal
              relevance: 0
            },
            {
              match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
              // decimal without a present digit before . (making a digit afterwards required)
              relevance: 0
            },
            {
              match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
              // decimal with a present digit before . (making a digit afterwards optional)
              relevance: 0
            }
          ]
        },
        {
          begin: /:=/
          // relevance booster
        },
        {
          className: "function",
          beginKeywords: "func",
          end: "\\s*(\\{|$)",
          excludeEnd: !0,
          contains: [
            e.TITLE_MODE,
            {
              className: "params",
              begin: /\(/,
              end: /\)/,
              endsParent: !0,
              keywords: o,
              illegal: /["']/
            }
          ]
        }
      ]
    };
  }
  return zu = t, zu;
}
var Wu, x_;
function bU() {
  if (x_) return Wu;
  x_ = 1;
  function t(e) {
    const n = e.regex, r = /[_A-Za-z][_0-9A-Za-z]*/;
    return {
      name: "GraphQL",
      aliases: ["gql"],
      case_insensitive: !0,
      disableAutodetect: !1,
      keywords: {
        keyword: [
          "query",
          "mutation",
          "subscription",
          "type",
          "input",
          "schema",
          "directive",
          "interface",
          "union",
          "scalar",
          "fragment",
          "enum",
          "on"
        ],
        literal: [
          "true",
          "false",
          "null"
        ]
      },
      contains: [
        e.HASH_COMMENT_MODE,
        e.QUOTE_STRING_MODE,
        e.NUMBER_MODE,
        {
          scope: "punctuation",
          match: /[.]{3}/,
          relevance: 0
        },
        {
          scope: "punctuation",
          begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
          relevance: 0
        },
        {
          scope: "variable",
          begin: /\$/,
          end: /\W/,
          excludeEnd: !0,
          relevance: 0
        },
        {
          scope: "meta",
          match: /@\w+/,
          excludeEnd: !0
        },
        {
          scope: "symbol",
          begin: n.concat(r, n.lookahead(/\s*:/)),
          relevance: 0
        }
      ],
      illegal: [
        /[;<']/,
        /BEGIN/
      ]
    };
  }
  return Wu = t, Wu;
}
var Gu, M_;
function vU() {
  if (M_) return Gu;
  M_ = 1;
  function t(e) {
    const n = e.regex, r = {
      className: "number",
      relevance: 0,
      variants: [
        { begin: /([+-]+)?[\d]+_[\d_]+/ },
        { begin: e.NUMBER_RE }
      ]
    }, i = e.COMMENT();
    i.variants = [
      {
        begin: /;/,
        end: /$/
      },
      {
        begin: /#/,
        end: /$/
      }
    ];
    const s = {
      className: "variable",
      variants: [
        { begin: /\$[\w\d"][\w\d_]*/ },
        { begin: /\$\{(.*?)\}/ }
      ]
    }, o = {
      className: "literal",
      begin: /\bon|off|true|false|yes|no\b/
    }, a = {
      className: "string",
      contains: [e.BACKSLASH_ESCAPE],
      variants: [
        {
          begin: "'''",
          end: "'''",
          relevance: 10
        },
        {
          begin: '"""',
          end: '"""',
          relevance: 10
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "'",
          end: "'"
        }
      ]
    }, l = {
      begin: /\[/,
      end: /\]/,
      contains: [
        i,
        o,
        s,
        a,
        r,
        "self"
      ],
      relevance: 0
    }, u = /[A-Za-z0-9_-]+/, d = /"(\\"|[^"])*"/, f = /'[^']*'/, p = n.either(
      u,
      d,
      f
    ), g = n.concat(
      p,
      "(\\s*\\.\\s*",
      p,
      ")*",
      n.lookahead(/\s*=\s*[^#\s]/)
    );
    return {
      name: "TOML, also INI",
      aliases: ["toml"],
      case_insensitive: !0,
      illegal: /\S/,
      contains: [
        i,
        {
          className: "section",
          begin: /\[+/,
          end: /\]+/
        },
        {
          begin: g,
          className: "attr",
          starts: {
            end: /$/,
            contains: [
              i,
              l,
              o,
              s,
              a,
              r
            ]
          }
        }
      ]
    };
  }
  return Gu = t, Gu;
}
var Hu, D_;
function EU() {
  if (D_) return Hu;
  D_ = 1;
  var t = "[0-9](_*[0-9])*", e = `\\.(${t})`, n = "[0-9a-fA-F](_*[0-9a-fA-F])*", r = {
    className: "number",
    variants: [
      // DecimalFloatingPointLiteral
      // including ExponentPart
      { begin: `(\\b(${t})((${e})|\\.)?|(${e}))[eE][+-]?(${t})[fFdD]?\\b` },
      // excluding ExponentPart
      { begin: `\\b(${t})((${e})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
      { begin: `(${e})[fFdD]?\\b` },
      { begin: `\\b(${t})[fFdD]\\b` },
      // HexadecimalFloatingPointLiteral
      { begin: `\\b0[xX]((${n})\\.?|(${n})?\\.(${n}))[pP][+-]?(${t})[fFdD]?\\b` },
      // DecimalIntegerLiteral
      { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
      // HexIntegerLiteral
      { begin: `\\b0[xX](${n})[lL]?\\b` },
      // OctalIntegerLiteral
      { begin: "\\b0(_*[0-7])*[lL]?\\b" },
      // BinaryIntegerLiteral
      { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
    ],
    relevance: 0
  };
  function i(o, a, l) {
    return l === -1 ? "" : o.replace(a, (u) => i(o, a, l - 1));
  }
  function s(o) {
    const a = o.regex, l = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", u = l + i("(?:<" + l + "~~~(?:\\s*,\\s*" + l + "~~~)*>)?", /~~~/g, 2), _ = {
      keyword: [
        "synchronized",
        "abstract",
        "private",
        "var",
        "static",
        "if",
        "const ",
        "for",
        "while",
        "strictfp",
        "finally",
        "protected",
        "import",
        "native",
        "final",
        "void",
        "enum",
        "else",
        "break",
        "transient",
        "catch",
        "instanceof",
        "volatile",
        "case",
        "assert",
        "package",
        "default",
        "public",
        "try",
        "switch",
        "continue",
        "throws",
        "protected",
        "public",
        "private",
        "module",
        "requires",
        "exports",
        "do",
        "sealed",
        "yield",
        "permits",
        "goto",
        "when"
      ],
      literal: [
        "false",
        "true",
        "null"
      ],
      type: [
        "char",
        "boolean",
        "long",
        "float",
        "int",
        "byte",
        "short",
        "double"
      ],
      built_in: [
        "super",
        "this"
      ]
    }, b = {
      className: "meta",
      begin: "@" + l,
      contains: [
        {
          begin: /\(/,
          end: /\)/,
          contains: ["self"]
          // allow nested () inside our annotation
        }
      ]
    }, m = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      keywords: _,
      relevance: 0,
      contains: [o.C_BLOCK_COMMENT_MODE],
      endsParent: !0
    };
    return {
      name: "Java",
      aliases: ["jsp"],
      keywords: _,
      illegal: /<\/|#/,
      contains: [
        o.COMMENT(
          "/\\*\\*",
          "\\*/",
          {
            relevance: 0,
            contains: [
              {
                // eat up @'s in emails to prevent them to be recognized as doctags
                begin: /\w+@/,
                relevance: 0
              },
              {
                className: "doctag",
                begin: "@[A-Za-z]+"
              }
            ]
          }
        ),
        // relevance boost
        {
          begin: /import java\.[a-z]+\./,
          keywords: "import",
          relevance: 2
        },
        o.C_LINE_COMMENT_MODE,
        o.C_BLOCK_COMMENT_MODE,
        {
          begin: /"""/,
          end: /"""/,
          className: "string",
          contains: [o.BACKSLASH_ESCAPE]
        },
        o.APOS_STRING_MODE,
        o.QUOTE_STRING_MODE,
        {
          match: [
            /\b(?:class|interface|enum|extends|implements|new)/,
            /\s+/,
            l
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        },
        {
          // Exceptions for hyphenated keywords
          match: /non-sealed/,
          scope: "keyword"
        },
        {
          begin: [
            a.concat(/(?!else)/, l),
            /\s+/,
            l,
            /\s+/,
            /=(?!=)/
          ],
          className: {
            1: "type",
            3: "variable",
            5: "operator"
          }
        },
        {
          begin: [
            /record/,
            /\s+/,
            l
          ],
          className: {
            1: "keyword",
            3: "title.class"
          },
          contains: [
            m,
            o.C_LINE_COMMENT_MODE,
            o.C_BLOCK_COMMENT_MODE
          ]
        },
        {
          // Expression keywords prevent 'keyword Name(...)' from being
          // recognized as a function definition
          beginKeywords: "new throw return else",
          relevance: 0
        },
        {
          begin: [
            "(?:" + u + "\\s+)",
            o.UNDERSCORE_IDENT_RE,
            /\s*(?=\()/
          ],
          className: { 2: "title.function" },
          keywords: _,
          contains: [
            {
              className: "params",
              begin: /\(/,
              end: /\)/,
              keywords: _,
              relevance: 0,
              contains: [
                b,
                o.APOS_STRING_MODE,
                o.QUOTE_STRING_MODE,
                r,
                o.C_BLOCK_COMMENT_MODE
              ]
            },
            o.C_LINE_COMMENT_MODE,
            o.C_BLOCK_COMMENT_MODE
          ]
        },
        r,
        b
      ]
    };
  }
  return Hu = s, Hu;
}
var Ku, L_;
function wU() {
  if (L_) return Ku;
  L_ = 1;
  const t = "[A-Za-z$_][0-9A-Za-z$_]*", e = [
    "as",
    // for exports
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    // JS handles these with a special rule
    // "get",
    // "set",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends",
    // It's reached stage 3, which is "recommended for implementation":
    "using"
  ], n = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ], r = [
    // Fundamental objects
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    // numbers and dates
    "Math",
    "Date",
    "Number",
    "BigInt",
    // text
    "String",
    "RegExp",
    // Indexed collections
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    // Keyed collections
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    // Structured data
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    // Control abstraction objects
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    // Reflection
    "Reflect",
    "Proxy",
    // Internationalization
    "Intl",
    // WebAssembly
    "WebAssembly"
  ], i = [
    "Error",
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ], s = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ], o = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "sessionStorage",
    "module",
    "global"
    // Node.js
  ], a = [].concat(
    s,
    r,
    i
  );
  function l(u) {
    const d = u.regex, f = (ie, { after: le }) => {
      const Se = "</" + ie[0].slice(1);
      return ie.input.indexOf(Se, le) !== -1;
    }, p = t, g = {
      begin: "<>",
      end: "</>"
    }, _ = /<[A-Za-z0-9\\._:-]+\s*\/>/, b = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      /**
       * @param {RegExpMatchArray} match
       * @param {CallbackResponse} response
       */
      isTrulyOpeningTag: (ie, le) => {
        const Se = ie[0].length + ie.index, de = ie.input[Se];
        if (
          // HTML should not include another raw `<` inside a tag
          // nested type?
          // `<Array<Array<number>>`, etc.
          de === "<" || // the , gives away that this is not HTML
          // `<T, A extends keyof T, V>`
          de === ","
        ) {
          le.ignoreMatch();
          return;
        }
        de === ">" && (f(ie, { after: Se }) || le.ignoreMatch());
        let Le;
        const K = ie.input.substring(Se);
        if (Le = K.match(/^\s*=/)) {
          le.ignoreMatch();
          return;
        }
        if ((Le = K.match(/^\s+extends\s+/)) && Le.index === 0) {
          le.ignoreMatch();
          return;
        }
      }
    }, m = {
      $pattern: t,
      keyword: e,
      literal: n,
      built_in: a,
      "variable.language": o
    }, v = "[0-9](_?[0-9])*", C = `\\.(${v})`, x = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", P = {
      className: "number",
      variants: [
        // DecimalLiteral
        { begin: `(\\b(${x})((${C})|\\.)?|(${C}))[eE][+-]?(${v})\\b` },
        { begin: `\\b(${x})\\b((${C})\\b|\\.)?|(${C})\\b` },
        // DecimalBigIntegerLiteral
        { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
        // NonDecimalIntegerLiteral
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        // LegacyOctalIntegerLiteral (does not include underscore separators)
        // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
        { begin: "\\b0[0-7]+n?\\b" }
      ],
      relevance: 0
    }, k = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: m,
      contains: []
      // defined later
    }, U = {
      begin: ".?html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          u.BACKSLASH_ESCAPE,
          k
        ],
        subLanguage: "xml"
      }
    }, I = {
      begin: ".?css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          u.BACKSLASH_ESCAPE,
          k
        ],
        subLanguage: "css"
      }
    }, E = {
      begin: ".?gql`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          u.BACKSLASH_ESCAPE,
          k
        ],
        subLanguage: "graphql"
      }
    }, T = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        u.BACKSLASH_ESCAPE,
        k
      ]
    }, R = {
      className: "comment",
      variants: [
        u.COMMENT(
          /\/\*\*(?!\/)/,
          "\\*/",
          {
            relevance: 0,
            contains: [
              {
                begin: "(?=@[A-Za-z]+)",
                relevance: 0,
                contains: [
                  {
                    className: "doctag",
                    begin: "@[A-Za-z]+"
                  },
                  {
                    className: "type",
                    begin: "\\{",
                    end: "\\}",
                    excludeEnd: !0,
                    excludeBegin: !0,
                    relevance: 0
                  },
                  {
                    className: "variable",
                    begin: p + "(?=\\s*(-)|$)",
                    endsParent: !0,
                    relevance: 0
                  },
                  // eat spaces (not newlines) so we can find
                  // types or variables
                  {
                    begin: /(?=[^\n])\s/,
                    relevance: 0
                  }
                ]
              }
            ]
          }
        ),
        u.C_BLOCK_COMMENT_MODE,
        u.C_LINE_COMMENT_MODE
      ]
    }, M = [
      u.APOS_STRING_MODE,
      u.QUOTE_STRING_MODE,
      U,
      I,
      E,
      T,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      P
      // This is intentional:
      // See https://github.com/highlightjs/highlight.js/issues/3288
      // hljs.REGEXP_MODE
    ];
    k.contains = M.concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: m,
      contains: [
        "self"
      ].concat(M)
    });
    const S = [].concat(R, k.contains), D = S.concat([
      // eat recursive parens in sub expressions
      {
        begin: /(\s*)\(/,
        end: /\)/,
        keywords: m,
        contains: ["self"].concat(S)
      }
    ]), V = {
      className: "params",
      // convert this to negative lookbehind in v12
      begin: /(\s*)\(/,
      // to match the parms with
      end: /\)/,
      excludeBegin: !0,
      excludeEnd: !0,
      keywords: m,
      contains: D
    }, X = {
      variants: [
        // class Car extends vehicle
        {
          match: [
            /class/,
            /\s+/,
            p,
            /\s+/,
            /extends/,
            /\s+/,
            d.concat(p, "(", d.concat(/\./, p), ")*")
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            5: "keyword",
            7: "title.class.inherited"
          }
        },
        // class Car
        {
          match: [
            /class/,
            /\s+/,
            p
          ],
          scope: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    }, ge = {
      relevance: 0,
      match: d.either(
        // Hard coded exceptions
        /\bJSON/,
        // Float32Array, OutT
        /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
        // CSSFactory, CSSFactoryT
        /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
        // FPs, FPsT
        /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
        // P
        // single letters are not highlighted
        // BLAH
        // this will be flagged as a UPPER_CASE_CONSTANT instead
      ),
      className: "title.class",
      keywords: {
        _: [
          // se we still get relevance credit for JS library classes
          ...r,
          ...i
        ]
      }
    }, Te = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, Ie = {
      variants: [
        {
          match: [
            /function/,
            /\s+/,
            p,
            /(?=\s*\()/
          ]
        },
        // anonymous function
        {
          match: [
            /function/,
            /\s*(?=\()/
          ]
        }
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [V],
      illegal: /%/
    }, B = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    function q(ie) {
      return d.concat("(?!", ie.join("|"), ")");
    }
    const se = {
      match: d.concat(
        /\b/,
        q([
          ...s,
          "super",
          "import"
        ].map((ie) => `${ie}\\s*\\(`)),
        p,
        d.lookahead(/\s*\(/)
      ),
      className: "title.function",
      relevance: 0
    }, re = {
      begin: d.concat(/\./, d.lookahead(
        d.concat(p, /(?![0-9A-Za-z$_(])/)
      )),
      end: p,
      excludeBegin: !0,
      keywords: "prototype",
      className: "property",
      relevance: 0
    }, ae = {
      match: [
        /get|set/,
        /\s+/,
        p,
        /(?=\()/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        {
          // eat to avoid empty params
          begin: /\(\)/
        },
        V
      ]
    }, ce = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + u.UNDERSCORE_IDENT_RE + ")\\s*=>", pe = {
      match: [
        /const|var|let/,
        /\s+/,
        p,
        /\s*/,
        /=\s*/,
        /(async\s*)?/,
        // async is optional
        d.lookahead(ce)
      ],
      keywords: "async",
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        V
      ]
    };
    return {
      name: "JavaScript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: m,
      // this will be extended by TypeScript
      exports: { PARAMS_CONTAINS: D, CLASS_REFERENCE: ge },
      illegal: /#(?![$_A-z])/,
      contains: [
        u.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        Te,
        u.APOS_STRING_MODE,
        u.QUOTE_STRING_MODE,
        U,
        I,
        E,
        T,
        R,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        P,
        ge,
        {
          scope: "attr",
          match: p + d.lookahead(":"),
          relevance: 0
        },
        pe,
        {
          // "value" container
          begin: "(" + u.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [
            R,
            u.REGEXP_MODE,
            {
              className: "function",
              // we have to count the parens to make sure we actually have the
              // correct bounding ( ) before the =>.  There could be any number of
              // sub-expressions inside also surrounded by parens.
              begin: ce,
              returnBegin: !0,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: u.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: !0
                    },
                    {
                      begin: /(\s*)\(/,
                      end: /\)/,
                      excludeBegin: !0,
                      excludeEnd: !0,
                      keywords: m,
                      contains: D
                    }
                  ]
                }
              ]
            },
            {
              // could be a comma delimited list of params to a function call
              begin: /,/,
              relevance: 0
            },
            {
              match: /\s+/,
              relevance: 0
            },
            {
              // JSX
              variants: [
                { begin: g.begin, end: g.end },
                { match: _ },
                {
                  begin: b.begin,
                  // we carefully check the opening tag to see if it truly
                  // is a tag and not a false positive
                  "on:begin": b.isTrulyOpeningTag,
                  end: b.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: b.begin,
                  end: b.end,
                  skip: !0,
                  contains: ["self"]
                }
              ]
            }
          ]
        },
        Ie,
        {
          // prevent this from getting swallowed up by function
          // since they appear "function like"
          beginKeywords: "while if switch catch for"
        },
        {
          // we have to count the parens to make sure we actually have the correct
          // bounding ( ).  There could be any number of sub-expressions inside
          // also surrounded by parens.
          begin: "\\b(?!function)" + u.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          // end parens
          returnBegin: !0,
          label: "func.def",
          contains: [
            V,
            u.inherit(u.TITLE_MODE, { begin: p, className: "title.function" })
          ]
        },
        // catch ... so it won't trigger the property rule below
        {
          match: /\.\.\./,
          relevance: 0
        },
        re,
        // hack: prevents detection of keywords in some circumstances
        // .keyword()
        // $keyword = x
        {
          match: "\\$" + p,
          relevance: 0
        },
        {
          match: [/\bconstructor(?=\s*\()/],
          className: { 1: "title.function" },
          contains: [V]
        },
        se,
        B,
        X,
        ae,
        {
          match: /\$[(.]/
          // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
        }
      ]
    };
  }
  return Ku = l, Ku;
}
var Yu, U_;
function TU() {
  if (U_) return Yu;
  U_ = 1;
  function t(e) {
    const n = {
      className: "attr",
      begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
      relevance: 1.01
    }, r = {
      match: /[{}[\],:]/,
      className: "punctuation",
      relevance: 0
    }, i = [
      "true",
      "false",
      "null"
    ], s = {
      scope: "literal",
      beginKeywords: i.join(" ")
    };
    return {
      name: "JSON",
      aliases: ["jsonc"],
      keywords: {
        literal: i
      },
      contains: [
        n,
        r,
        e.QUOTE_STRING_MODE,
        s,
        e.C_NUMBER_MODE,
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE
      ],
      illegal: "\\S"
    };
  }
  return Yu = t, Yu;
}
var Xu, F_;
function IU() {
  if (F_) return Xu;
  F_ = 1;
  var t = "[0-9](_*[0-9])*", e = `\\.(${t})`, n = "[0-9a-fA-F](_*[0-9a-fA-F])*", r = {
    className: "number",
    variants: [
      // DecimalFloatingPointLiteral
      // including ExponentPart
      { begin: `(\\b(${t})((${e})|\\.)?|(${e}))[eE][+-]?(${t})[fFdD]?\\b` },
      // excluding ExponentPart
      { begin: `\\b(${t})((${e})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
      { begin: `(${e})[fFdD]?\\b` },
      { begin: `\\b(${t})[fFdD]\\b` },
      // HexadecimalFloatingPointLiteral
      { begin: `\\b0[xX]((${n})\\.?|(${n})?\\.(${n}))[pP][+-]?(${t})[fFdD]?\\b` },
      // DecimalIntegerLiteral
      { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
      // HexIntegerLiteral
      { begin: `\\b0[xX](${n})[lL]?\\b` },
      // OctalIntegerLiteral
      { begin: "\\b0(_*[0-7])*[lL]?\\b" },
      // BinaryIntegerLiteral
      { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
    ],
    relevance: 0
  };
  function i(s) {
    const o = {
      keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
      built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
      literal: "true false null"
    }, a = {
      className: "keyword",
      begin: /\b(break|continue|return|this)\b/,
      starts: { contains: [
        {
          className: "symbol",
          begin: /@\w+/
        }
      ] }
    }, l = {
      className: "symbol",
      begin: s.UNDERSCORE_IDENT_RE + "@"
    }, u = {
      className: "subst",
      begin: /\$\{/,
      end: /\}/,
      contains: [s.C_NUMBER_MODE]
    }, d = {
      className: "variable",
      begin: "\\$" + s.UNDERSCORE_IDENT_RE
    }, f = {
      className: "string",
      variants: [
        {
          begin: '"""',
          end: '"""(?=[^"])',
          contains: [
            d,
            u
          ]
        },
        // Can't use built-in modes easily, as we want to use STRING in the meta
        // context as 'meta-string' and there's no syntax to remove explicitly set
        // classNames in built-in modes.
        {
          begin: "'",
          end: "'",
          illegal: /\n/,
          contains: [s.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"',
          illegal: /\n/,
          contains: [
            s.BACKSLASH_ESCAPE,
            d,
            u
          ]
        }
      ]
    };
    u.contains.push(f);
    const p = {
      className: "meta",
      begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + s.UNDERSCORE_IDENT_RE + ")?"
    }, g = {
      className: "meta",
      begin: "@" + s.UNDERSCORE_IDENT_RE,
      contains: [
        {
          begin: /\(/,
          end: /\)/,
          contains: [
            s.inherit(f, { className: "string" }),
            "self"
          ]
        }
      ]
    }, _ = r, b = s.COMMENT(
      "/\\*",
      "\\*/",
      { contains: [s.C_BLOCK_COMMENT_MODE] }
    ), m = { variants: [
      {
        className: "type",
        begin: s.UNDERSCORE_IDENT_RE
      },
      {
        begin: /\(/,
        end: /\)/,
        contains: []
        // defined later
      }
    ] }, v = m;
    return v.variants[1].contains = [m], m.variants[1].contains = [v], {
      name: "Kotlin",
      aliases: [
        "kt",
        "kts"
      ],
      keywords: o,
      contains: [
        s.COMMENT(
          "/\\*\\*",
          "\\*/",
          {
            relevance: 0,
            contains: [
              {
                className: "doctag",
                begin: "@[A-Za-z]+"
              }
            ]
          }
        ),
        s.C_LINE_COMMENT_MODE,
        b,
        a,
        l,
        p,
        g,
        {
          className: "function",
          beginKeywords: "fun",
          end: "[(]|$",
          returnBegin: !0,
          excludeEnd: !0,
          keywords: o,
          relevance: 5,
          contains: [
            {
              begin: s.UNDERSCORE_IDENT_RE + "\\s*\\(",
              returnBegin: !0,
              relevance: 0,
              contains: [s.UNDERSCORE_TITLE_MODE]
            },
            {
              className: "type",
              begin: /</,
              end: />/,
              keywords: "reified",
              relevance: 0
            },
            {
              className: "params",
              begin: /\(/,
              end: /\)/,
              endsParent: !0,
              keywords: o,
              relevance: 0,
              contains: [
                {
                  begin: /:/,
                  end: /[=,\/]/,
                  endsWithParent: !0,
                  contains: [
                    m,
                    s.C_LINE_COMMENT_MODE,
                    b
                  ],
                  relevance: 0
                },
                s.C_LINE_COMMENT_MODE,
                b,
                p,
                g,
                f,
                s.C_NUMBER_MODE
              ]
            },
            b
          ]
        },
        {
          begin: [
            /class|interface|trait/,
            /\s+/,
            s.UNDERSCORE_IDENT_RE
          ],
          beginScope: {
            3: "title.class"
          },
          keywords: "class interface trait",
          end: /[:\{(]|$/,
          excludeEnd: !0,
          illegal: "extends implements",
          contains: [
            { beginKeywords: "public protected internal private constructor" },
            s.UNDERSCORE_TITLE_MODE,
            {
              className: "type",
              begin: /</,
              end: />/,
              excludeBegin: !0,
              excludeEnd: !0,
              relevance: 0
            },
            {
              className: "type",
              begin: /[,:]\s*/,
              end: /[<\(,){\s]|$/,
              excludeBegin: !0,
              returnEnd: !0
            },
            p,
            g
          ]
        },
        f,
        {
          className: "meta",
          begin: "^#!/usr/bin/env",
          end: "$",
          illegal: `
`
        },
        _
      ]
    };
  }
  return Xu = i, Xu;
}
var Qu, V_;
function SU() {
  if (V_) return Qu;
  V_ = 1;
  const t = (d) => ({
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: d.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        d.APOS_STRING_MODE,
        d.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: d.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z_][A-Za-z0-9_-]*/
    }
  }), e = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "audio",
    "b",
    "blockquote",
    "body",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "dd",
    "del",
    "details",
    "dfn",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "mark",
    "menu",
    "nav",
    "object",
    "ol",
    "optgroup",
    "option",
    "p",
    "picture",
    "q",
    "quote",
    "samp",
    "section",
    "select",
    "source",
    "span",
    "strong",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "ul",
    "var",
    "video"
  ], n = [
    "defs",
    "g",
    "marker",
    "mask",
    "pattern",
    "svg",
    "switch",
    "symbol",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feFlood",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMorphology",
    "feOffset",
    "feSpecularLighting",
    "feTile",
    "feTurbulence",
    "linearGradient",
    "radialGradient",
    "stop",
    "circle",
    "ellipse",
    "image",
    "line",
    "path",
    "polygon",
    "polyline",
    "rect",
    "text",
    "use",
    "textPath",
    "tspan",
    "foreignObject",
    "clipPath"
  ], r = [
    ...e,
    ...n
  ], i = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    // TODO: find a better solution?
    "min-width",
    "max-width",
    "min-height",
    "max-height"
  ].sort().reverse(), s = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    // dir()
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    // has()
    "host",
    // host or host()
    "host-context",
    // host-context()
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    // is()
    "lang",
    // lang()
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    // not()
    "nth-child",
    // nth-child()
    "nth-col",
    // nth-col()
    "nth-last-child",
    // nth-last-child()
    "nth-last-col",
    // nth-last-col()
    "nth-last-of-type",
    //nth-last-of-type()
    "nth-of-type",
    //nth-of-type()
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where"
    // where()
  ].sort().reverse(), o = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error"
  ].sort().reverse(), a = [
    "accent-color",
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "all",
    "anchor-name",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-range",
    "animation-range-end",
    "animation-range-start",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "aspect-ratio",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "block-size",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-align",
    "box-decoration-break",
    "box-direction",
    "box-flex",
    "box-flex-group",
    "box-lines",
    "box-ordinal-group",
    "box-orient",
    "box-pack",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret-color",
    "clear",
    "clip",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "color-scheme",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "content-visibility",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "cx",
    "cy",
    "direction",
    "display",
    "dominant-baseline",
    "empty-cells",
    "enable-background",
    "field-sizing",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "flood-color",
    "flood-opacity",
    "flow",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-smooth",
    "font-smoothing",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-position",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "forced-color-adjust",
    "gap",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "ime-mode",
    "initial-letter",
    "initial-letter-align",
    "inline-size",
    "inset",
    "inset-area",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "kerning",
    "left",
    "letter-spacing",
    "lighting-color",
    "line-break",
    "line-height",
    "line-height-step",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "margin-trim",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-start",
    "marks",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "masonry-auto-flow",
    "math-depth",
    "math-shift",
    "math-style",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "none",
    "normal",
    "object-fit",
    "object-position",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overlay",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "paint-order",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "place-content",
    "place-items",
    "place-self",
    "pointer-events",
    "position",
    "position-anchor",
    "position-visibility",
    "print-color-adjust",
    "quotes",
    "r",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "rotate",
    "row-gap",
    "ruby-align",
    "ruby-position",
    "scale",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scroll-timeline",
    "scroll-timeline-axis",
    "scroll-timeline-name",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "shape-rendering",
    "speak",
    "speak-as",
    "src",
    // @font-face
    "stop-color",
    "stop-opacity",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text-wrap",
    "text-wrap-mode",
    "text-wrap-style",
    "timeline-scope",
    "top",
    "touch-action",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-behavior",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "translate",
    "unicode-bidi",
    "user-modify",
    "user-select",
    "vector-effect",
    "vertical-align",
    "view-timeline",
    "view-timeline-axis",
    "view-timeline-inset",
    "view-timeline-name",
    "view-transition-name",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "white-space-collapse",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode",
    "x",
    "y",
    "z-index",
    "zoom"
  ].sort().reverse(), l = s.concat(o).sort().reverse();
  function u(d) {
    const f = t(d), p = l, g = "and or not only", _ = "[\\w-]+", b = "(" + _ + "|@\\{" + _ + "\\})", m = [], v = [], C = function(S) {
      return {
        // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
        className: "string",
        begin: "~?" + S + ".*?" + S
      };
    }, x = function(S, D, V) {
      return {
        className: S,
        begin: D,
        relevance: V
      };
    }, P = {
      $pattern: /[a-z-]+/,
      keyword: g,
      attribute: i.join(" ")
    }, k = {
      // used only to properly balance nested parens inside mixin call, def. arg list
      begin: "\\(",
      end: "\\)",
      contains: v,
      keywords: P,
      relevance: 0
    };
    v.push(
      d.C_LINE_COMMENT_MODE,
      d.C_BLOCK_COMMENT_MODE,
      C("'"),
      C('"'),
      f.CSS_NUMBER_MODE,
      // fixme: it does not include dot for numbers like .5em :(
      {
        begin: "(url|data-uri)\\(",
        starts: {
          className: "string",
          end: "[\\)\\n]",
          excludeEnd: !0
        }
      },
      f.HEXCOLOR,
      k,
      x("variable", "@@?" + _, 10),
      x("variable", "@\\{" + _ + "\\}"),
      x("built_in", "~?`[^`]*?`"),
      // inline javascript (or whatever host language) *multiline* string
      {
        // @media features (its here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
        className: "attribute",
        begin: _ + "\\s*:",
        end: ":",
        returnBegin: !0,
        excludeEnd: !0
      },
      f.IMPORTANT,
      { beginKeywords: "and not" },
      f.FUNCTION_DISPATCH
    );
    const U = v.concat({
      begin: /\{/,
      end: /\}/,
      contains: m
    }), I = {
      beginKeywords: "when",
      endsWithParent: !0,
      contains: [{ beginKeywords: "and not" }].concat(v)
      // using this form to override VALUEs 'function' match
    }, E = {
      begin: b + "\\s*:",
      returnBegin: !0,
      end: /[;}]/,
      relevance: 0,
      contains: [
        { begin: /-(webkit|moz|ms|o)-/ },
        f.CSS_VARIABLE,
        {
          className: "attribute",
          begin: "\\b(" + a.join("|") + ")\\b",
          end: /(?=:)/,
          starts: {
            endsWithParent: !0,
            illegal: "[<=$]",
            relevance: 0,
            contains: v
          }
        }
      ]
    }, T = {
      className: "keyword",
      begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
      starts: {
        end: "[;{}]",
        keywords: P,
        returnEnd: !0,
        contains: v,
        relevance: 0
      }
    }, A = {
      className: "variable",
      variants: [
        // using more strict pattern for higher relevance to increase chances of Less detection.
        // this is *the only* Less specific statement used in most of the sources, so...
        // (well still often loose to the css-parser unless there's '//' comment,
        // simply because 1 variable just can't beat 99 properties :)
        {
          begin: "@" + _ + "\\s*:",
          relevance: 15
        },
        { begin: "@" + _ }
      ],
      starts: {
        end: "[;}]",
        returnEnd: !0,
        contains: U
      }
    }, R = {
      // first parse unambiguous selectors (i.e. those not starting with tag)
      // then fall into the scary lookahead-discriminator variant.
      // this mode also handles mixin definitions and calls
      variants: [
        {
          begin: "[\\.#:&\\[>]",
          end: "[;{}]"
          // mixin calls end with ';'
        },
        {
          begin: b,
          end: /\{/
        }
      ],
      returnBegin: !0,
      returnEnd: !0,
      illegal: `[<='$"]`,
      relevance: 0,
      contains: [
        d.C_LINE_COMMENT_MODE,
        d.C_BLOCK_COMMENT_MODE,
        I,
        x("keyword", "all\\b"),
        x("variable", "@\\{" + _ + "\\}"),
        // otherwise its identified as tag
        {
          begin: "\\b(" + r.join("|") + ")\\b",
          className: "selector-tag"
        },
        f.CSS_NUMBER_MODE,
        x("selector-tag", b, 0),
        x("selector-id", "#" + b),
        x("selector-class", "\\." + b, 0),
        x("selector-tag", "&", 0),
        f.ATTRIBUTE_SELECTOR_MODE,
        {
          className: "selector-pseudo",
          begin: ":(" + s.join("|") + ")"
        },
        {
          className: "selector-pseudo",
          begin: ":(:)?(" + o.join("|") + ")"
        },
        {
          begin: /\(/,
          end: /\)/,
          relevance: 0,
          contains: U
        },
        // argument list of parametric mixins
        { begin: "!important" },
        // eat !important after mixin call or it will be colored as tag
        f.FUNCTION_DISPATCH
      ]
    }, M = {
      begin: _ + `:(:)?(${p.join("|")})`,
      returnBegin: !0,
      contains: [R]
    };
    return m.push(
      d.C_LINE_COMMENT_MODE,
      d.C_BLOCK_COMMENT_MODE,
      T,
      A,
      M,
      E,
      R,
      I,
      f.FUNCTION_DISPATCH
    ), {
      name: "Less",
      case_insensitive: !0,
      illegal: `[=>'/<($"]`,
      contains: m
    };
  }
  return Qu = u, Qu;
}
var Ju, B_;
function AU() {
  if (B_) return Ju;
  B_ = 1;
  function t(e) {
    const n = "\\[=*\\[", r = "\\]=*\\]", i = {
      begin: n,
      end: r,
      contains: ["self"]
    }, s = [
      e.COMMENT("--(?!" + n + ")", "$"),
      e.COMMENT(
        "--" + n,
        r,
        {
          contains: [i],
          relevance: 10
        }
      )
    ];
    return {
      name: "Lua",
      aliases: ["pluto"],
      keywords: {
        $pattern: e.UNDERSCORE_IDENT_RE,
        literal: "true false nil",
        keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
        built_in: (
          // Metatags and globals:
          "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
        )
      },
      contains: s.concat([
        {
          className: "function",
          beginKeywords: "function",
          end: "\\)",
          contains: [
            e.inherit(e.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
            {
              className: "params",
              begin: "\\(",
              endsWithParent: !0,
              contains: s
            }
          ].concat(s)
        },
        e.C_NUMBER_MODE,
        e.APOS_STRING_MODE,
        e.QUOTE_STRING_MODE,
        {
          className: "string",
          begin: n,
          end: r,
          contains: [i],
          relevance: 5
        }
      ])
    };
  }
  return Ju = t, Ju;
}
var Zu, $_;
function RU() {
  if ($_) return Zu;
  $_ = 1;
  function t(e) {
    const n = {
      className: "variable",
      variants: [
        {
          begin: "\\$\\(" + e.UNDERSCORE_IDENT_RE + "\\)",
          contains: [e.BACKSLASH_ESCAPE]
        },
        { begin: /\$[@%<?\^\+\*]/ }
      ]
    }, r = {
      className: "string",
      begin: /"/,
      end: /"/,
      contains: [
        e.BACKSLASH_ESCAPE,
        n
      ]
    }, i = {
      className: "variable",
      begin: /\$\([\w-]+\s/,
      end: /\)/,
      keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
      contains: [
        n,
        r
        // Added QUOTE_STRING as they can be a part of functions
      ]
    }, s = { begin: "^" + e.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, o = {
      className: "meta",
      begin: /^\.PHONY:/,
      end: /$/,
      keywords: {
        $pattern: /[\.\w]+/,
        keyword: ".PHONY"
      }
    }, a = {
      className: "section",
      begin: /^[^\s]+:/,
      end: /$/,
      contains: [n]
    };
    return {
      name: "Makefile",
      aliases: [
        "mk",
        "mak",
        "make"
      ],
      keywords: {
        $pattern: /[\w-]+/,
        keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
      },
      contains: [
        e.HASH_COMMENT_MODE,
        n,
        r,
        i,
        s,
        o,
        a
      ]
    };
  }
  return Zu = t, Zu;
}
var ed, j_;
function CU() {
  if (j_) return ed;
  j_ = 1;
  function t(e) {
    const n = e.regex, r = [
      "abs",
      "accept",
      "alarm",
      "and",
      "atan2",
      "bind",
      "binmode",
      "bless",
      "break",
      "caller",
      "chdir",
      "chmod",
      "chomp",
      "chop",
      "chown",
      "chr",
      "chroot",
      "class",
      "close",
      "closedir",
      "connect",
      "continue",
      "cos",
      "crypt",
      "dbmclose",
      "dbmopen",
      "defined",
      "delete",
      "die",
      "do",
      "dump",
      "each",
      "else",
      "elsif",
      "endgrent",
      "endhostent",
      "endnetent",
      "endprotoent",
      "endpwent",
      "endservent",
      "eof",
      "eval",
      "exec",
      "exists",
      "exit",
      "exp",
      "fcntl",
      "field",
      "fileno",
      "flock",
      "for",
      "foreach",
      "fork",
      "format",
      "formline",
      "getc",
      "getgrent",
      "getgrgid",
      "getgrnam",
      "gethostbyaddr",
      "gethostbyname",
      "gethostent",
      "getlogin",
      "getnetbyaddr",
      "getnetbyname",
      "getnetent",
      "getpeername",
      "getpgrp",
      "getpriority",
      "getprotobyname",
      "getprotobynumber",
      "getprotoent",
      "getpwent",
      "getpwnam",
      "getpwuid",
      "getservbyname",
      "getservbyport",
      "getservent",
      "getsockname",
      "getsockopt",
      "given",
      "glob",
      "gmtime",
      "goto",
      "grep",
      "gt",
      "hex",
      "if",
      "index",
      "int",
      "ioctl",
      "join",
      "keys",
      "kill",
      "last",
      "lc",
      "lcfirst",
      "length",
      "link",
      "listen",
      "local",
      "localtime",
      "log",
      "lstat",
      "lt",
      "ma",
      "map",
      "method",
      "mkdir",
      "msgctl",
      "msgget",
      "msgrcv",
      "msgsnd",
      "my",
      "ne",
      "next",
      "no",
      "not",
      "oct",
      "open",
      "opendir",
      "or",
      "ord",
      "our",
      "pack",
      "package",
      "pipe",
      "pop",
      "pos",
      "print",
      "printf",
      "prototype",
      "push",
      "q|0",
      "qq",
      "quotemeta",
      "qw",
      "qx",
      "rand",
      "read",
      "readdir",
      "readline",
      "readlink",
      "readpipe",
      "recv",
      "redo",
      "ref",
      "rename",
      "require",
      "reset",
      "return",
      "reverse",
      "rewinddir",
      "rindex",
      "rmdir",
      "say",
      "scalar",
      "seek",
      "seekdir",
      "select",
      "semctl",
      "semget",
      "semop",
      "send",
      "setgrent",
      "sethostent",
      "setnetent",
      "setpgrp",
      "setpriority",
      "setprotoent",
      "setpwent",
      "setservent",
      "setsockopt",
      "shift",
      "shmctl",
      "shmget",
      "shmread",
      "shmwrite",
      "shutdown",
      "sin",
      "sleep",
      "socket",
      "socketpair",
      "sort",
      "splice",
      "split",
      "sprintf",
      "sqrt",
      "srand",
      "stat",
      "state",
      "study",
      "sub",
      "substr",
      "symlink",
      "syscall",
      "sysopen",
      "sysread",
      "sysseek",
      "system",
      "syswrite",
      "tell",
      "telldir",
      "tie",
      "tied",
      "time",
      "times",
      "tr",
      "truncate",
      "uc",
      "ucfirst",
      "umask",
      "undef",
      "unless",
      "unlink",
      "unpack",
      "unshift",
      "untie",
      "until",
      "use",
      "utime",
      "values",
      "vec",
      "wait",
      "waitpid",
      "wantarray",
      "warn",
      "when",
      "while",
      "write",
      "x|0",
      "xor",
      "y|0"
    ], i = /[dualxmsipngr]{0,12}/, s = {
      $pattern: /[\w.]+/,
      keyword: r.join(" ")
    }, o = {
      className: "subst",
      begin: "[$@]\\{",
      end: "\\}",
      keywords: s
    }, a = {
      begin: /->\{/,
      end: /\}/
      // contains defined later
    }, l = {
      scope: "attr",
      match: /\s+:\s*\w+(\s*\(.*?\))?/
    }, u = {
      scope: "variable",
      variants: [
        { begin: /\$\d/ },
        {
          begin: n.concat(
            /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
            // negative look-ahead tries to avoid matching patterns that are not
            // Perl at all like $ident$, @ident@, etc.
            "(?![A-Za-z])(?![@$%])"
          )
        },
        {
          // Only $= is a special Perl variable and one can't declare @= or %=.
          begin: /[$%@](?!")[^\s\w{=]|\$=/,
          relevance: 0
        }
      ],
      contains: [l]
    }, d = {
      className: "number",
      variants: [
        // decimal numbers:
        // include the case where a number starts with a dot (eg. .9), and
        // the leading 0? avoids mixing the first and second match on 0.x cases
        { match: /0?\.[0-9][0-9_]+\b/ },
        // include the special versioned number (eg. v5.38)
        { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
        // non-decimal numbers:
        { match: /\b0[0-7][0-7_]*\b/ },
        { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
        { match: /\b0b[0-1][0-1_]*\b/ }
      ],
      relevance: 0
    }, f = [
      e.BACKSLASH_ESCAPE,
      o,
      u
    ], p = [
      /!/,
      /\//,
      /\|/,
      /\?/,
      /'/,
      /"/,
      // valid but infrequent and weird
      /#/
      // valid but infrequent and weird
    ], g = (m, v, C = "\\1") => {
      const x = C === "\\1" ? C : n.concat(C, v);
      return n.concat(
        n.concat("(?:", m, ")"),
        v,
        /(?:\\.|[^\\\/])*?/,
        x,
        /(?:\\.|[^\\\/])*?/,
        C,
        i
      );
    }, _ = (m, v, C) => n.concat(
      n.concat("(?:", m, ")"),
      v,
      /(?:\\.|[^\\\/])*?/,
      C,
      i
    ), b = [
      u,
      e.HASH_COMMENT_MODE,
      e.COMMENT(
        /^=\w/,
        /=cut/,
        { endsWithParent: !0 }
      ),
      a,
      {
        className: "string",
        contains: f,
        variants: [
          {
            begin: "q[qwxr]?\\s*\\(",
            end: "\\)",
            relevance: 5
          },
          {
            begin: "q[qwxr]?\\s*\\[",
            end: "\\]",
            relevance: 5
          },
          {
            begin: "q[qwxr]?\\s*\\{",
            end: "\\}",
            relevance: 5
          },
          {
            begin: "q[qwxr]?\\s*\\|",
            end: "\\|",
            relevance: 5
          },
          {
            begin: "q[qwxr]?\\s*<",
            end: ">",
            relevance: 5
          },
          {
            begin: "qw\\s+q",
            end: "q",
            relevance: 5
          },
          {
            begin: "'",
            end: "'",
            contains: [e.BACKSLASH_ESCAPE]
          },
          {
            begin: '"',
            end: '"'
          },
          {
            begin: "`",
            end: "`",
            contains: [e.BACKSLASH_ESCAPE]
          },
          {
            begin: /\{\w+\}/,
            relevance: 0
          },
          {
            begin: "-?\\w+\\s*=>",
            relevance: 0
          }
        ]
      },
      d,
      {
        // regexp container
        begin: "(\\/\\/|" + e.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
        keywords: "split return print reverse grep",
        relevance: 0,
        contains: [
          e.HASH_COMMENT_MODE,
          {
            className: "regexp",
            variants: [
              // allow matching common delimiters
              { begin: g("s|tr|y", n.either(...p, { capture: !0 })) },
              // and then paired delmis
              { begin: g("s|tr|y", "\\(", "\\)") },
              { begin: g("s|tr|y", "\\[", "\\]") },
              { begin: g("s|tr|y", "\\{", "\\}") }
            ],
            relevance: 2
          },
          {
            className: "regexp",
            variants: [
              {
                // could be a comment in many languages so do not count
                // as relevant
                begin: /(m|qr)\/\//,
                relevance: 0
              },
              // prefix is optional with /regex/
              { begin: _("(?:m|qr)?", /\//, /\//) },
              // allow matching common delimiters
              { begin: _("m|qr", n.either(...p, { capture: !0 }), /\1/) },
              // allow common paired delmins
              { begin: _("m|qr", /\(/, /\)/) },
              { begin: _("m|qr", /\[/, /\]/) },
              { begin: _("m|qr", /\{/, /\}/) }
            ]
          }
        ]
      },
      {
        className: "function",
        beginKeywords: "sub method",
        end: "(\\s*\\(.*?\\))?[;{]",
        excludeEnd: !0,
        relevance: 5,
        contains: [e.TITLE_MODE, l]
      },
      {
        className: "class",
        beginKeywords: "class",
        end: "[;{]",
        excludeEnd: !0,
        relevance: 5,
        contains: [e.TITLE_MODE, l, d]
      },
      {
        begin: "-\\w\\b",
        relevance: 0
      },
      {
        begin: "^__DATA__$",
        end: "^__END__$",
        subLanguage: "mojolicious",
        contains: [
          {
            begin: "^@@.*",
            end: "$",
            className: "comment"
          }
        ]
      }
    ];
    return o.contains = b, a.contains = b, {
      name: "Perl",
      aliases: [
        "pl",
        "pm"
      ],
      keywords: s,
      contains: b
    };
  }
  return ed = t, ed;
}
var td, q_;
function kU() {
  if (q_) return td;
  q_ = 1;
  function t(e) {
    const n = {
      className: "built_in",
      begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
    }, r = /[a-zA-Z@][a-zA-Z0-9_]*/, l = {
      "variable.language": [
        "this",
        "super"
      ],
      $pattern: r,
      keyword: [
        "while",
        "export",
        "sizeof",
        "typedef",
        "const",
        "struct",
        "for",
        "union",
        "volatile",
        "static",
        "mutable",
        "if",
        "do",
        "return",
        "goto",
        "enum",
        "else",
        "break",
        "extern",
        "asm",
        "case",
        "default",
        "register",
        "explicit",
        "typename",
        "switch",
        "continue",
        "inline",
        "readonly",
        "assign",
        "readwrite",
        "self",
        "@synchronized",
        "id",
        "typeof",
        "nonatomic",
        "IBOutlet",
        "IBAction",
        "strong",
        "weak",
        "copy",
        "in",
        "out",
        "inout",
        "bycopy",
        "byref",
        "oneway",
        "__strong",
        "__weak",
        "__block",
        "__autoreleasing",
        "@private",
        "@protected",
        "@public",
        "@try",
        "@property",
        "@end",
        "@throw",
        "@catch",
        "@finally",
        "@autoreleasepool",
        "@synthesize",
        "@dynamic",
        "@selector",
        "@optional",
        "@required",
        "@encode",
        "@package",
        "@import",
        "@defs",
        "@compatibility_alias",
        "__bridge",
        "__bridge_transfer",
        "__bridge_retained",
        "__bridge_retain",
        "__covariant",
        "__contravariant",
        "__kindof",
        "_Nonnull",
        "_Nullable",
        "_Null_unspecified",
        "__FUNCTION__",
        "__PRETTY_FUNCTION__",
        "__attribute__",
        "getter",
        "setter",
        "retain",
        "unsafe_unretained",
        "nonnull",
        "nullable",
        "null_unspecified",
        "null_resettable",
        "class",
        "instancetype",
        "NS_DESIGNATED_INITIALIZER",
        "NS_UNAVAILABLE",
        "NS_REQUIRES_SUPER",
        "NS_RETURNS_INNER_POINTER",
        "NS_INLINE",
        "NS_AVAILABLE",
        "NS_DEPRECATED",
        "NS_ENUM",
        "NS_OPTIONS",
        "NS_SWIFT_UNAVAILABLE",
        "NS_ASSUME_NONNULL_BEGIN",
        "NS_ASSUME_NONNULL_END",
        "NS_REFINED_FOR_SWIFT",
        "NS_SWIFT_NAME",
        "NS_SWIFT_NOTHROW",
        "NS_DURING",
        "NS_HANDLER",
        "NS_ENDHANDLER",
        "NS_VALUERETURN",
        "NS_VOIDRETURN"
      ],
      literal: [
        "false",
        "true",
        "FALSE",
        "TRUE",
        "nil",
        "YES",
        "NO",
        "NULL"
      ],
      built_in: [
        "dispatch_once_t",
        "dispatch_queue_t",
        "dispatch_sync",
        "dispatch_async",
        "dispatch_once"
      ],
      type: [
        "int",
        "float",
        "char",
        "unsigned",
        "signed",
        "short",
        "long",
        "double",
        "wchar_t",
        "unichar",
        "void",
        "bool",
        "BOOL",
        "id|0",
        "_Bool"
      ]
    }, u = {
      $pattern: r,
      keyword: [
        "@interface",
        "@class",
        "@protocol",
        "@implementation"
      ]
    };
    return {
      name: "Objective-C",
      aliases: [
        "mm",
        "objc",
        "obj-c",
        "obj-c++",
        "objective-c++"
      ],
      keywords: l,
      illegal: "</",
      contains: [
        n,
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        e.C_NUMBER_MODE,
        e.QUOTE_STRING_MODE,
        e.APOS_STRING_MODE,
        {
          className: "string",
          variants: [
            {
              begin: '@"',
              end: '"',
              illegal: "\\n",
              contains: [e.BACKSLASH_ESCAPE]
            }
          ]
        },
        {
          className: "meta",
          begin: /#\s*[a-z]+\b/,
          end: /$/,
          keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
          contains: [
            {
              begin: /\\\n/,
              relevance: 0
            },
            e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
            {
              className: "string",
              begin: /<.*?>/,
              end: /$/,
              illegal: "\\n"
            },
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE
          ]
        },
        {
          className: "class",
          begin: "(" + u.keyword.join("|") + ")\\b",
          end: /(\{|$)/,
          excludeEnd: !0,
          keywords: u,
          contains: [e.UNDERSCORE_TITLE_MODE]
        },
        {
          begin: "\\." + e.UNDERSCORE_IDENT_RE,
          relevance: 0
        }
      ]
    };
  }
  return td = t, td;
}
var nd, z_;
function NU() {
  if (z_) return nd;
  z_ = 1;
  function t(e) {
    const n = e.regex, r = /(?![A-Za-z0-9])(?![$])/, i = n.concat(
      /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
      r
    ), s = n.concat(
      /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
      r
    ), o = n.concat(
      /[A-Z]+/,
      r
    ), a = {
      scope: "variable",
      match: "\\$+" + i
    }, l = {
      scope: "meta",
      variants: [
        { begin: /<\?php/, relevance: 10 },
        // boost for obvious PHP
        { begin: /<\?=/ },
        // less relevant per PSR-1 which says not to use short-tags
        { begin: /<\?/, relevance: 0.1 },
        { begin: /\?>/ }
        // end php tag
      ]
    }, u = {
      scope: "subst",
      variants: [
        { begin: /\$\w+/ },
        {
          begin: /\{\$/,
          end: /\}/
        }
      ]
    }, d = e.inherit(e.APOS_STRING_MODE, { illegal: null }), f = e.inherit(e.QUOTE_STRING_MODE, {
      illegal: null,
      contains: e.QUOTE_STRING_MODE.contains.concat(u)
    }), p = {
      begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
      end: /[ \t]*(\w+)\b/,
      contains: e.QUOTE_STRING_MODE.contains.concat(u),
      "on:begin": (V, X) => {
        X.data._beginMatch = V[1] || V[2];
      },
      "on:end": (V, X) => {
        X.data._beginMatch !== V[1] && X.ignoreMatch();
      }
    }, g = e.END_SAME_AS_BEGIN({
      begin: /<<<[ \t]*'(\w+)'\n/,
      end: /[ \t]*(\w+)\b/
    }), _ = `[ 	
]`, b = {
      scope: "string",
      variants: [
        f,
        d,
        p,
        g
      ]
    }, m = {
      scope: "number",
      variants: [
        { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
        // Binary w/ underscore support
        { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
        // Octals w/ underscore support
        { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
        // Hex w/ underscore support
        // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
        { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
      ],
      relevance: 0
    }, v = [
      "false",
      "null",
      "true"
    ], C = [
      // Magic constants:
      // <https://www.php.net/manual/en/language.constants.predefined.php>
      "__CLASS__",
      "__DIR__",
      "__FILE__",
      "__FUNCTION__",
      "__COMPILER_HALT_OFFSET__",
      "__LINE__",
      "__METHOD__",
      "__NAMESPACE__",
      "__TRAIT__",
      // Function that look like language construct or language construct that look like function:
      // List of keywords that may not require parenthesis
      "die",
      "echo",
      "exit",
      "include",
      "include_once",
      "print",
      "require",
      "require_once",
      // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
      // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
      // Other keywords:
      // <https://www.php.net/manual/en/reserved.php>
      // <https://www.php.net/manual/en/language.types.type-juggling.php>
      "array",
      "abstract",
      "and",
      "as",
      "binary",
      "bool",
      "boolean",
      "break",
      "callable",
      "case",
      "catch",
      "class",
      "clone",
      "const",
      "continue",
      "declare",
      "default",
      "do",
      "double",
      "else",
      "elseif",
      "empty",
      "enddeclare",
      "endfor",
      "endforeach",
      "endif",
      "endswitch",
      "endwhile",
      "enum",
      "eval",
      "extends",
      "final",
      "finally",
      "float",
      "for",
      "foreach",
      "from",
      "global",
      "goto",
      "if",
      "implements",
      "instanceof",
      "insteadof",
      "int",
      "integer",
      "interface",
      "isset",
      "iterable",
      "list",
      "match|0",
      "mixed",
      "new",
      "never",
      "object",
      "or",
      "private",
      "protected",
      "public",
      "readonly",
      "real",
      "return",
      "string",
      "switch",
      "throw",
      "trait",
      "try",
      "unset",
      "use",
      "var",
      "void",
      "while",
      "xor",
      "yield"
    ], x = [
      // Standard PHP library:
      // <https://www.php.net/manual/en/book.spl.php>
      "Error|0",
      "AppendIterator",
      "ArgumentCountError",
      "ArithmeticError",
      "ArrayIterator",
      "ArrayObject",
      "AssertionError",
      "BadFunctionCallException",
      "BadMethodCallException",
      "CachingIterator",
      "CallbackFilterIterator",
      "CompileError",
      "Countable",
      "DirectoryIterator",
      "DivisionByZeroError",
      "DomainException",
      "EmptyIterator",
      "ErrorException",
      "Exception",
      "FilesystemIterator",
      "FilterIterator",
      "GlobIterator",
      "InfiniteIterator",
      "InvalidArgumentException",
      "IteratorIterator",
      "LengthException",
      "LimitIterator",
      "LogicException",
      "MultipleIterator",
      "NoRewindIterator",
      "OutOfBoundsException",
      "OutOfRangeException",
      "OuterIterator",
      "OverflowException",
      "ParentIterator",
      "ParseError",
      "RangeException",
      "RecursiveArrayIterator",
      "RecursiveCachingIterator",
      "RecursiveCallbackFilterIterator",
      "RecursiveDirectoryIterator",
      "RecursiveFilterIterator",
      "RecursiveIterator",
      "RecursiveIteratorIterator",
      "RecursiveRegexIterator",
      "RecursiveTreeIterator",
      "RegexIterator",
      "RuntimeException",
      "SeekableIterator",
      "SplDoublyLinkedList",
      "SplFileInfo",
      "SplFileObject",
      "SplFixedArray",
      "SplHeap",
      "SplMaxHeap",
      "SplMinHeap",
      "SplObjectStorage",
      "SplObserver",
      "SplPriorityQueue",
      "SplQueue",
      "SplStack",
      "SplSubject",
      "SplTempFileObject",
      "TypeError",
      "UnderflowException",
      "UnexpectedValueException",
      "UnhandledMatchError",
      // Reserved interfaces:
      // <https://www.php.net/manual/en/reserved.interfaces.php>
      "ArrayAccess",
      "BackedEnum",
      "Closure",
      "Fiber",
      "Generator",
      "Iterator",
      "IteratorAggregate",
      "Serializable",
      "Stringable",
      "Throwable",
      "Traversable",
      "UnitEnum",
      "WeakReference",
      "WeakMap",
      // Reserved classes:
      // <https://www.php.net/manual/en/reserved.classes.php>
      "Directory",
      "__PHP_Incomplete_Class",
      "parent",
      "php_user_filter",
      "self",
      "static",
      "stdClass"
    ], k = {
      keyword: C,
      literal: ((V) => {
        const X = [];
        return V.forEach((ge) => {
          X.push(ge), ge.toLowerCase() === ge ? X.push(ge.toUpperCase()) : X.push(ge.toLowerCase());
        }), X;
      })(v),
      built_in: x
    }, U = (V) => V.map((X) => X.replace(/\|\d+$/, "")), I = { variants: [
      {
        match: [
          /new/,
          n.concat(_, "+"),
          // to prevent built ins from being confused as the class constructor call
          n.concat("(?!", U(x).join("\\b|"), "\\b)"),
          s
        ],
        scope: {
          1: "keyword",
          4: "title.class"
        }
      }
    ] }, E = n.concat(i, "\\b(?!\\()"), T = { variants: [
      {
        match: [
          n.concat(
            /::/,
            n.lookahead(/(?!class\b)/)
          ),
          E
        ],
        scope: { 2: "variable.constant" }
      },
      {
        match: [
          /::/,
          /class/
        ],
        scope: { 2: "variable.language" }
      },
      {
        match: [
          s,
          n.concat(
            /::/,
            n.lookahead(/(?!class\b)/)
          ),
          E
        ],
        scope: {
          1: "title.class",
          3: "variable.constant"
        }
      },
      {
        match: [
          s,
          n.concat(
            "::",
            n.lookahead(/(?!class\b)/)
          )
        ],
        scope: { 1: "title.class" }
      },
      {
        match: [
          s,
          /::/,
          /class/
        ],
        scope: {
          1: "title.class",
          3: "variable.language"
        }
      }
    ] }, A = {
      scope: "attr",
      match: n.concat(i, n.lookahead(":"), n.lookahead(/(?!::)/))
    }, R = {
      relevance: 0,
      begin: /\(/,
      end: /\)/,
      keywords: k,
      contains: [
        A,
        a,
        T,
        e.C_BLOCK_COMMENT_MODE,
        b,
        m,
        I
      ]
    }, M = {
      relevance: 0,
      match: [
        /\b/,
        // to prevent keywords from being confused as the function title
        n.concat("(?!fn\\b|function\\b|", U(C).join("\\b|"), "|", U(x).join("\\b|"), "\\b)"),
        i,
        n.concat(_, "*"),
        n.lookahead(/(?=\()/)
      ],
      scope: { 3: "title.function.invoke" },
      contains: [R]
    };
    R.contains.push(M);
    const S = [
      A,
      T,
      e.C_BLOCK_COMMENT_MODE,
      b,
      m,
      I
    ], D = {
      begin: n.concat(
        /#\[\s*\\?/,
        n.either(
          s,
          o
        )
      ),
      beginScope: "meta",
      end: /]/,
      endScope: "meta",
      keywords: {
        literal: v,
        keyword: [
          "new",
          "array"
        ]
      },
      contains: [
        {
          begin: /\[/,
          end: /]/,
          keywords: {
            literal: v,
            keyword: [
              "new",
              "array"
            ]
          },
          contains: [
            "self",
            ...S
          ]
        },
        ...S,
        {
          scope: "meta",
          variants: [
            { match: s },
            { match: o }
          ]
        }
      ]
    };
    return {
      case_insensitive: !1,
      keywords: k,
      contains: [
        D,
        e.HASH_COMMENT_MODE,
        e.COMMENT("//", "$"),
        e.COMMENT(
          "/\\*",
          "\\*/",
          { contains: [
            {
              scope: "doctag",
              match: "@[A-Za-z]+"
            }
          ] }
        ),
        {
          match: /__halt_compiler\(\);/,
          keywords: "__halt_compiler",
          starts: {
            scope: "comment",
            end: e.MATCH_NOTHING_RE,
            contains: [
              {
                match: /\?>/,
                scope: "meta",
                endsParent: !0
              }
            ]
          }
        },
        l,
        {
          scope: "variable.language",
          match: /\$this\b/
        },
        a,
        M,
        T,
        {
          match: [
            /const/,
            /\s/,
            i
          ],
          scope: {
            1: "keyword",
            3: "variable.constant"
          }
        },
        I,
        {
          scope: "function",
          relevance: 0,
          beginKeywords: "fn function",
          end: /[;{]/,
          excludeEnd: !0,
          illegal: "[$%\\[]",
          contains: [
            { beginKeywords: "use" },
            e.UNDERSCORE_TITLE_MODE,
            {
              begin: "=>",
              // No markup, just a relevance booster
              endsParent: !0
            },
            {
              scope: "params",
              begin: "\\(",
              end: "\\)",
              excludeBegin: !0,
              excludeEnd: !0,
              keywords: k,
              contains: [
                "self",
                D,
                a,
                T,
                e.C_BLOCK_COMMENT_MODE,
                b,
                m
              ]
            }
          ]
        },
        {
          scope: "class",
          variants: [
            {
              beginKeywords: "enum",
              illegal: /[($"]/
            },
            {
              beginKeywords: "class interface trait",
              illegal: /[:($"]/
            }
          ],
          relevance: 0,
          end: /\{/,
          excludeEnd: !0,
          contains: [
            { beginKeywords: "extends implements" },
            e.UNDERSCORE_TITLE_MODE
          ]
        },
        // both use and namespace still use "old style" rules (vs multi-match)
        // because the namespace name can include `\` and we still want each
        // element to be treated as its own *individual* title
        {
          beginKeywords: "namespace",
          relevance: 0,
          end: ";",
          illegal: /[.']/,
          contains: [e.inherit(e.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
        },
        {
          beginKeywords: "use",
          relevance: 0,
          end: ";",
          contains: [
            // TODO: title.function vs title.class
            {
              match: /\b(as|const|function)\b/,
              scope: "keyword"
            },
            // TODO: could be title.class or title.function
            e.UNDERSCORE_TITLE_MODE
          ]
        },
        b,
        m
      ]
    };
  }
  return nd = t, nd;
}
var rd, W_;
function OU() {
  if (W_) return rd;
  W_ = 1;
  function t(e) {
    return {
      name: "PHP template",
      subLanguage: "xml",
      contains: [
        {
          begin: /<\?(php|=)?/,
          end: /\?>/,
          subLanguage: "php",
          contains: [
            // We don't want the php closing tag ?> to close the PHP block when
            // inside any of the following blocks:
            {
              begin: "/\\*",
              end: "\\*/",
              skip: !0
            },
            {
              begin: 'b"',
              end: '"',
              skip: !0
            },
            {
              begin: "b'",
              end: "'",
              skip: !0
            },
            e.inherit(e.APOS_STRING_MODE, {
              illegal: null,
              className: null,
              contains: null,
              skip: !0
            }),
            e.inherit(e.QUOTE_STRING_MODE, {
              illegal: null,
              className: null,
              contains: null,
              skip: !0
            })
          ]
        }
      ]
    };
  }
  return rd = t, rd;
}
var id, G_;
function PU() {
  if (G_) return id;
  G_ = 1;
  function t(e) {
    return {
      name: "Plain text",
      aliases: [
        "text",
        "txt"
      ],
      disableAutodetect: !0
    };
  }
  return id = t, id;
}
var sd, H_;
function xU() {
  if (H_) return sd;
  H_ = 1;
  function t(e) {
    const n = e.regex, r = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), i = [
      "and",
      "as",
      "assert",
      "async",
      "await",
      "break",
      "case",
      "class",
      "continue",
      "def",
      "del",
      "elif",
      "else",
      "except",
      "finally",
      "for",
      "from",
      "global",
      "if",
      "import",
      "in",
      "is",
      "lambda",
      "match",
      "nonlocal|10",
      "not",
      "or",
      "pass",
      "raise",
      "return",
      "try",
      "while",
      "with",
      "yield"
    ], l = {
      $pattern: /[A-Za-z]\w+|__\w+__/,
      keyword: i,
      built_in: [
        "__import__",
        "abs",
        "all",
        "any",
        "ascii",
        "bin",
        "bool",
        "breakpoint",
        "bytearray",
        "bytes",
        "callable",
        "chr",
        "classmethod",
        "compile",
        "complex",
        "delattr",
        "dict",
        "dir",
        "divmod",
        "enumerate",
        "eval",
        "exec",
        "filter",
        "float",
        "format",
        "frozenset",
        "getattr",
        "globals",
        "hasattr",
        "hash",
        "help",
        "hex",
        "id",
        "input",
        "int",
        "isinstance",
        "issubclass",
        "iter",
        "len",
        "list",
        "locals",
        "map",
        "max",
        "memoryview",
        "min",
        "next",
        "object",
        "oct",
        "open",
        "ord",
        "pow",
        "print",
        "property",
        "range",
        "repr",
        "reversed",
        "round",
        "set",
        "setattr",
        "slice",
        "sorted",
        "staticmethod",
        "str",
        "sum",
        "super",
        "tuple",
        "type",
        "vars",
        "zip"
      ],
      literal: [
        "__debug__",
        "Ellipsis",
        "False",
        "None",
        "NotImplemented",
        "True"
      ],
      type: [
        "Any",
        "Callable",
        "Coroutine",
        "Dict",
        "List",
        "Literal",
        "Generic",
        "Optional",
        "Sequence",
        "Set",
        "Tuple",
        "Type",
        "Union"
      ]
    }, u = {
      className: "meta",
      begin: /^(>>>|\.\.\.) /
    }, d = {
      className: "subst",
      begin: /\{/,
      end: /\}/,
      keywords: l,
      illegal: /#/
    }, f = {
      begin: /\{\{/,
      relevance: 0
    }, p = {
      className: "string",
      contains: [e.BACKSLASH_ESCAPE],
      variants: [
        {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
          end: /'''/,
          contains: [
            e.BACKSLASH_ESCAPE,
            u
          ],
          relevance: 10
        },
        {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
          end: /"""/,
          contains: [
            e.BACKSLASH_ESCAPE,
            u
          ],
          relevance: 10
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])'''/,
          end: /'''/,
          contains: [
            e.BACKSLASH_ESCAPE,
            u,
            f,
            d
          ]
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])"""/,
          end: /"""/,
          contains: [
            e.BACKSLASH_ESCAPE,
            u,
            f,
            d
          ]
        },
        {
          begin: /([uU]|[rR])'/,
          end: /'/,
          relevance: 10
        },
        {
          begin: /([uU]|[rR])"/,
          end: /"/,
          relevance: 10
        },
        {
          begin: /([bB]|[bB][rR]|[rR][bB])'/,
          end: /'/
        },
        {
          begin: /([bB]|[bB][rR]|[rR][bB])"/,
          end: /"/
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])'/,
          end: /'/,
          contains: [
            e.BACKSLASH_ESCAPE,
            f,
            d
          ]
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])"/,
          end: /"/,
          contains: [
            e.BACKSLASH_ESCAPE,
            f,
            d
          ]
        },
        e.APOS_STRING_MODE,
        e.QUOTE_STRING_MODE
      ]
    }, g = "[0-9](_?[0-9])*", _ = `(\\b(${g}))?\\.(${g})|\\b(${g})\\.`, b = `\\b|${i.join("|")}`, m = {
      className: "number",
      relevance: 0,
      variants: [
        // exponentfloat, pointfloat
        // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
        // optionally imaginary
        // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
        // Note: no leading \b because floats can start with a decimal point
        // and we don't want to mishandle e.g. `fn(.5)`,
        // no trailing \b for pointfloat because it can end with a decimal point
        // and we don't want to mishandle e.g. `0..hex()`; this should be safe
        // because both MUST contain a decimal point and so cannot be confused with
        // the interior part of an identifier
        {
          begin: `(\\b(${g})|(${_}))[eE][+-]?(${g})[jJ]?(?=${b})`
        },
        {
          begin: `(${_})[jJ]?`
        },
        // decinteger, bininteger, octinteger, hexinteger
        // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
        // optionally "long" in Python 2
        // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
        // decinteger is optionally imaginary
        // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
        {
          begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${b})`
        },
        {
          begin: `\\b0[bB](_?[01])+[lL]?(?=${b})`
        },
        {
          begin: `\\b0[oO](_?[0-7])+[lL]?(?=${b})`
        },
        {
          begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${b})`
        },
        // imagnumber (digitpart-based)
        // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
        {
          begin: `\\b(${g})[jJ](?=${b})`
        }
      ]
    }, v = {
      className: "comment",
      begin: n.lookahead(/# type:/),
      end: /$/,
      keywords: l,
      contains: [
        {
          // prevent keywords from coloring `type`
          begin: /# type:/
        },
        // comment within a datatype comment includes no keywords
        {
          begin: /#/,
          end: /\b\B/,
          endsWithParent: !0
        }
      ]
    }, C = {
      className: "params",
      variants: [
        // Exclude params in functions without params
        {
          className: "",
          begin: /\(\s*\)/,
          skip: !0
        },
        {
          begin: /\(/,
          end: /\)/,
          excludeBegin: !0,
          excludeEnd: !0,
          keywords: l,
          contains: [
            "self",
            u,
            m,
            p,
            e.HASH_COMMENT_MODE
          ]
        }
      ]
    };
    return d.contains = [
      p,
      m,
      u
    ], {
      name: "Python",
      aliases: [
        "py",
        "gyp",
        "ipython"
      ],
      unicodeRegex: !0,
      keywords: l,
      illegal: /(<\/|\?)|=>/,
      contains: [
        u,
        m,
        {
          // very common convention
          scope: "variable.language",
          match: /\bself\b/
        },
        {
          // eat "if" prior to string so that it won't accidentally be
          // labeled as an f-string
          beginKeywords: "if",
          relevance: 0
        },
        { match: /\bor\b/, scope: "keyword" },
        p,
        v,
        e.HASH_COMMENT_MODE,
        {
          match: [
            /\bdef/,
            /\s+/,
            r
          ],
          scope: {
            1: "keyword",
            3: "title.function"
          },
          contains: [C]
        },
        {
          variants: [
            {
              match: [
                /\bclass/,
                /\s+/,
                r,
                /\s*/,
                /\(\s*/,
                r,
                /\s*\)/
              ]
            },
            {
              match: [
                /\bclass/,
                /\s+/,
                r
              ]
            }
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            6: "title.class.inherited"
          }
        },
        {
          className: "meta",
          begin: /^[\t ]*@/,
          end: /(?=#)|$/,
          contains: [
            m,
            C,
            p
          ]
        }
      ]
    };
  }
  return sd = t, sd;
}
var od, K_;
function MU() {
  if (K_) return od;
  K_ = 1;
  function t(e) {
    return {
      aliases: ["pycon"],
      contains: [
        {
          className: "meta.prompt",
          starts: {
            // a space separates the REPL prefix from the actual code
            // this is purely for cleaner HTML output
            end: / |$/,
            starts: {
              end: "$",
              subLanguage: "python"
            }
          },
          variants: [
            { begin: /^>>>(?=[ ]|$)/ },
            { begin: /^\.\.\.(?=[ ]|$)/ }
          ]
        }
      ]
    };
  }
  return od = t, od;
}
var ad, Y_;
function DU() {
  if (Y_) return ad;
  Y_ = 1;
  function t(e) {
    const n = e.regex, r = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, i = n.either(
      // Special case: only hexadecimal binary powers can contain fractions
      /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
      // Hexadecimal numbers without fraction and optional binary power
      /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
      // Decimal numbers
      /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
    ), s = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, o = n.either(
      /[()]/,
      /[{}]/,
      /\[\[/,
      /[[\]]/,
      /\\/,
      /,/
    );
    return {
      name: "R",
      keywords: {
        $pattern: r,
        keyword: "function if in break next repeat else for while",
        literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
        built_in: (
          // Builtin constants
          "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
        )
      },
      contains: [
        // Roxygen comments
        e.COMMENT(
          /#'/,
          /$/,
          { contains: [
            {
              // Handle `@examples` separately to cause all subsequent code
              // until the next `@`-tag on its own line to be kept as-is,
              // preventing highlighting. This code is example R code, so nested
              // doctags shouldnt be treated as such. See
              // `test/markup/r/roxygen.txt` for an example.
              scope: "doctag",
              match: /@examples/,
              starts: {
                end: n.lookahead(n.either(
                  // end if another doc comment
                  /\n^#'\s*(?=@[a-zA-Z]+)/,
                  // or a line with no comment
                  /\n^(?!#')/
                )),
                endsParent: !0
              }
            },
            {
              // Handle `@param` to highlight the parameter name following
              // after.
              scope: "doctag",
              begin: "@param",
              end: /$/,
              contains: [
                {
                  scope: "variable",
                  variants: [
                    { match: r },
                    { match: /`(?:\\.|[^`\\])+`/ }
                  ],
                  endsParent: !0
                }
              ]
            },
            {
              scope: "doctag",
              match: /@[a-zA-Z]+/
            },
            {
              scope: "keyword",
              match: /\\[a-zA-Z]+/
            }
          ] }
        ),
        e.HASH_COMMENT_MODE,
        {
          scope: "string",
          contains: [e.BACKSLASH_ESCAPE],
          variants: [
            e.END_SAME_AS_BEGIN({
              begin: /[rR]"(-*)\(/,
              end: /\)(-*)"/
            }),
            e.END_SAME_AS_BEGIN({
              begin: /[rR]"(-*)\{/,
              end: /\}(-*)"/
            }),
            e.END_SAME_AS_BEGIN({
              begin: /[rR]"(-*)\[/,
              end: /\](-*)"/
            }),
            e.END_SAME_AS_BEGIN({
              begin: /[rR]'(-*)\(/,
              end: /\)(-*)'/
            }),
            e.END_SAME_AS_BEGIN({
              begin: /[rR]'(-*)\{/,
              end: /\}(-*)'/
            }),
            e.END_SAME_AS_BEGIN({
              begin: /[rR]'(-*)\[/,
              end: /\](-*)'/
            }),
            {
              begin: '"',
              end: '"',
              relevance: 0
            },
            {
              begin: "'",
              end: "'",
              relevance: 0
            }
          ]
        },
        // Matching numbers immediately following punctuation and operators is
        // tricky since we need to look at the character ahead of a number to
        // ensure the number is not part of an identifier, and we cannot use
        // negative look-behind assertions. So instead we explicitly handle all
        // possible combinations of (operator|punctuation), number.
        // TODO: replace with negative look-behind when available
        // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
        // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
        // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
        {
          relevance: 0,
          variants: [
            {
              scope: {
                1: "operator",
                2: "number"
              },
              match: [
                s,
                i
              ]
            },
            {
              scope: {
                1: "operator",
                2: "number"
              },
              match: [
                /%[^%]*%/,
                i
              ]
            },
            {
              scope: {
                1: "punctuation",
                2: "number"
              },
              match: [
                o,
                i
              ]
            },
            {
              scope: { 2: "number" },
              match: [
                /[^a-zA-Z0-9._]|^/,
                // not part of an identifier, or start of document
                i
              ]
            }
          ]
        },
        // Operators/punctuation when they're not directly followed by numbers
        {
          // Relevance boost for the most common assignment form.
          scope: { 3: "operator" },
          match: [
            r,
            /\s+/,
            /<-/,
            /\s+/
          ]
        },
        {
          scope: "operator",
          relevance: 0,
          variants: [
            { match: s },
            { match: /%[^%]*%/ }
          ]
        },
        {
          scope: "punctuation",
          relevance: 0,
          match: o
        },
        {
          // Escaped identifier
          begin: "`",
          end: "`",
          contains: [{ begin: /\\./ }]
        }
      ]
    };
  }
  return ad = t, ad;
}
var cd, X_;
function LU() {
  if (X_) return cd;
  X_ = 1;
  function t(e) {
    const n = e.regex, r = /(r#)?/, i = n.concat(r, e.UNDERSCORE_IDENT_RE), s = n.concat(r, e.IDENT_RE), o = {
      className: "title.function.invoke",
      relevance: 0,
      begin: n.concat(
        /\b/,
        /(?!let|for|while|if|else|match\b)/,
        s,
        n.lookahead(/\s*\(/)
      )
    }, a = "([ui](8|16|32|64|128|size)|f(32|64))?", l = [
      "abstract",
      "as",
      "async",
      "await",
      "become",
      "box",
      "break",
      "const",
      "continue",
      "crate",
      "do",
      "dyn",
      "else",
      "enum",
      "extern",
      "false",
      "final",
      "fn",
      "for",
      "if",
      "impl",
      "in",
      "let",
      "loop",
      "macro",
      "match",
      "mod",
      "move",
      "mut",
      "override",
      "priv",
      "pub",
      "ref",
      "return",
      "self",
      "Self",
      "static",
      "struct",
      "super",
      "trait",
      "true",
      "try",
      "type",
      "typeof",
      "union",
      "unsafe",
      "unsized",
      "use",
      "virtual",
      "where",
      "while",
      "yield"
    ], u = [
      "true",
      "false",
      "Some",
      "None",
      "Ok",
      "Err"
    ], d = [
      // functions
      "drop ",
      // traits
      "Copy",
      "Send",
      "Sized",
      "Sync",
      "Drop",
      "Fn",
      "FnMut",
      "FnOnce",
      "ToOwned",
      "Clone",
      "Debug",
      "PartialEq",
      "PartialOrd",
      "Eq",
      "Ord",
      "AsRef",
      "AsMut",
      "Into",
      "From",
      "Default",
      "Iterator",
      "Extend",
      "IntoIterator",
      "DoubleEndedIterator",
      "ExactSizeIterator",
      "SliceConcatExt",
      "ToString",
      // macros
      "assert!",
      "assert_eq!",
      "bitflags!",
      "bytes!",
      "cfg!",
      "col!",
      "concat!",
      "concat_idents!",
      "debug_assert!",
      "debug_assert_eq!",
      "env!",
      "eprintln!",
      "panic!",
      "file!",
      "format!",
      "format_args!",
      "include_bytes!",
      "include_str!",
      "line!",
      "local_data_key!",
      "module_path!",
      "option_env!",
      "print!",
      "println!",
      "select!",
      "stringify!",
      "try!",
      "unimplemented!",
      "unreachable!",
      "vec!",
      "write!",
      "writeln!",
      "macro_rules!",
      "assert_ne!",
      "debug_assert_ne!"
    ], f = [
      "i8",
      "i16",
      "i32",
      "i64",
      "i128",
      "isize",
      "u8",
      "u16",
      "u32",
      "u64",
      "u128",
      "usize",
      "f32",
      "f64",
      "str",
      "char",
      "bool",
      "Box",
      "Option",
      "Result",
      "String",
      "Vec"
    ];
    return {
      name: "Rust",
      aliases: ["rs"],
      keywords: {
        $pattern: e.IDENT_RE + "!?",
        type: f,
        keyword: l,
        literal: u,
        built_in: d
      },
      illegal: "</",
      contains: [
        e.C_LINE_COMMENT_MODE,
        e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
        e.inherit(e.QUOTE_STRING_MODE, {
          begin: /b?"/,
          illegal: null
        }),
        {
          className: "symbol",
          // negative lookahead to avoid matching `'`
          begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
        },
        {
          scope: "string",
          variants: [
            { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
            {
              begin: /b?'/,
              end: /'/,
              contains: [
                {
                  scope: "char.escape",
                  match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
                }
              ]
            }
          ]
        },
        {
          className: "number",
          variants: [
            { begin: "\\b0b([01_]+)" + a },
            { begin: "\\b0o([0-7_]+)" + a },
            { begin: "\\b0x([A-Fa-f0-9_]+)" + a },
            { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + a }
          ],
          relevance: 0
        },
        {
          begin: [
            /fn/,
            /\s+/,
            i
          ],
          className: {
            1: "keyword",
            3: "title.function"
          }
        },
        {
          className: "meta",
          begin: "#!?\\[",
          end: "\\]",
          contains: [
            {
              className: "string",
              begin: /"/,
              end: /"/,
              contains: [
                e.BACKSLASH_ESCAPE
              ]
            }
          ]
        },
        {
          begin: [
            /let/,
            /\s+/,
            /(?:mut\s+)?/,
            i
          ],
          className: {
            1: "keyword",
            3: "keyword",
            4: "variable"
          }
        },
        // must come before impl/for rule later
        {
          begin: [
            /for/,
            /\s+/,
            i,
            /\s+/,
            /in/
          ],
          className: {
            1: "keyword",
            3: "variable",
            5: "keyword"
          }
        },
        {
          begin: [
            /type/,
            /\s+/,
            i
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        },
        {
          begin: [
            /(?:trait|enum|struct|union|impl|for)/,
            /\s+/,
            i
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        },
        {
          begin: e.IDENT_RE + "::",
          keywords: {
            keyword: "Self",
            built_in: d,
            type: f
          }
        },
        {
          className: "punctuation",
          begin: "->"
        },
        o
      ]
    };
  }
  return cd = t, cd;
}
var ld, Q_;
function UU() {
  if (Q_) return ld;
  Q_ = 1;
  const t = (u) => ({
    IMPORTANT: {
      scope: "meta",
      begin: "!important"
    },
    BLOCK_COMMENT: u.C_BLOCK_COMMENT_MODE,
    HEXCOLOR: {
      scope: "number",
      begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
    },
    FUNCTION_DISPATCH: {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    },
    ATTRIBUTE_SELECTOR_MODE: {
      scope: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [
        u.APOS_STRING_MODE,
        u.QUOTE_STRING_MODE
      ]
    },
    CSS_NUMBER_MODE: {
      scope: "number",
      begin: u.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    },
    CSS_VARIABLE: {
      className: "attr",
      begin: /--[A-Za-z_][A-Za-z0-9_-]*/
    }
  }), e = [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "audio",
    "b",
    "blockquote",
    "body",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "dd",
    "del",
    "details",
    "dfn",
    "div",
    "dl",
    "dt",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "mark",
    "menu",
    "nav",
    "object",
    "ol",
    "optgroup",
    "option",
    "p",
    "picture",
    "q",
    "quote",
    "samp",
    "section",
    "select",
    "source",
    "span",
    "strong",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "ul",
    "var",
    "video"
  ], n = [
    "defs",
    "g",
    "marker",
    "mask",
    "pattern",
    "svg",
    "switch",
    "symbol",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feFlood",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMorphology",
    "feOffset",
    "feSpecularLighting",
    "feTile",
    "feTurbulence",
    "linearGradient",
    "radialGradient",
    "stop",
    "circle",
    "ellipse",
    "image",
    "line",
    "path",
    "polygon",
    "polyline",
    "rect",
    "text",
    "use",
    "textPath",
    "tspan",
    "foreignObject",
    "clipPath"
  ], r = [
    ...e,
    ...n
  ], i = [
    "any-hover",
    "any-pointer",
    "aspect-ratio",
    "color",
    "color-gamut",
    "color-index",
    "device-aspect-ratio",
    "device-height",
    "device-width",
    "display-mode",
    "forced-colors",
    "grid",
    "height",
    "hover",
    "inverted-colors",
    "monochrome",
    "orientation",
    "overflow-block",
    "overflow-inline",
    "pointer",
    "prefers-color-scheme",
    "prefers-contrast",
    "prefers-reduced-motion",
    "prefers-reduced-transparency",
    "resolution",
    "scan",
    "scripting",
    "update",
    "width",
    // TODO: find a better solution?
    "min-width",
    "max-width",
    "min-height",
    "max-height"
  ].sort().reverse(), s = [
    "active",
    "any-link",
    "blank",
    "checked",
    "current",
    "default",
    "defined",
    "dir",
    // dir()
    "disabled",
    "drop",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "fullscreen",
    "future",
    "focus",
    "focus-visible",
    "focus-within",
    "has",
    // has()
    "host",
    // host or host()
    "host-context",
    // host-context()
    "hover",
    "indeterminate",
    "in-range",
    "invalid",
    "is",
    // is()
    "lang",
    // lang()
    "last-child",
    "last-of-type",
    "left",
    "link",
    "local-link",
    "not",
    // not()
    "nth-child",
    // nth-child()
    "nth-col",
    // nth-col()
    "nth-last-child",
    // nth-last-child()
    "nth-last-col",
    // nth-last-col()
    "nth-last-of-type",
    //nth-last-of-type()
    "nth-of-type",
    //nth-of-type()
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "past",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "target-within",
    "user-invalid",
    "valid",
    "visited",
    "where"
    // where()
  ].sort().reverse(), o = [
    "after",
    "backdrop",
    "before",
    "cue",
    "cue-region",
    "first-letter",
    "first-line",
    "grammar-error",
    "marker",
    "part",
    "placeholder",
    "selection",
    "slotted",
    "spelling-error"
  ].sort().reverse(), a = [
    "accent-color",
    "align-content",
    "align-items",
    "align-self",
    "alignment-baseline",
    "all",
    "anchor-name",
    "animation",
    "animation-composition",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-range",
    "animation-range-end",
    "animation-range-start",
    "animation-timeline",
    "animation-timing-function",
    "appearance",
    "aspect-ratio",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "block-size",
    "border",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-end-end-radius",
    "border-end-start-radius",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-start-end-radius",
    "border-start-start-radius",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-align",
    "box-decoration-break",
    "box-direction",
    "box-flex",
    "box-flex-group",
    "box-lines",
    "box-ordinal-group",
    "box-orient",
    "box-pack",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret-color",
    "clear",
    "clip",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "color-scheme",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "contain-intrinsic-block-size",
    "contain-intrinsic-height",
    "contain-intrinsic-inline-size",
    "contain-intrinsic-size",
    "contain-intrinsic-width",
    "container",
    "container-name",
    "container-type",
    "content",
    "content-visibility",
    "counter-increment",
    "counter-reset",
    "counter-set",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "cx",
    "cy",
    "direction",
    "display",
    "dominant-baseline",
    "empty-cells",
    "enable-background",
    "field-sizing",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "flood-color",
    "flood-opacity",
    "flow",
    "font",
    "font-display",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-palette",
    "font-size",
    "font-size-adjust",
    "font-smooth",
    "font-smoothing",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-synthesis-position",
    "font-synthesis-small-caps",
    "font-synthesis-style",
    "font-synthesis-weight",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-emoji",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "forced-color-adjust",
    "gap",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphenate-character",
    "hyphenate-limit-chars",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "ime-mode",
    "initial-letter",
    "initial-letter-align",
    "inline-size",
    "inset",
    "inset-area",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "kerning",
    "left",
    "letter-spacing",
    "lighting-color",
    "line-break",
    "line-height",
    "line-height-step",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-bottom",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "margin-left",
    "margin-right",
    "margin-top",
    "margin-trim",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-start",
    "marks",
    "mask",
    "mask-border",
    "mask-border-mode",
    "mask-border-outset",
    "mask-border-repeat",
    "mask-border-slice",
    "mask-border-source",
    "mask-border-width",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "masonry-auto-flow",
    "math-depth",
    "math-shift",
    "math-style",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "mix-blend-mode",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "none",
    "normal",
    "object-fit",
    "object-position",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-anchor",
    "overflow-block",
    "overflow-clip-margin",
    "overflow-inline",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "overlay",
    "overscroll-behavior",
    "overscroll-behavior-block",
    "overscroll-behavior-inline",
    "overscroll-behavior-x",
    "overscroll-behavior-y",
    "padding",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-bottom",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "padding-left",
    "padding-right",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "paint-order",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "place-content",
    "place-items",
    "place-self",
    "pointer-events",
    "position",
    "position-anchor",
    "position-visibility",
    "print-color-adjust",
    "quotes",
    "r",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "right",
    "rotate",
    "row-gap",
    "ruby-align",
    "ruby-position",
    "scale",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-stop",
    "scroll-snap-type",
    "scroll-timeline",
    "scroll-timeline-axis",
    "scroll-timeline-name",
    "scrollbar-color",
    "scrollbar-gutter",
    "scrollbar-width",
    "shape-image-threshold",
    "shape-margin",
    "shape-outside",
    "shape-rendering",
    "speak",
    "speak-as",
    "src",
    // @font-face
    "stop-color",
    "stop-opacity",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "tab-size",
    "table-layout",
    "text-align",
    "text-align-all",
    "text-align-last",
    "text-anchor",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-decoration-thickness",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-transform",
    "text-underline-offset",
    "text-underline-position",
    "text-wrap",
    "text-wrap-mode",
    "text-wrap-style",
    "timeline-scope",
    "top",
    "touch-action",
    "transform",
    "transform-box",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-behavior",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "translate",
    "unicode-bidi",
    "user-modify",
    "user-select",
    "vector-effect",
    "vertical-align",
    "view-timeline",
    "view-timeline-axis",
    "view-timeline-inset",
    "view-timeline-name",
    "view-transition-name",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "white-space",
    "white-space-collapse",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode",
    "x",
    "y",
    "z-index",
    "zoom"
  ].sort().reverse();
  function l(u) {
    const d = t(u), f = o, p = s, g = "@[a-z-]+", _ = "and or not only", m = {
      className: "variable",
      begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
      relevance: 0
    };
    return {
      name: "SCSS",
      case_insensitive: !0,
      illegal: "[=/|']",
      contains: [
        u.C_LINE_COMMENT_MODE,
        u.C_BLOCK_COMMENT_MODE,
        // to recognize keyframe 40% etc which are outside the scope of our
        // attribute value mode
        d.CSS_NUMBER_MODE,
        {
          className: "selector-id",
          begin: "#[A-Za-z0-9_-]+",
          relevance: 0
        },
        {
          className: "selector-class",
          begin: "\\.[A-Za-z0-9_-]+",
          relevance: 0
        },
        d.ATTRIBUTE_SELECTOR_MODE,
        {
          className: "selector-tag",
          begin: "\\b(" + r.join("|") + ")\\b",
          // was there, before, but why?
          relevance: 0
        },
        {
          className: "selector-pseudo",
          begin: ":(" + p.join("|") + ")"
        },
        {
          className: "selector-pseudo",
          begin: ":(:)?(" + f.join("|") + ")"
        },
        m,
        {
          // pseudo-selector params
          begin: /\(/,
          end: /\)/,
          contains: [d.CSS_NUMBER_MODE]
        },
        d.CSS_VARIABLE,
        {
          className: "attribute",
          begin: "\\b(" + a.join("|") + ")\\b"
        },
        { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
        {
          begin: /:/,
          end: /[;}{]/,
          relevance: 0,
          contains: [
            d.BLOCK_COMMENT,
            m,
            d.HEXCOLOR,
            d.CSS_NUMBER_MODE,
            u.QUOTE_STRING_MODE,
            u.APOS_STRING_MODE,
            d.IMPORTANT,
            d.FUNCTION_DISPATCH
          ]
        },
        // matching these here allows us to treat them more like regular CSS
        // rules so everything between the {} gets regular rule highlighting,
        // which is what we want for page and font-face
        {
          begin: "@(page|font-face)",
          keywords: {
            $pattern: g,
            keyword: "@page @font-face"
          }
        },
        {
          begin: "@",
          end: "[{;]",
          returnBegin: !0,
          keywords: {
            $pattern: /[a-z-]+/,
            keyword: _,
            attribute: i.join(" ")
          },
          contains: [
            {
              begin: g,
              className: "keyword"
            },
            {
              begin: /[a-z-]+(?=:)/,
              className: "attribute"
            },
            m,
            u.QUOTE_STRING_MODE,
            u.APOS_STRING_MODE,
            d.HEXCOLOR,
            d.CSS_NUMBER_MODE
          ]
        },
        d.FUNCTION_DISPATCH
      ]
    };
  }
  return ld = l, ld;
}
var ud, J_;
function FU() {
  if (J_) return ud;
  J_ = 1;
  function t(e) {
    return {
      name: "Shell Session",
      aliases: [
        "console",
        "shellsession"
      ],
      contains: [
        {
          className: "meta.prompt",
          // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
          // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
          // echo /path/to/home > t.exe
          begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
          starts: {
            end: /[^\\](?=\s*$)/,
            subLanguage: "bash"
          }
        }
      ]
    };
  }
  return ud = t, ud;
}
var dd, Z_;
function VU() {
  if (Z_) return dd;
  Z_ = 1;
  function t(e) {
    const n = e.regex, r = e.COMMENT("--", "$"), i = {
      scope: "string",
      variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [{ match: /''/ }]
        }
      ]
    }, s = {
      begin: /"/,
      end: /"/,
      contains: [{ match: /""/ }]
    }, o = [
      "true",
      "false",
      // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
      // "null",
      "unknown"
    ], a = [
      "double precision",
      "large object",
      "with timezone",
      "without timezone"
    ], l = [
      "bigint",
      "binary",
      "blob",
      "boolean",
      "char",
      "character",
      "clob",
      "date",
      "dec",
      "decfloat",
      "decimal",
      "float",
      "int",
      "integer",
      "interval",
      "nchar",
      "nclob",
      "national",
      "numeric",
      "real",
      "row",
      "smallint",
      "time",
      "timestamp",
      "varchar",
      "varying",
      // modifier (character varying)
      "varbinary"
    ], u = [
      "add",
      "asc",
      "collation",
      "desc",
      "final",
      "first",
      "last",
      "view"
    ], d = [
      "abs",
      "acos",
      "all",
      "allocate",
      "alter",
      "and",
      "any",
      "are",
      "array",
      "array_agg",
      "array_max_cardinality",
      "as",
      "asensitive",
      "asin",
      "asymmetric",
      "at",
      "atan",
      "atomic",
      "authorization",
      "avg",
      "begin",
      "begin_frame",
      "begin_partition",
      "between",
      "bigint",
      "binary",
      "blob",
      "boolean",
      "both",
      "by",
      "call",
      "called",
      "cardinality",
      "cascaded",
      "case",
      "cast",
      "ceil",
      "ceiling",
      "char",
      "char_length",
      "character",
      "character_length",
      "check",
      "classifier",
      "clob",
      "close",
      "coalesce",
      "collate",
      "collect",
      "column",
      "commit",
      "condition",
      "connect",
      "constraint",
      "contains",
      "convert",
      "copy",
      "corr",
      "corresponding",
      "cos",
      "cosh",
      "count",
      "covar_pop",
      "covar_samp",
      "create",
      "cross",
      "cube",
      "cume_dist",
      "current",
      "current_catalog",
      "current_date",
      "current_default_transform_group",
      "current_path",
      "current_role",
      "current_row",
      "current_schema",
      "current_time",
      "current_timestamp",
      "current_path",
      "current_role",
      "current_transform_group_for_type",
      "current_user",
      "cursor",
      "cycle",
      "date",
      "day",
      "deallocate",
      "dec",
      "decimal",
      "decfloat",
      "declare",
      "default",
      "define",
      "delete",
      "dense_rank",
      "deref",
      "describe",
      "deterministic",
      "disconnect",
      "distinct",
      "double",
      "drop",
      "dynamic",
      "each",
      "element",
      "else",
      "empty",
      "end",
      "end_frame",
      "end_partition",
      "end-exec",
      "equals",
      "escape",
      "every",
      "except",
      "exec",
      "execute",
      "exists",
      "exp",
      "external",
      "extract",
      "false",
      "fetch",
      "filter",
      "first_value",
      "float",
      "floor",
      "for",
      "foreign",
      "frame_row",
      "free",
      "from",
      "full",
      "function",
      "fusion",
      "get",
      "global",
      "grant",
      "group",
      "grouping",
      "groups",
      "having",
      "hold",
      "hour",
      "identity",
      "in",
      "indicator",
      "initial",
      "inner",
      "inout",
      "insensitive",
      "insert",
      "int",
      "integer",
      "intersect",
      "intersection",
      "interval",
      "into",
      "is",
      "join",
      "json_array",
      "json_arrayagg",
      "json_exists",
      "json_object",
      "json_objectagg",
      "json_query",
      "json_table",
      "json_table_primitive",
      "json_value",
      "lag",
      "language",
      "large",
      "last_value",
      "lateral",
      "lead",
      "leading",
      "left",
      "like",
      "like_regex",
      "listagg",
      "ln",
      "local",
      "localtime",
      "localtimestamp",
      "log",
      "log10",
      "lower",
      "match",
      "match_number",
      "match_recognize",
      "matches",
      "max",
      "member",
      "merge",
      "method",
      "min",
      "minute",
      "mod",
      "modifies",
      "module",
      "month",
      "multiset",
      "national",
      "natural",
      "nchar",
      "nclob",
      "new",
      "no",
      "none",
      "normalize",
      "not",
      "nth_value",
      "ntile",
      "null",
      "nullif",
      "numeric",
      "octet_length",
      "occurrences_regex",
      "of",
      "offset",
      "old",
      "omit",
      "on",
      "one",
      "only",
      "open",
      "or",
      "order",
      "out",
      "outer",
      "over",
      "overlaps",
      "overlay",
      "parameter",
      "partition",
      "pattern",
      "per",
      "percent",
      "percent_rank",
      "percentile_cont",
      "percentile_disc",
      "period",
      "portion",
      "position",
      "position_regex",
      "power",
      "precedes",
      "precision",
      "prepare",
      "primary",
      "procedure",
      "ptf",
      "range",
      "rank",
      "reads",
      "real",
      "recursive",
      "ref",
      "references",
      "referencing",
      "regr_avgx",
      "regr_avgy",
      "regr_count",
      "regr_intercept",
      "regr_r2",
      "regr_slope",
      "regr_sxx",
      "regr_sxy",
      "regr_syy",
      "release",
      "result",
      "return",
      "returns",
      "revoke",
      "right",
      "rollback",
      "rollup",
      "row",
      "row_number",
      "rows",
      "running",
      "savepoint",
      "scope",
      "scroll",
      "search",
      "second",
      "seek",
      "select",
      "sensitive",
      "session_user",
      "set",
      "show",
      "similar",
      "sin",
      "sinh",
      "skip",
      "smallint",
      "some",
      "specific",
      "specifictype",
      "sql",
      "sqlexception",
      "sqlstate",
      "sqlwarning",
      "sqrt",
      "start",
      "static",
      "stddev_pop",
      "stddev_samp",
      "submultiset",
      "subset",
      "substring",
      "substring_regex",
      "succeeds",
      "sum",
      "symmetric",
      "system",
      "system_time",
      "system_user",
      "table",
      "tablesample",
      "tan",
      "tanh",
      "then",
      "time",
      "timestamp",
      "timezone_hour",
      "timezone_minute",
      "to",
      "trailing",
      "translate",
      "translate_regex",
      "translation",
      "treat",
      "trigger",
      "trim",
      "trim_array",
      "true",
      "truncate",
      "uescape",
      "union",
      "unique",
      "unknown",
      "unnest",
      "update",
      "upper",
      "user",
      "using",
      "value",
      "values",
      "value_of",
      "var_pop",
      "var_samp",
      "varbinary",
      "varchar",
      "varying",
      "versioning",
      "when",
      "whenever",
      "where",
      "width_bucket",
      "window",
      "with",
      "within",
      "without",
      "year"
    ], f = [
      "abs",
      "acos",
      "array_agg",
      "asin",
      "atan",
      "avg",
      "cast",
      "ceil",
      "ceiling",
      "coalesce",
      "corr",
      "cos",
      "cosh",
      "count",
      "covar_pop",
      "covar_samp",
      "cume_dist",
      "dense_rank",
      "deref",
      "element",
      "exp",
      "extract",
      "first_value",
      "floor",
      "json_array",
      "json_arrayagg",
      "json_exists",
      "json_object",
      "json_objectagg",
      "json_query",
      "json_table",
      "json_table_primitive",
      "json_value",
      "lag",
      "last_value",
      "lead",
      "listagg",
      "ln",
      "log",
      "log10",
      "lower",
      "max",
      "min",
      "mod",
      "nth_value",
      "ntile",
      "nullif",
      "percent_rank",
      "percentile_cont",
      "percentile_disc",
      "position",
      "position_regex",
      "power",
      "rank",
      "regr_avgx",
      "regr_avgy",
      "regr_count",
      "regr_intercept",
      "regr_r2",
      "regr_slope",
      "regr_sxx",
      "regr_sxy",
      "regr_syy",
      "row_number",
      "sin",
      "sinh",
      "sqrt",
      "stddev_pop",
      "stddev_samp",
      "substring",
      "substring_regex",
      "sum",
      "tan",
      "tanh",
      "translate",
      "translate_regex",
      "treat",
      "trim",
      "trim_array",
      "unnest",
      "upper",
      "value_of",
      "var_pop",
      "var_samp",
      "width_bucket"
    ], p = [
      "current_catalog",
      "current_date",
      "current_default_transform_group",
      "current_path",
      "current_role",
      "current_schema",
      "current_transform_group_for_type",
      "current_user",
      "session_user",
      "system_time",
      "system_user",
      "current_time",
      "localtime",
      "current_timestamp",
      "localtimestamp"
    ], g = [
      "create table",
      "insert into",
      "primary key",
      "foreign key",
      "not null",
      "alter table",
      "add constraint",
      "grouping sets",
      "on overflow",
      "character set",
      "respect nulls",
      "ignore nulls",
      "nulls first",
      "nulls last",
      "depth first",
      "breadth first"
    ], _ = f, b = [
      ...d,
      ...u
    ].filter((U) => !f.includes(U)), m = {
      scope: "variable",
      match: /@[a-z0-9][a-z0-9_]*/
    }, v = {
      scope: "operator",
      match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
      relevance: 0
    }, C = {
      match: n.concat(/\b/, n.either(..._), /\s*\(/),
      relevance: 0,
      keywords: { built_in: _ }
    };
    function x(U) {
      return n.concat(
        /\b/,
        n.either(...U.map((I) => I.replace(/\s+/, "\\s+"))),
        /\b/
      );
    }
    const P = {
      scope: "keyword",
      match: x(g),
      relevance: 0
    };
    function k(U, {
      exceptions: I,
      when: E
    } = {}) {
      const T = E;
      return I = I || [], U.map((A) => A.match(/\|\d+$/) || I.includes(A) ? A : T(A) ? `${A}|0` : A);
    }
    return {
      name: "SQL",
      case_insensitive: !0,
      // does not include {} or HTML tags `</`
      illegal: /[{}]|<\//,
      keywords: {
        $pattern: /\b[\w\.]+/,
        keyword: k(b, { when: (U) => U.length < 3 }),
        literal: o,
        type: l,
        built_in: p
      },
      contains: [
        {
          scope: "type",
          match: x(a)
        },
        P,
        C,
        m,
        i,
        s,
        e.C_NUMBER_MODE,
        e.C_BLOCK_COMMENT_MODE,
        r,
        v
      ]
    };
  }
  return dd = t, dd;
}
var fd, eb;
function BU() {
  if (eb) return fd;
  eb = 1;
  function t(E) {
    return E ? typeof E == "string" ? E : E.source : null;
  }
  function e(E) {
    return n("(?=", E, ")");
  }
  function n(...E) {
    return E.map((A) => t(A)).join("");
  }
  function r(E) {
    const T = E[E.length - 1];
    return typeof T == "object" && T.constructor === Object ? (E.splice(E.length - 1, 1), T) : {};
  }
  function i(...E) {
    return "(" + (r(E).capture ? "" : "?:") + E.map((R) => t(R)).join("|") + ")";
  }
  const s = (E) => n(
    /\b/,
    E,
    /\w$/.test(E) ? /\b/ : /\B/
  ), o = [
    "Protocol",
    // contextual
    "Type"
    // contextual
  ].map(s), a = [
    "init",
    "self"
  ].map(s), l = [
    "Any",
    "Self"
  ], u = [
    // strings below will be fed into the regular `keywords` engine while regex
    // will result in additional modes being created to scan for those keywords to
    // avoid conflicts with other rules
    "actor",
    "any",
    // contextual
    "associatedtype",
    "async",
    "await",
    /as\?/,
    // operator
    /as!/,
    // operator
    "as",
    // operator
    "borrowing",
    // contextual
    "break",
    "case",
    "catch",
    "class",
    "consume",
    // contextual
    "consuming",
    // contextual
    "continue",
    "convenience",
    // contextual
    "copy",
    // contextual
    "default",
    "defer",
    "deinit",
    "didSet",
    // contextual
    "distributed",
    "do",
    "dynamic",
    // contextual
    "each",
    "else",
    "enum",
    "extension",
    "fallthrough",
    /fileprivate\(set\)/,
    "fileprivate",
    "final",
    // contextual
    "for",
    "func",
    "get",
    // contextual
    "guard",
    "if",
    "import",
    "indirect",
    // contextual
    "infix",
    // contextual
    /init\?/,
    /init!/,
    "inout",
    /internal\(set\)/,
    "internal",
    "in",
    "is",
    // operator
    "isolated",
    // contextual
    "nonisolated",
    // contextual
    "lazy",
    // contextual
    "let",
    "macro",
    "mutating",
    // contextual
    "nonmutating",
    // contextual
    /open\(set\)/,
    // contextual
    "open",
    // contextual
    "operator",
    "optional",
    // contextual
    "override",
    // contextual
    "package",
    "postfix",
    // contextual
    "precedencegroup",
    "prefix",
    // contextual
    /private\(set\)/,
    "private",
    "protocol",
    /public\(set\)/,
    "public",
    "repeat",
    "required",
    // contextual
    "rethrows",
    "return",
    "set",
    // contextual
    "some",
    // contextual
    "static",
    "struct",
    "subscript",
    "super",
    "switch",
    "throws",
    "throw",
    /try\?/,
    // operator
    /try!/,
    // operator
    "try",
    // operator
    "typealias",
    /unowned\(safe\)/,
    // contextual
    /unowned\(unsafe\)/,
    // contextual
    "unowned",
    // contextual
    "var",
    "weak",
    // contextual
    "where",
    "while",
    "willSet"
    // contextual
  ], d = [
    "false",
    "nil",
    "true"
  ], f = [
    "assignment",
    "associativity",
    "higherThan",
    "left",
    "lowerThan",
    "none",
    "right"
  ], p = [
    "#colorLiteral",
    "#column",
    "#dsohandle",
    "#else",
    "#elseif",
    "#endif",
    "#error",
    "#file",
    "#fileID",
    "#fileLiteral",
    "#filePath",
    "#function",
    "#if",
    "#imageLiteral",
    "#keyPath",
    "#line",
    "#selector",
    "#sourceLocation",
    "#warning"
  ], g = [
    "abs",
    "all",
    "any",
    "assert",
    "assertionFailure",
    "debugPrint",
    "dump",
    "fatalError",
    "getVaList",
    "isKnownUniquelyReferenced",
    "max",
    "min",
    "numericCast",
    "pointwiseMax",
    "pointwiseMin",
    "precondition",
    "preconditionFailure",
    "print",
    "readLine",
    "repeatElement",
    "sequence",
    "stride",
    "swap",
    "swift_unboxFromSwiftValueWithType",
    "transcode",
    "type",
    "unsafeBitCast",
    "unsafeDowncast",
    "withExtendedLifetime",
    "withUnsafeMutablePointer",
    "withUnsafePointer",
    "withVaList",
    "withoutActuallyEscaping",
    "zip"
  ], _ = i(
    /[/=\-+!*%<>&|^~?]/,
    /[\u00A1-\u00A7]/,
    /[\u00A9\u00AB]/,
    /[\u00AC\u00AE]/,
    /[\u00B0\u00B1]/,
    /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
    /[\u2016-\u2017]/,
    /[\u2020-\u2027]/,
    /[\u2030-\u203E]/,
    /[\u2041-\u2053]/,
    /[\u2055-\u205E]/,
    /[\u2190-\u23FF]/,
    /[\u2500-\u2775]/,
    /[\u2794-\u2BFF]/,
    /[\u2E00-\u2E7F]/,
    /[\u3001-\u3003]/,
    /[\u3008-\u3020]/,
    /[\u3030]/
  ), b = i(
    _,
    /[\u0300-\u036F]/,
    /[\u1DC0-\u1DFF]/,
    /[\u20D0-\u20FF]/,
    /[\uFE00-\uFE0F]/,
    /[\uFE20-\uFE2F]/
    // TODO: The following characters are also allowed, but the regex isn't supported yet.
    // /[\u{E0100}-\u{E01EF}]/u
  ), m = n(_, b, "*"), v = i(
    /[a-zA-Z_]/,
    /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
    /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
    /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
    /[\u1E00-\u1FFF]/,
    /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
    /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
    /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
    /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
    /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
    /[\uFE47-\uFEFE\uFF00-\uFFFD]/
    // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
    // The following characters are also allowed, but the regexes aren't supported yet.
    // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
    // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
    // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
    // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
  ), C = i(
    v,
    /\d/,
    /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
  ), x = n(v, C, "*"), P = n(/[A-Z]/, C, "*"), k = [
    "attached",
    "autoclosure",
    n(/convention\(/, i("swift", "block", "c"), /\)/),
    "discardableResult",
    "dynamicCallable",
    "dynamicMemberLookup",
    "escaping",
    "freestanding",
    "frozen",
    "GKInspectable",
    "IBAction",
    "IBDesignable",
    "IBInspectable",
    "IBOutlet",
    "IBSegueAction",
    "inlinable",
    "main",
    "nonobjc",
    "NSApplicationMain",
    "NSCopying",
    "NSManaged",
    n(/objc\(/, x, /\)/),
    "objc",
    "objcMembers",
    "propertyWrapper",
    "requires_stored_property_inits",
    "resultBuilder",
    "Sendable",
    "testable",
    "UIApplicationMain",
    "unchecked",
    "unknown",
    "usableFromInline",
    "warn_unqualified_access"
  ], U = [
    "iOS",
    "iOSApplicationExtension",
    "macOS",
    "macOSApplicationExtension",
    "macCatalyst",
    "macCatalystApplicationExtension",
    "watchOS",
    "watchOSApplicationExtension",
    "tvOS",
    "tvOSApplicationExtension",
    "swift"
  ];
  function I(E) {
    const T = {
      match: /\s+/,
      relevance: 0
    }, A = E.COMMENT(
      "/\\*",
      "\\*/",
      { contains: ["self"] }
    ), R = [
      E.C_LINE_COMMENT_MODE,
      A
    ], M = {
      match: [
        /\./,
        i(...o, ...a)
      ],
      className: { 2: "keyword" }
    }, S = {
      // Consume .keyword to prevent highlighting properties and methods as keywords.
      match: n(/\./, i(...u)),
      relevance: 0
    }, D = u.filter((Ue) => typeof Ue == "string").concat(["_|0"]), V = u.filter((Ue) => typeof Ue != "string").concat(l).map(s), X = { variants: [
      {
        className: "keyword",
        match: i(...V, ...a)
      }
    ] }, ge = {
      $pattern: i(
        /\b\w+/,
        // regular keywords
        /#\w+/
        // number keywords
      ),
      keyword: D.concat(p),
      literal: d
    }, Te = [
      M,
      S,
      X
    ], Ie = {
      // Consume .built_in to prevent highlighting properties and methods.
      match: n(/\./, i(...g)),
      relevance: 0
    }, B = {
      className: "built_in",
      match: n(/\b/, i(...g), /(?=\()/)
    }, q = [
      Ie,
      B
    ], se = {
      // Prevent -> from being highlighting as an operator.
      match: /->/,
      relevance: 0
    }, re = {
      className: "operator",
      relevance: 0,
      variants: [
        { match: m },
        {
          // dot-operator: only operators that start with a dot are allowed to use dots as
          // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
          // characters that may also include dots.
          match: `\\.(\\.|${b})+`
        }
      ]
    }, ae = [
      se,
      re
    ], ce = "([0-9]_*)+", pe = "([0-9a-fA-F]_*)+", ie = {
      className: "number",
      relevance: 0,
      variants: [
        // decimal floating-point-literal (subsumes decimal-literal)
        { match: `\\b(${ce})(\\.(${ce}))?([eE][+-]?(${ce}))?\\b` },
        // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
        { match: `\\b0x(${pe})(\\.(${pe}))?([pP][+-]?(${ce}))?\\b` },
        // octal-literal
        { match: /\b0o([0-7]_*)+\b/ },
        // binary-literal
        { match: /\b0b([01]_*)+\b/ }
      ]
    }, le = (Ue = "") => ({
      className: "subst",
      variants: [
        { match: n(/\\/, Ue, /[0\\tnr"']/) },
        { match: n(/\\/, Ue, /u\{[0-9a-fA-F]{1,8}\}/) }
      ]
    }), Se = (Ue = "") => ({
      className: "subst",
      match: n(/\\/, Ue, /[\t ]*(?:[\r\n]|\r\n)/)
    }), de = (Ue = "") => ({
      className: "subst",
      label: "interpol",
      begin: n(/\\/, Ue, /\(/),
      end: /\)/
    }), Le = (Ue = "") => ({
      begin: n(Ue, /"""/),
      end: n(/"""/, Ue),
      contains: [
        le(Ue),
        Se(Ue),
        de(Ue)
      ]
    }), K = (Ue = "") => ({
      begin: n(Ue, /"/),
      end: n(/"/, Ue),
      contains: [
        le(Ue),
        de(Ue)
      ]
    }), Qe = {
      className: "string",
      variants: [
        Le(),
        Le("#"),
        Le("##"),
        Le("###"),
        K(),
        K("#"),
        K("##"),
        K("###")
      ]
    }, ue = [
      E.BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [E.BACKSLASH_ESCAPE]
      }
    ], Ut = {
      begin: /\/[^\s](?=[^/\n]*\/)/,
      end: /\//,
      contains: ue
    }, Ft = (Ue) => {
      const Zt = n(Ue, /\//), en = n(/\//, Ue);
      return {
        begin: Zt,
        end: en,
        contains: [
          ...ue,
          {
            scope: "comment",
            begin: `#(?!.*${en})`,
            end: /$/
          }
        ]
      };
    }, kn = {
      scope: "regexp",
      variants: [
        Ft("###"),
        Ft("##"),
        Ft("#"),
        Ut
      ]
    }, Ir = { match: n(/`/, x, /`/) }, zn = {
      className: "variable",
      match: /\$\d+/
    }, sr = {
      className: "variable",
      match: `\\$${C}+`
    }, or = [
      Ir,
      zn,
      sr
    ], Sr = {
      match: /(@|#(un)?)available/,
      scope: "keyword",
      starts: { contains: [
        {
          begin: /\(/,
          end: /\)/,
          keywords: U,
          contains: [
            ...ae,
            ie,
            Qe
          ]
        }
      ] }
    }, ar = {
      scope: "keyword",
      match: n(/@/, i(...k), e(i(/\(/, /\s+/)))
    }, un = {
      scope: "meta",
      match: n(/@/, x)
    }, En = [
      Sr,
      ar,
      un
    ], We = {
      match: e(/\b[A-Z]/),
      relevance: 0,
      contains: [
        {
          // Common Apple frameworks, for relevance boost
          className: "type",
          match: n(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, C, "+")
        },
        {
          // Type identifier
          className: "type",
          match: P,
          relevance: 0
        },
        {
          // Optional type
          match: /[?!]+/,
          relevance: 0
        },
        {
          // Variadic parameter
          match: /\.\.\./,
          relevance: 0
        },
        {
          // Protocol composition
          match: n(/\s+&\s+/, e(P)),
          relevance: 0
        }
      ]
    }, gt = {
      begin: /</,
      end: />/,
      keywords: ge,
      contains: [
        ...R,
        ...Te,
        ...En,
        se,
        We
      ]
    };
    We.contains.push(gt);
    const Wn = {
      match: n(x, /\s*:/),
      keywords: "_|0",
      relevance: 0
    }, cr = {
      begin: /\(/,
      end: /\)/,
      relevance: 0,
      keywords: ge,
      contains: [
        "self",
        Wn,
        ...R,
        kn,
        ...Te,
        ...q,
        ...ae,
        ie,
        Qe,
        ...or,
        ...En,
        We
      ]
    }, Gn = {
      begin: /</,
      end: />/,
      keywords: "repeat each",
      contains: [
        ...R,
        We
      ]
    }, Oi = {
      begin: i(
        e(n(x, /\s*:/)),
        e(n(x, /\s+/, x, /\s*:/))
      ),
      end: /:/,
      relevance: 0,
      contains: [
        {
          className: "keyword",
          match: /\b_\b/
        },
        {
          className: "params",
          match: x
        }
      ]
    }, Nn = {
      begin: /\(/,
      end: /\)/,
      keywords: ge,
      contains: [
        Oi,
        ...R,
        ...Te,
        ...ae,
        ie,
        Qe,
        ...En,
        We,
        cr
      ],
      endsParent: !0,
      illegal: /["']/
    }, ti = {
      match: [
        /(func|macro)/,
        /\s+/,
        i(Ir.match, x, m)
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        Gn,
        Nn,
        T
      ],
      illegal: [
        /\[/,
        /%/
      ]
    }, Ar = {
      match: [
        /\b(?:subscript|init[?!]?)/,
        /\s*(?=[<(])/
      ],
      className: { 1: "keyword" },
      contains: [
        Gn,
        Nn,
        T
      ],
      illegal: /\[|%/
    }, Rr = {
      match: [
        /operator/,
        /\s+/,
        m
      ],
      className: {
        1: "keyword",
        3: "title"
      }
    }, Pi = {
      begin: [
        /precedencegroup/,
        /\s+/,
        P
      ],
      className: {
        1: "keyword",
        3: "title"
      },
      contains: [We],
      keywords: [
        ...f,
        ...d
      ],
      end: /}/
    }, xi = {
      match: [
        /class\b/,
        /\s+/,
        /func\b/,
        /\s+/,
        /\b[A-Za-z_][A-Za-z0-9_]*\b/
      ],
      scope: {
        1: "keyword",
        3: "keyword",
        5: "title.function"
      }
    }, wn = {
      match: [
        /class\b/,
        /\s+/,
        /var\b/
      ],
      scope: {
        1: "keyword",
        3: "keyword"
      }
    }, lr = {
      begin: [
        /(struct|protocol|class|extension|enum|actor)/,
        /\s+/,
        x,
        /\s*/
      ],
      beginScope: {
        1: "keyword",
        3: "title.class"
      },
      keywords: ge,
      contains: [
        Gn,
        ...Te,
        {
          begin: /:/,
          end: /\{/,
          keywords: ge,
          contains: [
            {
              scope: "title.class.inherited",
              match: P
            },
            ...Te
          ],
          relevance: 0
        }
      ]
    };
    for (const Ue of Qe.variants) {
      const Zt = Ue.contains.find((dn) => dn.label === "interpol");
      Zt.keywords = ge;
      const en = [
        ...Te,
        ...q,
        ...ae,
        ie,
        Qe,
        ...or
      ];
      Zt.contains = [
        ...en,
        {
          begin: /\(/,
          end: /\)/,
          contains: [
            "self",
            ...en
          ]
        }
      ];
    }
    return {
      name: "Swift",
      keywords: ge,
      contains: [
        ...R,
        ti,
        Ar,
        xi,
        wn,
        lr,
        Rr,
        Pi,
        {
          beginKeywords: "import",
          end: /$/,
          contains: [...R],
          relevance: 0
        },
        kn,
        ...Te,
        ...q,
        ...ae,
        ie,
        Qe,
        ...or,
        ...En,
        We,
        cr
      ]
    };
  }
  return fd = I, fd;
}
var hd, tb;
function $U() {
  if (tb) return hd;
  tb = 1;
  function t(e) {
    const n = "true false yes no null", r = "[\\w#;/?:@&=+$,.~*'()[\\]]+", i = {
      className: "attr",
      variants: [
        // added brackets support and special char support
        { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
        {
          // double quoted keys - with brackets and special char support
          begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
        },
        {
          // single quoted keys - with brackets and special char support
          begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
        }
      ]
    }, s = {
      className: "template-variable",
      variants: [
        {
          // jinja templates Ansible
          begin: /\{\{/,
          end: /\}\}/
        },
        {
          // Ruby i18n
          begin: /%\{/,
          end: /\}/
        }
      ]
    }, o = {
      className: "string",
      relevance: 0,
      begin: /'/,
      end: /'/,
      contains: [
        {
          match: /''/,
          scope: "char.escape",
          relevance: 0
        }
      ]
    }, a = {
      className: "string",
      relevance: 0,
      variants: [
        {
          begin: /"/,
          end: /"/
        },
        { begin: /\S+/ }
      ],
      contains: [
        e.BACKSLASH_ESCAPE,
        s
      ]
    }, l = e.inherit(a, { variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [
          {
            begin: /''/,
            relevance: 0
          }
        ]
      },
      {
        begin: /"/,
        end: /"/
      },
      { begin: /[^\s,{}[\]]+/ }
    ] }), g = {
      className: "number",
      begin: "\\b" + "[0-9]{4}(-[0-9][0-9]){0,2}" + "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" + "(\\.[0-9]*)?" + "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" + "\\b"
    }, _ = {
      end: ",",
      endsWithParent: !0,
      excludeEnd: !0,
      keywords: n,
      relevance: 0
    }, b = {
      begin: /\{/,
      end: /\}/,
      contains: [_],
      illegal: "\\n",
      relevance: 0
    }, m = {
      begin: "\\[",
      end: "\\]",
      contains: [_],
      illegal: "\\n",
      relevance: 0
    }, v = [
      i,
      {
        className: "meta",
        begin: "^---\\s*$",
        relevance: 10
      },
      {
        // multi line string
        // Blocks start with a | or > followed by a newline
        //
        // Indentation of subsequent lines must be the same to
        // be considered part of the block
        className: "string",
        begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
      },
      {
        // Ruby/Rails erb
        begin: "<%[%=-]?",
        end: "[%-]?%>",
        subLanguage: "ruby",
        excludeBegin: !0,
        excludeEnd: !0,
        relevance: 0
      },
      {
        // named tags
        className: "type",
        begin: "!\\w+!" + r
      },
      // https://yaml.org/spec/1.2/spec.html#id2784064
      {
        // verbatim tags
        className: "type",
        begin: "!<" + r + ">"
      },
      {
        // primary tags
        className: "type",
        begin: "!" + r
      },
      {
        // secondary tags
        className: "type",
        begin: "!!" + r
      },
      {
        // fragment id &ref
        className: "meta",
        begin: "&" + e.UNDERSCORE_IDENT_RE + "$"
      },
      {
        // fragment reference *ref
        className: "meta",
        begin: "\\*" + e.UNDERSCORE_IDENT_RE + "$"
      },
      {
        // array listing
        className: "bullet",
        // TODO: remove |$ hack when we have proper look-ahead support
        begin: "-(?=[ ]|$)",
        relevance: 0
      },
      e.HASH_COMMENT_MODE,
      {
        beginKeywords: n,
        keywords: { literal: n }
      },
      g,
      // numbers are any valid C-style number that
      // sit isolated from other words
      {
        className: "number",
        begin: e.C_NUMBER_RE + "\\b",
        relevance: 0
      },
      b,
      m,
      o,
      a
    ], C = [...v];
    return C.pop(), C.push(l), _.contains = C, {
      name: "YAML",
      case_insensitive: !0,
      aliases: ["yml"],
      contains: v
    };
  }
  return hd = t, hd;
}
var pd, nb;
function jU() {
  if (nb) return pd;
  nb = 1;
  const t = "[A-Za-z$_][0-9A-Za-z$_]*", e = [
    "as",
    // for exports
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    // JS handles these with a special rule
    // "get",
    // "set",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends",
    // It's reached stage 3, which is "recommended for implementation":
    "using"
  ], n = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ], r = [
    // Fundamental objects
    "Object",
    "Function",
    "Boolean",
    "Symbol",
    // numbers and dates
    "Math",
    "Date",
    "Number",
    "BigInt",
    // text
    "String",
    "RegExp",
    // Indexed collections
    "Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Int32Array",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array",
    // Keyed collections
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    // Structured data
    "ArrayBuffer",
    "SharedArrayBuffer",
    "Atomics",
    "DataView",
    "JSON",
    // Control abstraction objects
    "Promise",
    "Generator",
    "GeneratorFunction",
    "AsyncFunction",
    // Reflection
    "Reflect",
    "Proxy",
    // Internationalization
    "Intl",
    // WebAssembly
    "WebAssembly"
  ], i = [
    "Error",
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ], s = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ], o = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "sessionStorage",
    "module",
    "global"
    // Node.js
  ], a = [].concat(
    s,
    r,
    i
  );
  function l(d) {
    const f = d.regex, p = (le, { after: Se }) => {
      const de = "</" + le[0].slice(1);
      return le.input.indexOf(de, Se) !== -1;
    }, g = t, _ = {
      begin: "<>",
      end: "</>"
    }, b = /<[A-Za-z0-9\\._:-]+\s*\/>/, m = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      /**
       * @param {RegExpMatchArray} match
       * @param {CallbackResponse} response
       */
      isTrulyOpeningTag: (le, Se) => {
        const de = le[0].length + le.index, Le = le.input[de];
        if (
          // HTML should not include another raw `<` inside a tag
          // nested type?
          // `<Array<Array<number>>`, etc.
          Le === "<" || // the , gives away that this is not HTML
          // `<T, A extends keyof T, V>`
          Le === ","
        ) {
          Se.ignoreMatch();
          return;
        }
        Le === ">" && (p(le, { after: de }) || Se.ignoreMatch());
        let K;
        const Qe = le.input.substring(de);
        if (K = Qe.match(/^\s*=/)) {
          Se.ignoreMatch();
          return;
        }
        if ((K = Qe.match(/^\s+extends\s+/)) && K.index === 0) {
          Se.ignoreMatch();
          return;
        }
      }
    }, v = {
      $pattern: t,
      keyword: e,
      literal: n,
      built_in: a,
      "variable.language": o
    }, C = "[0-9](_?[0-9])*", x = `\\.(${C})`, P = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", k = {
      className: "number",
      variants: [
        // DecimalLiteral
        { begin: `(\\b(${P})((${x})|\\.)?|(${x}))[eE][+-]?(${C})\\b` },
        { begin: `\\b(${P})\\b((${x})\\b|\\.)?|(${x})\\b` },
        // DecimalBigIntegerLiteral
        { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
        // NonDecimalIntegerLiteral
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        // LegacyOctalIntegerLiteral (does not include underscore separators)
        // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
        { begin: "\\b0[0-7]+n?\\b" }
      ],
      relevance: 0
    }, U = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: v,
      contains: []
      // defined later
    }, I = {
      begin: ".?html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          d.BACKSLASH_ESCAPE,
          U
        ],
        subLanguage: "xml"
      }
    }, E = {
      begin: ".?css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          d.BACKSLASH_ESCAPE,
          U
        ],
        subLanguage: "css"
      }
    }, T = {
      begin: ".?gql`",
      end: "",
      starts: {
        end: "`",
        returnEnd: !1,
        contains: [
          d.BACKSLASH_ESCAPE,
          U
        ],
        subLanguage: "graphql"
      }
    }, A = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        d.BACKSLASH_ESCAPE,
        U
      ]
    }, M = {
      className: "comment",
      variants: [
        d.COMMENT(
          /\/\*\*(?!\/)/,
          "\\*/",
          {
            relevance: 0,
            contains: [
              {
                begin: "(?=@[A-Za-z]+)",
                relevance: 0,
                contains: [
                  {
                    className: "doctag",
                    begin: "@[A-Za-z]+"
                  },
                  {
                    className: "type",
                    begin: "\\{",
                    end: "\\}",
                    excludeEnd: !0,
                    excludeBegin: !0,
                    relevance: 0
                  },
                  {
                    className: "variable",
                    begin: g + "(?=\\s*(-)|$)",
                    endsParent: !0,
                    relevance: 0
                  },
                  // eat spaces (not newlines) so we can find
                  // types or variables
                  {
                    begin: /(?=[^\n])\s/,
                    relevance: 0
                  }
                ]
              }
            ]
          }
        ),
        d.C_BLOCK_COMMENT_MODE,
        d.C_LINE_COMMENT_MODE
      ]
    }, S = [
      d.APOS_STRING_MODE,
      d.QUOTE_STRING_MODE,
      I,
      E,
      T,
      A,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      k
      // This is intentional:
      // See https://github.com/highlightjs/highlight.js/issues/3288
      // hljs.REGEXP_MODE
    ];
    U.contains = S.concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: v,
      contains: [
        "self"
      ].concat(S)
    });
    const D = [].concat(M, U.contains), V = D.concat([
      // eat recursive parens in sub expressions
      {
        begin: /(\s*)\(/,
        end: /\)/,
        keywords: v,
        contains: ["self"].concat(D)
      }
    ]), X = {
      className: "params",
      // convert this to negative lookbehind in v12
      begin: /(\s*)\(/,
      // to match the parms with
      end: /\)/,
      excludeBegin: !0,
      excludeEnd: !0,
      keywords: v,
      contains: V
    }, ge = {
      variants: [
        // class Car extends vehicle
        {
          match: [
            /class/,
            /\s+/,
            g,
            /\s+/,
            /extends/,
            /\s+/,
            f.concat(g, "(", f.concat(/\./, g), ")*")
          ],
          scope: {
            1: "keyword",
            3: "title.class",
            5: "keyword",
            7: "title.class.inherited"
          }
        },
        // class Car
        {
          match: [
            /class/,
            /\s+/,
            g
          ],
          scope: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    }, Te = {
      relevance: 0,
      match: f.either(
        // Hard coded exceptions
        /\bJSON/,
        // Float32Array, OutT
        /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
        // CSSFactory, CSSFactoryT
        /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
        // FPs, FPsT
        /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
        // P
        // single letters are not highlighted
        // BLAH
        // this will be flagged as a UPPER_CASE_CONSTANT instead
      ),
      className: "title.class",
      keywords: {
        _: [
          // se we still get relevance credit for JS library classes
          ...r,
          ...i
        ]
      }
    }, Ie = {
      label: "use_strict",
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use (strict|asm)['"]/
    }, B = {
      variants: [
        {
          match: [
            /function/,
            /\s+/,
            g,
            /(?=\s*\()/
          ]
        },
        // anonymous function
        {
          match: [
            /function/,
            /\s*(?=\()/
          ]
        }
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      label: "func.def",
      contains: [X],
      illegal: /%/
    }, q = {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    };
    function se(le) {
      return f.concat("(?!", le.join("|"), ")");
    }
    const re = {
      match: f.concat(
        /\b/,
        se([
          ...s,
          "super",
          "import"
        ].map((le) => `${le}\\s*\\(`)),
        g,
        f.lookahead(/\s*\(/)
      ),
      className: "title.function",
      relevance: 0
    }, ae = {
      begin: f.concat(/\./, f.lookahead(
        f.concat(g, /(?![0-9A-Za-z$_(])/)
      )),
      end: g,
      excludeBegin: !0,
      keywords: "prototype",
      className: "property",
      relevance: 0
    }, ce = {
      match: [
        /get|set/,
        /\s+/,
        g,
        /(?=\()/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        {
          // eat to avoid empty params
          begin: /\(\)/
        },
        X
      ]
    }, pe = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + d.UNDERSCORE_IDENT_RE + ")\\s*=>", ie = {
      match: [
        /const|var|let/,
        /\s+/,
        g,
        /\s*/,
        /=\s*/,
        /(async\s*)?/,
        // async is optional
        f.lookahead(pe)
      ],
      keywords: "async",
      className: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        X
      ]
    };
    return {
      name: "JavaScript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: v,
      // this will be extended by TypeScript
      exports: { PARAMS_CONTAINS: V, CLASS_REFERENCE: Te },
      illegal: /#(?![$_A-z])/,
      contains: [
        d.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        Ie,
        d.APOS_STRING_MODE,
        d.QUOTE_STRING_MODE,
        I,
        E,
        T,
        A,
        M,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        k,
        Te,
        {
          scope: "attr",
          match: g + f.lookahead(":"),
          relevance: 0
        },
        ie,
        {
          // "value" container
          begin: "(" + d.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [
            M,
            d.REGEXP_MODE,
            {
              className: "function",
              // we have to count the parens to make sure we actually have the
              // correct bounding ( ) before the =>.  There could be any number of
              // sub-expressions inside also surrounded by parens.
              begin: pe,
              returnBegin: !0,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: d.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: !0
                    },
                    {
                      begin: /(\s*)\(/,
                      end: /\)/,
                      excludeBegin: !0,
                      excludeEnd: !0,
                      keywords: v,
                      contains: V
                    }
                  ]
                }
              ]
            },
            {
              // could be a comma delimited list of params to a function call
              begin: /,/,
              relevance: 0
            },
            {
              match: /\s+/,
              relevance: 0
            },
            {
              // JSX
              variants: [
                { begin: _.begin, end: _.end },
                { match: b },
                {
                  begin: m.begin,
                  // we carefully check the opening tag to see if it truly
                  // is a tag and not a false positive
                  "on:begin": m.isTrulyOpeningTag,
                  end: m.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: m.begin,
                  end: m.end,
                  skip: !0,
                  contains: ["self"]
                }
              ]
            }
          ]
        },
        B,
        {
          // prevent this from getting swallowed up by function
          // since they appear "function like"
          beginKeywords: "while if switch catch for"
        },
        {
          // we have to count the parens to make sure we actually have the correct
          // bounding ( ).  There could be any number of sub-expressions inside
          // also surrounded by parens.
          begin: "\\b(?!function)" + d.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          // end parens
          returnBegin: !0,
          label: "func.def",
          contains: [
            X,
            d.inherit(d.TITLE_MODE, { begin: g, className: "title.function" })
          ]
        },
        // catch ... so it won't trigger the property rule below
        {
          match: /\.\.\./,
          relevance: 0
        },
        ae,
        // hack: prevents detection of keywords in some circumstances
        // .keyword()
        // $keyword = x
        {
          match: "\\$" + g,
          relevance: 0
        },
        {
          match: [/\bconstructor(?=\s*\()/],
          className: { 1: "title.function" },
          contains: [X]
        },
        re,
        q,
        ge,
        ce,
        {
          match: /\$[(.]/
          // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
        }
      ]
    };
  }
  function u(d) {
    const f = d.regex, p = l(d), g = t, _ = [
      "any",
      "void",
      "number",
      "boolean",
      "string",
      "object",
      "never",
      "symbol",
      "bigint",
      "unknown"
    ], b = {
      begin: [
        /namespace/,
        /\s+/,
        d.IDENT_RE
      ],
      beginScope: {
        1: "keyword",
        3: "title.class"
      }
    }, m = {
      beginKeywords: "interface",
      end: /\{/,
      excludeEnd: !0,
      keywords: {
        keyword: "interface extends",
        built_in: _
      },
      contains: [p.exports.CLASS_REFERENCE]
    }, v = {
      className: "meta",
      relevance: 10,
      begin: /^\s*['"]use strict['"]/
    }, C = [
      "type",
      // "namespace",
      "interface",
      "public",
      "private",
      "protected",
      "implements",
      "declare",
      "abstract",
      "readonly",
      "enum",
      "override",
      "satisfies"
    ], x = {
      $pattern: t,
      keyword: e.concat(C),
      literal: n,
      built_in: a.concat(_),
      "variable.language": o
    }, P = {
      className: "meta",
      begin: "@" + g
    }, k = (T, A, R) => {
      const M = T.contains.findIndex((S) => S.label === A);
      if (M === -1)
        throw new Error("can not find mode to replace");
      T.contains.splice(M, 1, R);
    };
    Object.assign(p.keywords, x), p.exports.PARAMS_CONTAINS.push(P);
    const U = p.contains.find((T) => T.scope === "attr"), I = Object.assign(
      {},
      U,
      { match: f.concat(g, f.lookahead(/\s*\?:/)) }
    );
    p.exports.PARAMS_CONTAINS.push([
      p.exports.CLASS_REFERENCE,
      // class reference for highlighting the params types
      U,
      // highlight the params key
      I
      // Added for optional property assignment highlighting
    ]), p.contains = p.contains.concat([
      P,
      b,
      m,
      I
      // Added for optional property assignment highlighting
    ]), k(p, "shebang", d.SHEBANG()), k(p, "use_strict", v);
    const E = p.contains.find((T) => T.label === "func.def");
    return E.relevance = 0, Object.assign(p, {
      name: "TypeScript",
      aliases: [
        "ts",
        "tsx",
        "mts",
        "cts"
      ]
    }), p;
  }
  return pd = u, pd;
}
var md, rb;
function qU() {
  if (rb) return md;
  rb = 1;
  function t(e) {
    const n = e.regex, r = {
      className: "string",
      begin: /"(""|[^/n])"C\b/
    }, i = {
      className: "string",
      begin: /"/,
      end: /"/,
      illegal: /\n/,
      contains: [
        {
          // double quote escape
          begin: /""/
        }
      ]
    }, s = /\d{1,2}\/\d{1,2}\/\d{4}/, o = /\d{4}-\d{1,2}-\d{1,2}/, a = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, l = /\d{1,2}(:\d{1,2}){1,2}/, u = {
      className: "literal",
      variants: [
        {
          // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
          begin: n.concat(/# */, n.either(o, s), / *#/)
        },
        {
          // #H:mm[:ss]# (24h Time)
          begin: n.concat(/# */, l, / *#/)
        },
        {
          // #h[:mm[:ss]] A# (12h Time)
          begin: n.concat(/# */, a, / *#/)
        },
        {
          // date plus time
          begin: n.concat(
            /# */,
            n.either(o, s),
            / +/,
            n.either(a, l),
            / *#/
          )
        }
      ]
    }, d = {
      className: "number",
      relevance: 0,
      variants: [
        {
          // Float
          begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
        },
        {
          // Integer (base 10)
          begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
        },
        {
          // Integer (base 16)
          begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
        },
        {
          // Integer (base 8)
          begin: /&O[0-7_]+((U?[SIL])|[%&])?/
        },
        {
          // Integer (base 2)
          begin: /&B[01_]+((U?[SIL])|[%&])?/
        }
      ]
    }, f = {
      className: "label",
      begin: /^\w+:/
    }, p = e.COMMENT(/'''/, /$/, { contains: [
      {
        className: "doctag",
        begin: /<\/?/,
        end: />/
      }
    ] }), g = e.COMMENT(null, /$/, { variants: [
      { begin: /'/ },
      {
        // TODO: Use multi-class for leading spaces
        begin: /([\t ]|^)REM(?=\s)/
      }
    ] });
    return {
      name: "Visual Basic .NET",
      aliases: ["vb"],
      case_insensitive: !0,
      classNameAliases: { label: "symbol" },
      keywords: {
        keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
        built_in: (
          // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
          "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
        ),
        type: (
          // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
          "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
        ),
        literal: "true false nothing"
      },
      illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
      contains: [
        r,
        i,
        u,
        d,
        f,
        p,
        g,
        {
          className: "meta",
          // TODO: Use multi-class for indentation once available
          begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
          end: /$/,
          keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
          contains: [g]
        }
      ]
    };
  }
  return md = t, md;
}
var gd, ib;
function zU() {
  if (ib) return gd;
  ib = 1;
  function t(e) {
    e.regex;
    const n = e.COMMENT(/\(;/, /;\)/);
    n.contains.push("self");
    const r = e.COMMENT(/;;/, /$/), i = [
      "anyfunc",
      "block",
      "br",
      "br_if",
      "br_table",
      "call",
      "call_indirect",
      "data",
      "drop",
      "elem",
      "else",
      "end",
      "export",
      "func",
      "global.get",
      "global.set",
      "local.get",
      "local.set",
      "local.tee",
      "get_global",
      "get_local",
      "global",
      "if",
      "import",
      "local",
      "loop",
      "memory",
      "memory.grow",
      "memory.size",
      "module",
      "mut",
      "nop",
      "offset",
      "param",
      "result",
      "return",
      "select",
      "set_global",
      "set_local",
      "start",
      "table",
      "tee_local",
      "then",
      "type",
      "unreachable"
    ], s = {
      begin: [
        /(?:func|call|call_indirect)/,
        /\s+/,
        /\$[^\s)]+/
      ],
      className: {
        1: "keyword",
        3: "title.function"
      }
    }, o = {
      className: "variable",
      begin: /\$[\w_]+/
    }, a = {
      match: /(\((?!;)|\))+/,
      className: "punctuation",
      relevance: 0
    }, l = {
      className: "number",
      relevance: 0,
      // borrowed from Prism, TODO: split out into variants
      match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
    }, u = {
      // look-ahead prevents us from gobbling up opcodes
      match: /(i32|i64|f32|f64)(?!\.)/,
      className: "type"
    }, d = {
      className: "keyword",
      // borrowed from Prism, TODO: split out into variants
      match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
    };
    return {
      name: "WebAssembly",
      keywords: {
        $pattern: /[\w.]+/,
        keyword: i
      },
      contains: [
        r,
        n,
        {
          match: [
            /(?:offset|align)/,
            /\s*/,
            /=/
          ],
          className: {
            1: "keyword",
            3: "operator"
          }
        },
        o,
        a,
        s,
        e.QUOTE_STRING_MODE,
        u,
        d,
        l
      ]
    };
  }
  return gd = t, gd;
}
var yd, sb;
function WU() {
  if (sb) return yd;
  sb = 1;
  var t = /* @__PURE__ */ cU();
  return t.registerLanguage("xml", /* @__PURE__ */ lU()), t.registerLanguage("bash", /* @__PURE__ */ uU()), t.registerLanguage("c", /* @__PURE__ */ dU()), t.registerLanguage("cpp", /* @__PURE__ */ fU()), t.registerLanguage("csharp", /* @__PURE__ */ hU()), t.registerLanguage("css", /* @__PURE__ */ pU()), t.registerLanguage("markdown", /* @__PURE__ */ mU()), t.registerLanguage("diff", /* @__PURE__ */ gU()), t.registerLanguage("ruby", /* @__PURE__ */ yU()), t.registerLanguage("go", /* @__PURE__ */ _U()), t.registerLanguage("graphql", /* @__PURE__ */ bU()), t.registerLanguage("ini", /* @__PURE__ */ vU()), t.registerLanguage("java", /* @__PURE__ */ EU()), t.registerLanguage("javascript", /* @__PURE__ */ wU()), t.registerLanguage("json", /* @__PURE__ */ TU()), t.registerLanguage("kotlin", /* @__PURE__ */ IU()), t.registerLanguage("less", /* @__PURE__ */ SU()), t.registerLanguage("lua", /* @__PURE__ */ AU()), t.registerLanguage("makefile", /* @__PURE__ */ RU()), t.registerLanguage("perl", /* @__PURE__ */ CU()), t.registerLanguage("objectivec", /* @__PURE__ */ kU()), t.registerLanguage("php", /* @__PURE__ */ NU()), t.registerLanguage("php-template", /* @__PURE__ */ OU()), t.registerLanguage("plaintext", /* @__PURE__ */ PU()), t.registerLanguage("python", /* @__PURE__ */ xU()), t.registerLanguage("python-repl", /* @__PURE__ */ MU()), t.registerLanguage("r", /* @__PURE__ */ DU()), t.registerLanguage("rust", /* @__PURE__ */ LU()), t.registerLanguage("scss", /* @__PURE__ */ UU()), t.registerLanguage("shell", /* @__PURE__ */ FU()), t.registerLanguage("sql", /* @__PURE__ */ VU()), t.registerLanguage("swift", /* @__PURE__ */ BU()), t.registerLanguage("yaml", /* @__PURE__ */ $U()), t.registerLanguage("typescript", /* @__PURE__ */ jU()), t.registerLanguage("vbnet", /* @__PURE__ */ qU()), t.registerLanguage("wasm", /* @__PURE__ */ zU()), t.HighlightJS = t, t.default = t, yd = t, yd;
}
var GU = WU();
const ij = /* @__PURE__ */ Lb(GU);
function sj() {
  const t = vn();
  return /* @__PURE__ */ bn(
    "div",
    {
      className: "relative bg-opacity-10 w-full h-[2px] pointer-events-none",
      style: {
        ...t("gray.opacity")
      },
      children: [
        /* @__PURE__ */ he(
          "div",
          {
            className: Yt("left-0 absolute h-full animate-loading transform"),
            style: {
              ...t({
                background: af("to right", "transparent", "primary")
              })
            }
          }
        ),
        /* @__PURE__ */ he(
          "div",
          {
            className: Yt("right-0 absolute h-full animate-loading transform"),
            style: {
              ...t({
                background: af("to right", "primary", "transparent")
              })
            }
          }
        )
      ]
    }
  );
}
const CT = ({ className: t, circleClassName: e, children: n, ...r }) => {
  const i = vn();
  return /* @__PURE__ */ he("span", { children: /* @__PURE__ */ bn("span", { className: Yt("inline-flex relative justify-center items-center w-[25px] h-[25px] text-xs", t), ...r, children: [
    n,
    /* @__PURE__ */ he(
      "span",
      {
        className: Yt("inline-block absolute border-[2px] border-transparent border-solid rounded-full w-full h-full animate-spin", e),
        style: {
          ...i({
            borderTopColor: "primary",
            borderLeftColor: "primary",
            borderRightColor: "primary"
          })
        }
      }
    )
  ] }) });
}, HU = ({ balls: t = 3, ballClassName: e = "", ballStyle: n, icon: r, iconClassName: i }) => {
  const s = vn();
  return /* @__PURE__ */ he("div", { className: "flex", children: Nb(1, t).map((o) => /* @__PURE__ */ he(
    "span",
    {
      className: Yt("inline-flex justify-center items-center rounded-full w-[30px] h-[30px] animate-ty", e),
      style: {
        ...s("primary", {
          color: "primary.content"
        }),
        animationDelay: `${o / t * 1}s`,
        ...Db(n)
      },
      children: /* @__PURE__ */ he(Vo, { icon: r, iconClassName: Yt("w-1/2 h-1/2", i) })
    },
    o
  )) });
}, oj = ({ className: t, children: e, ...n }) => {
  const r = vn();
  return /* @__PURE__ */ bn("div", { className: Yt("relative w-full h-full overflow-hidden", t), ...n, children: [
    /* @__PURE__ */ he(
      "div",
      {
        style: {
          ...r("gray.opacity")
        },
        className: "absolute inset-0 animate-pulse",
        children: /* @__PURE__ */ he(
          "div",
          {
            className: "absolute w-2/3 h-full animate-move-right",
            style: {
              ...r({
                background: af("to right", "transparent", "gray.opacity", "transparent")
              })
            }
          }
        )
      }
    ),
    e
  ] });
}, KU = () => {
  const t = vn();
  return /* @__PURE__ */ bn("svg", { className: Yt("cardio-loading-container"), x: "0px", y: "0px", viewBox: "0 0 50 31.25", height: "31.25", width: "50", preserveAspectRatio: "xMidYMid meet", children: [
    /* @__PURE__ */ he(
      "path",
      {
        style: {
          ...t({
            stroke: "primary"
          })
        },
        className: "track",
        strokeWidth: "4",
        fill: "none",
        pathLength: "100",
        d: "M0.625 21.5 h10.25 l3.75 -5.875 l7.375 15 l9.75 -30 l7.375 20.875 v0 h10.25"
      }
    ),
    /* @__PURE__ */ he(
      "path",
      {
        style: {
          ...t({
            stroke: "primary"
          })
        },
        className: "car",
        strokeWidth: "4",
        fill: "none",
        pathLength: "100",
        d: "M0.625 21.5 h10.25 l3.75 -5.875 l7.375 15 l9.75 -30 l7.375 20.875 v0 h10.25"
      }
    )
  ] });
}, aj = {
  Circle: CT,
  Ball: HU,
  Cardio: KU
}, cj = Me.memo(
  ({ id: t, config: e, state: n }) => {
    var g;
    const r = vn(), i = ct(() => ((e == null ? void 0 : e.match) || ".").split("-"), [e == null ? void 0 : e.match]), s = ((g = n.get) == null ? void 0 : g.toString()) || "", o = at(!1), a = Bo(() => Pb(t), [t]), l = () => o.set(!0), u = () => o.set(!1), d = Bo(
      (_) => {
        const b = _.target.value.replace(/[^0-9]/g, "");
        n.set(b || null);
      },
      [n]
    ), f = Bo(async () => {
      const _ = (await navigator.clipboard.readText()).replace(/[^0-9]/g, "");
      n.set(_ || null);
    }, [n.set]), p = Me.useMemo(() => {
      var _;
      return (_ = e == null ? void 0 : e.match) == null ? void 0 : _.split("-").map((b) => b.length).reduce((b, m) => b + m, 0);
    }, [e == null ? void 0 : e.match]);
    return /* @__PURE__ */ bn("div", { tabIndex: 1, onFocus: a, children: [
      /* @__PURE__ */ he(
        "input",
        {
          onFocus: l,
          onBlur: u,
          onKeyDown: (_) => {
            if (new Ob("arrowdown|arrowright|arrowup|arrowleft").test(_)) {
              _.preventDefault();
              return;
            }
          },
          type: "text",
          inputMode: "numeric",
          onChange: d,
          onPaste: f,
          id: t,
          value: s,
          maxLength: p,
          className: "absolute opacity-0 w-0 h-0"
        }
      ),
      /* @__PURE__ */ he("div", { className: "flex flex-wrap items-center gap-1 rounded-lg w-fit", children: /* @__PURE__ */ he(
        AT,
        {
          list: i.map((_, b) => {
            const m = Array.from(_), v = i.slice(0, b).reduce((C, x) => C + x.length, 0);
            return /* @__PURE__ */ he(
              "div",
              {
                className: "flex rounded-lg",
                style: {
                  ...r({
                    boxShadow: Xc([{ colorId: "shadow.color", blur: 4, size: 0, x: 0, y: 5 }])
                  })
                },
                children: m.map((C, x) => {
                  const P = v + x, k = (e == null ? void 0 : e.size) || 50, U = s.length == P, I = p == s.length;
                  return /* @__PURE__ */ he(
                    "div",
                    {
                      className: Yt(
                        "flex justify-center items-center border-y border-transparent border-r border-solid text-lg",
                        x === 0 && "rounded-ss-lg rounded-es-lg border-l",
                        x + 1 === m.length && "rounded-se-lg rounded-ee-lg",
                        U && "border-l",
                        o.get && I && x + 1 !== m.length && "border-r-0"
                      ),
                      style: {
                        ...r({ borderColor: "borders" }, o.get && U && { borderColor: "primary" }, o.get && I && { borderColor: "primary" }),
                        width: k,
                        height: k
                      },
                      children: (s == null ? void 0 : s[P]) || (U ? o.get && /* @__PURE__ */ he(
                        "span",
                        {
                          className: "animate-pulse",
                          style: {
                            ...r({
                              color: "primary"
                            })
                          },
                          children: (e == null ? void 0 : e.cursor) || "|"
                        }
                      ) : "")
                    },
                    x
                  );
                })
              },
              b
            );
          }),
          joinComponent: /* @__PURE__ */ he(Si, { children: (e == null ? void 0 : e.separator) || "-" })
        }
      ) })
    ] });
  },
  (t, e) => t.state.get === e.state.get && t.config === e.config
), lj = Me.forwardRef(({ children: t, onScroll: e, className: n, type: r = "normal", ...i }, s) => {
  const o = at(0), a = Me.createRef(), l = (d) => {
    o.set(d.currentTarget.scrollTop), e && e(d);
  }, u = vn();
  return /* @__PURE__ */ bn("div", { ...i, ref: s, className: "scroll-view", children: [
    /* @__PURE__ */ he("div", { "aria-label": "scrolled-view", className: Yt("w-full h-full overflow-y-auto", n), ref: a, onScroll: l, children: t }),
    /* @__PURE__ */ he(
      "div",
      {
        "data-scrolled": o.get >= 10,
        className: "scroll-shadow-view",
        style: {
          ...u(
            o.get >= 10 && {
              boxShadow: Xc([
                {
                  x: 0,
                  y: 4,
                  size: 10,
                  blur: 10,
                  colorId: "shadow.color"
                }
              ])
            }
          )
        }
      }
    )
  ] });
}), YU = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
}, kT = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
class XU {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function uj(t, e, n) {
  let r, i;
  n = n || NT;
  let s = 0, o = t.length, a = !1;
  for (; s < o; )
    r = s + (o - s >> 1), i = +n(t[r], e), i < 0 ? s = r + 1 : (o = r, a = !i);
  return a ? s : ~s;
}
function NT(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}
function dj(t, e) {
  return t < e ? 1 : t > e ? -1 : 0;
}
function fj(t, e, n) {
  if (t[0] <= e)
    return 0;
  const r = t.length;
  if (e <= t[r - 1])
    return r - 1;
  if (typeof n == "function") {
    for (let i = 1; i < r; ++i) {
      const s = t[i];
      if (s === e)
        return i;
      if (s < e)
        return n(e, t[i - 1], s) > 0 ? i - 1 : i;
    }
    return r - 1;
  }
  if (n > 0) {
    for (let i = 1; i < r; ++i)
      if (t[i] < e)
        return i - 1;
    return r - 1;
  }
  if (n < 0) {
    for (let i = 1; i < r; ++i)
      if (t[i] <= e)
        return i;
    return r - 1;
  }
  for (let i = 1; i < r; ++i) {
    if (t[i] == e)
      return i;
    if (t[i] < e)
      return t[i - 1] - e < e - t[i] ? i - 1 : i;
  }
  return r - 1;
}
function hj(t, e, n) {
  for (; e < n; ) {
    const r = t[e];
    t[e] = t[n], t[n] = r, ++e, --n;
  }
}
function pj(t, e) {
  const n = Array.isArray(e) ? e : [e], r = n.length;
  for (let i = 0; i < r; i++)
    t[t.length] = n[i];
}
function QU(t, e) {
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function mj(t, e, n) {
  const r = e || NT;
  return t.every(function(i, s) {
    if (s === 0)
      return !0;
    const o = r(t[s - 1], i);
    return !(o > 0 || o === 0);
  });
}
function gj() {
  return !0;
}
function yj() {
  return !1;
}
function ob() {
}
function _j(t) {
  let e, n, r;
  return function() {
    const i = Array.prototype.slice.call(arguments);
    return (!n || this !== r || !QU(i, n)) && (r = this, n = i, e = t.apply(this, arguments)), e;
  };
}
function Rf(t) {
  function e() {
    let n;
    try {
      n = t();
    } catch (r) {
      return Promise.reject(r);
    }
    return n instanceof Promise ? n : Promise.resolve(n);
  }
  return e();
}
function vp(t) {
  for (const e in t)
    delete t[e];
}
function JU(t) {
  let e;
  for (e in t)
    return !1;
  return !e;
}
class OT {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
class PT extends XU {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, n) {
    if (!e || !n)
      return;
    const r = this.listeners_ || (this.listeners_ = {}), i = r[e] || (r[e] = []);
    i.includes(n) || i.push(n);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const n = typeof e == "string", r = n ? e : e.type, i = this.listeners_ && this.listeners_[r];
    if (!i)
      return;
    const s = n ? new OT(e) : (
      /** @type {Event} */
      e
    );
    s.target || (s.target = this.eventTarget_ || this);
    const o = this.dispatching_ || (this.dispatching_ = {}), a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    r in o || (o[r] = 0, a[r] = 0), ++o[r];
    let l;
    for (let u = 0, d = i.length; u < d; ++u)
      if ("handleEvent" in i[u] ? l = /** @type {import("../events.js").ListenerObject} */
      i[u].handleEvent(s) : l = /** @type {import("../events.js").ListenerFunction} */
      i[u].call(this, s), l === !1 || s.propagationStopped) {
        l = !1;
        break;
      }
    if (--o[r] === 0) {
      let u = a[r];
      for (delete a[r]; u--; )
        this.removeEventListener(r, ob);
      delete o[r];
    }
    return l;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.listeners_ && vp(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, n) {
    if (!this.listeners_)
      return;
    const r = this.listeners_[e];
    if (!r)
      return;
    const i = r.indexOf(n);
    i !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (r[i] = ob, ++this.pendingRemovals_[e]) : (r.splice(i, 1), r.length === 0 && delete this.listeners_[e]));
  }
}
function Cf(t, e, n, r, i) {
  if (i) {
    const o = n;
    n = function(a) {
      return t.removeEventListener(e, n), o.call(r ?? this, a);
    };
  } else r && r !== t && (n = n.bind(r));
  const s = {
    target: t,
    type: e,
    listener: n
  };
  return t.addEventListener(e, n), s;
}
function ab(t, e, n, r) {
  return Cf(t, e, n, r, !0);
}
function cb(t) {
  t && t.target && (t.target.removeEventListener(t.type, t.listener), vp(t));
}
class jl extends PT {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(kT.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, n) {
    if (Array.isArray(e)) {
      const r = e.length, i = new Array(r);
      for (let s = 0; s < r; ++s)
        i[s] = Cf(this, e[s], n);
      return i;
    }
    return Cf(
      this,
      /** @type {string} */
      e,
      n
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, n) {
    let r;
    if (Array.isArray(e)) {
      const i = e.length;
      r = new Array(i);
      for (let s = 0; s < i; ++s)
        r[s] = ab(this, e[s], n);
    } else
      r = ab(
        this,
        /** @type {string} */
        e,
        n
      );
    return n.ol_key = r, r;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, n) {
    const r = (
      /** @type {Object} */
      n.ol_key
    );
    if (r)
      ZU(r);
    else if (Array.isArray(e))
      for (let i = 0, s = e.length; i < s; ++i)
        this.removeEventListener(e[i], n);
    else
      this.removeEventListener(e, n);
  }
}
jl.prototype.on;
jl.prototype.once;
jl.prototype.un;
function ZU(t) {
  if (Array.isArray(t))
    for (let e = 0, n = t.length; e < n; ++e)
      cb(t[e]);
  else
    cb(
      /** @type {import("./events.js").EventsKey} */
      t
    );
}
function eF() {
  throw new Error("Unimplemented abstract method.");
}
let tF = 0;
function xT(t) {
  return t.ol_uid || (t.ol_uid = String(++tF));
}
class lb extends OT {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, n, r) {
    super(e), this.key = n, this.oldValue = r;
  }
}
class nF extends jl {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, xT(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let n;
    return this.values_ && this.values_.hasOwnProperty(e) && (n = this.values_[e]), n;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, n) {
    let r;
    r = `change:${e}`, this.hasListener(r) && this.dispatchEvent(new lb(r, e, n)), r = YU.PROPERTYCHANGE, this.hasListener(r) && this.dispatchEvent(new lb(r, e, n));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, n) {
    this.addEventListener(`change:${e}`, n);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, n) {
    this.removeEventListener(`change:${e}`, n);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, n, r) {
    const i = this.values_ || (this.values_ = {});
    if (r)
      i[e] = n;
    else {
      const s = i[e];
      i[e] = n, s !== n && this.notify(e, s);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, n) {
    for (const r in e)
      this.set(r, e[r], n);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, n) {
    if (this.values_ && e in this.values_) {
      const r = this.values_[e];
      delete this.values_[e], JU(this.values_) && (this.values_ = null), n || this.notify(e, r);
    }
  }
}
function bj(t, e, n) {
  return Math.min(Math.max(t, e), n);
}
function vj(t, e, n, r, i, s) {
  const o = i - n, a = s - r;
  if (o !== 0 || a !== 0) {
    const l = ((t - n) * o + (e - r) * a) / (o * o + a * a);
    l > 1 ? (n = i, r = s) : l > 0 && (n += o * l, r += a * l);
  }
  return rF(t, e, n, r);
}
function rF(t, e, n, r) {
  const i = n - t, s = r - e;
  return i * i + s * s;
}
function Ej(t) {
  const e = t.length;
  for (let r = 0; r < e; r++) {
    let i = r, s = Math.abs(t[r][r]);
    for (let a = r + 1; a < e; a++) {
      const l = Math.abs(t[a][r]);
      l > s && (s = l, i = a);
    }
    if (s === 0)
      return null;
    const o = t[i];
    t[i] = t[r], t[r] = o;
    for (let a = r + 1; a < e; a++) {
      const l = -t[a][r] / t[r][r];
      for (let u = r; u < e + 1; u++)
        r == u ? t[a][u] = 0 : t[a][u] += l * t[r][u];
    }
  }
  const n = new Array(e);
  for (let r = e - 1; r >= 0; r--) {
    n[r] = t[r][e] / t[r][r];
    for (let i = r - 1; i >= 0; i--)
      t[i][e] -= t[i][r] * n[r];
  }
  return n;
}
function ub(t) {
  return t * 180 / Math.PI;
}
function Qi(t) {
  return t * Math.PI / 180;
}
function wj(t, e) {
  const n = t % e;
  return n * e < 0 ? n + e : n;
}
function Tj(t, e, n) {
  return t + n * (e - t);
}
function MT(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
function Ij(t, e) {
  return Math.floor(MT(t, e));
}
function Sj(t, e) {
  return Math.ceil(MT(t, e));
}
function kf(t, e, n) {
  if (t >= e && t < n)
    return t;
  const r = n - e;
  return ((t - e) % r + r) % r + e;
}
const zt = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function Aj(t) {
  const e = DT();
  for (let n = 0, r = t.length; n < r; ++n)
    oF(e, t[n]);
  return e;
}
function iF(t, e, n) {
  const r = Math.min.apply(null, t), i = Math.min.apply(null, e), s = Math.max.apply(null, t), o = Math.max.apply(null, e);
  return ql(r, i, s, o, n);
}
function Rj(t, e, n) {
  return n ? (n[0] = t[0] - e, n[1] = t[1] - e, n[2] = t[2] + e, n[3] = t[3] + e, n) : [
    t[0] - e,
    t[1] - e,
    t[2] + e,
    t[3] + e
  ];
}
function Cj(t, e) {
  return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice();
}
function kj(t, e, n) {
  let r, i;
  return e < t[0] ? r = t[0] - e : t[2] < e ? r = e - t[2] : r = 0, n < t[1] ? i = t[1] - n : t[3] < n ? i = n - t[3] : i = 0, r * r + i * i;
}
function Nj(t, e) {
  return sF(t, e[0], e[1]);
}
function Oj(t, e) {
  return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3];
}
function sF(t, e, n) {
  return t[0] <= e && e <= t[2] && t[1] <= n && n <= t[3];
}
function db(t, e) {
  const n = t[0], r = t[1], i = t[2], s = t[3], o = e[0], a = e[1];
  let l = zt.UNKNOWN;
  return o < n ? l = l | zt.LEFT : o > i && (l = l | zt.RIGHT), a < r ? l = l | zt.BELOW : a > s && (l = l | zt.ABOVE), l === zt.UNKNOWN && (l = zt.INTERSECTING), l;
}
function DT() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function ql(t, e, n, r, i) {
  return i ? (i[0] = t, i[1] = e, i[2] = n, i[3] = r, i) : [t, e, n, r];
}
function Ep(t) {
  return ql(1 / 0, 1 / 0, -1 / 0, -1 / 0, t);
}
function Pj(t, e) {
  const n = t[0], r = t[1];
  return ql(n, r, n, r, e);
}
function xj(t, e, n, r, i) {
  const s = Ep(i);
  return aF(s, t, e, n, r);
}
function Mj(t, e) {
  return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3];
}
function Dj(t, e) {
  return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t;
}
function oF(t, e) {
  e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1]);
}
function aF(t, e, n, r, i) {
  for (; n < r; n += i)
    cF(t, e[n], e[n + 1]);
  return t;
}
function cF(t, e, n) {
  t[0] = Math.min(t[0], e), t[1] = Math.min(t[1], n), t[2] = Math.max(t[2], e), t[3] = Math.max(t[3], n);
}
function Lj(t, e) {
  let n;
  return n = e(LT(t)), n || (n = e(UT(t)), n) || (n = e(VT(t)), n) || (n = e(FT(t)), n) ? n : !1;
}
function Uj(t) {
  let e = 0;
  return BT(t) || (e = io(t) * dF(t)), e;
}
function LT(t) {
  return [t[0], t[1]];
}
function UT(t) {
  return [t[2], t[1]];
}
function lF(t) {
  return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2];
}
function Fj(t, e) {
  let n;
  if (e === "bottom-left")
    n = LT(t);
  else if (e === "bottom-right")
    n = UT(t);
  else if (e === "top-left")
    n = FT(t);
  else if (e === "top-right")
    n = VT(t);
  else
    throw new Error("Invalid corner");
  return n;
}
function Vj(t, e, n, r, i) {
  const [s, o, a, l, u, d, f, p] = uF(
    t,
    e,
    n,
    r
  );
  return ql(
    Math.min(s, a, u, f),
    Math.min(o, l, d, p),
    Math.max(s, a, u, f),
    Math.max(o, l, d, p),
    i
  );
}
function uF(t, e, n, r) {
  const i = e * r[0] / 2, s = e * r[1] / 2, o = Math.cos(n), a = Math.sin(n), l = i * o, u = i * a, d = s * o, f = s * a, p = t[0], g = t[1];
  return [
    p - l + f,
    g - u - d,
    p - l - f,
    g - u + d,
    p + l - f,
    g + u + d,
    p + l + f,
    g + u - d,
    p - l + f,
    g - u - d
  ];
}
function dF(t) {
  return t[3] - t[1];
}
function Bj(t, e, n) {
  const r = n || DT();
  return fF(t, e) ? (t[0] > e[0] ? r[0] = t[0] : r[0] = e[0], t[1] > e[1] ? r[1] = t[1] : r[1] = e[1], t[2] < e[2] ? r[2] = t[2] : r[2] = e[2], t[3] < e[3] ? r[3] = t[3] : r[3] = e[3]) : Ep(r), r;
}
function FT(t) {
  return [t[0], t[3]];
}
function VT(t) {
  return [t[2], t[3]];
}
function io(t) {
  return t[2] - t[0];
}
function fF(t, e) {
  return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1];
}
function BT(t) {
  return t[2] < t[0] || t[3] < t[1];
}
function $j(t, e) {
  return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t;
}
function jj(t, e, n) {
  let r = !1;
  const i = db(t, e), s = db(t, n);
  if (i === zt.INTERSECTING || s === zt.INTERSECTING)
    r = !0;
  else {
    const o = t[0], a = t[1], l = t[2], u = t[3], d = e[0], f = e[1], p = n[0], g = n[1], _ = (g - f) / (p - d);
    let b, m;
    s & zt.ABOVE && !(i & zt.ABOVE) && (b = p - (g - u) / _, r = b >= o && b <= l), !r && s & zt.RIGHT && !(i & zt.RIGHT) && (m = g - (p - l) * _, r = m >= a && m <= u), !r && s & zt.BELOW && !(i & zt.BELOW) && (b = p - (g - a) / _, r = b >= o && b <= l), !r && s & zt.LEFT && !(i & zt.LEFT) && (m = g - (p - o) * _, r = m >= a && m <= u);
  }
  return r;
}
function qj(t, e, n, r) {
  if (BT(t))
    return Ep(n);
  let i = [];
  i = [
    t[0],
    t[1],
    t[2],
    t[1],
    t[2],
    t[3],
    t[0],
    t[3]
  ], e(i, i, 2);
  const s = [], o = [];
  for (let a = 0, l = i.length; a < l; a += 2)
    s.push(i[a]), o.push(i[a + 1]);
  return iF(s, o, n);
}
function hF(t, e) {
  const n = e.getExtent(), r = lF(t);
  if (e.canWrapX() && (r[0] < n[0] || r[0] >= n[2])) {
    const i = io(n), o = Math.floor(
      (r[0] - n[0]) / i
    ) * i;
    t[0] -= o, t[2] -= o;
  }
  return t;
}
function zj(t, e, n) {
  if (e.canWrapX()) {
    const r = e.getExtent();
    if (!isFinite(t[0]) || !isFinite(t[2]))
      return [[r[0], t[1], r[2], t[3]]];
    hF(t, e);
    const i = io(r);
    if (io(t) > i && !n)
      return [[r[0], t[1], r[2], t[3]]];
    if (t[0] < r[0])
      return [
        [t[0] + i, t[1], r[2], t[3]],
        [r[0], t[1], t[2], t[3]]
      ];
    if (t[2] > r[2])
      return [
        [t[0], t[1], r[2], t[3]],
        [r[0], t[1], t[2] - i, t[3]]
      ];
  }
  return [t];
}
function Wj(t, e) {
  return t[0] += +e[0], t[1] += +e[1], t;
}
function pF(t, e) {
  let n = !0;
  for (let r = t.length - 1; r >= 0; --r)
    if (t[r] != e[r]) {
      n = !1;
      break;
    }
  return n;
}
function Gj(t, e) {
  const n = Math.cos(e), r = Math.sin(e), i = t[0] * n - t[1] * r, s = t[1] * n + t[0] * r;
  return t[0] = i, t[1] = s, t;
}
function Hj(t, e) {
  return t[0] *= e, t[1] *= e, t;
}
function Kj(t, e) {
  if (e.canWrapX()) {
    const n = io(e.getExtent()), r = mF(t, e, n);
    r && (t[0] -= r * n);
  }
  return t;
}
function mF(t, e, n) {
  const r = e.getExtent();
  let i = 0;
  return e.canWrapX() && (t[0] < r[0] || t[0] > r[2]) && (n = n || io(r), i = Math.floor(
    (t[0] - r[0]) / n
  )), i;
}
function $T(t) {
  return Math.pow(t, 3);
}
function Yj(t) {
  return 1 - $T(1 - t);
}
function Xj(t) {
  return 3 * t * t - 2 * t * t * t;
}
function Qj(t) {
  return t;
}
const gF = 63710088e-1;
function fb(t, e, n) {
  n = n || gF;
  const r = Qi(t[1]), i = Qi(e[1]), s = (i - r) / 2, o = Qi(e[0] - t[0]) / 2, a = Math.sin(s) * Math.sin(s) + Math.sin(o) * Math.sin(o) * Math.cos(r) * Math.cos(i);
  return 2 * n * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function yF(...t) {
  console.warn(...t);
}
const Nf = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class wp {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || Nf[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {GetPointResolution|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const ka = 6378137, ks = Math.PI * ka, _F = [-ks, -ks, ks, ks], bF = [-180, -85, 180, 85], oc = ka * Math.log(Math.tan(Math.PI / 2));
class vs extends wp {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: _F,
      global: !0,
      worldExtent: bF,
      getPointResolution: function(n, r) {
        return n / Math.cosh(r[1] / ka);
      }
    });
  }
}
const hb = [
  new vs("EPSG:3857"),
  new vs("EPSG:102100"),
  new vs("EPSG:102113"),
  new vs("EPSG:900913"),
  new vs("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new vs("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function vF(t, e, n, r) {
  const i = t.length;
  n = n > 1 ? n : 2, r = r ?? n, e === void 0 && (n > 2 ? e = t.slice() : e = new Array(i));
  for (let s = 0; s < i; s += r) {
    e[s] = ks * t[s] / 180;
    let o = ka * Math.log(Math.tan(Math.PI * (+t[s + 1] + 90) / 360));
    o > oc ? o = oc : o < -oc && (o = -oc), e[s + 1] = o;
  }
  return e;
}
function EF(t, e, n, r) {
  const i = t.length;
  n = n > 1 ? n : 2, r = r ?? n, e === void 0 && (n > 2 ? e = t.slice() : e = new Array(i));
  for (let s = 0; s < i; s += r)
    e[s] = 180 * t[s] / ks, e[s + 1] = 360 * Math.atan(Math.exp(t[s + 1] / ka)) / Math.PI - 90;
  return e;
}
const wF = 6378137, pb = [-180, -90, 180, 90], TF = Math.PI * wF / 180;
class Fi extends wp {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, n) {
    super({
      code: e,
      units: "degrees",
      extent: pb,
      axisOrientation: n,
      global: !0,
      metersPerUnit: TF,
      worldExtent: pb
    });
  }
}
const mb = [
  new Fi("CRS:84"),
  new Fi("EPSG:4326", "neu"),
  new Fi("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Fi("urn:ogc:def:crs:OGC:2:84"),
  new Fi("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Fi("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Fi("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let Of = {};
function IF(t) {
  return Of[t] || Of[t.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function SF(t, e) {
  Of[t] = e;
}
let js = {};
function la(t, e, n) {
  const r = t.getCode(), i = e.getCode();
  r in js || (js[r] = {}), js[r][i] = n;
}
function _d(t, e) {
  return t in js && e in js[t] ? js[t][e] : null;
}
const tl = 0.9996, jn = 669438e-8, zl = jn * jn, Wl = zl * jn, Gi = jn / (1 - jn), gb = Math.sqrt(1 - jn), so = (1 - gb) / (1 + gb), jT = so * so, Tp = jT * so, Ip = Tp * so, qT = Ip * so, zT = 1 - jn / 4 - 3 * zl / 64 - 5 * Wl / 256, AF = 3 * jn / 8 + 3 * zl / 32 + 45 * Wl / 1024, RF = 15 * zl / 256 + 45 * Wl / 1024, CF = 35 * Wl / 3072, kF = 3 / 2 * so - 27 / 32 * Tp + 269 / 512 * qT, NF = 21 / 16 * jT - 55 / 32 * Ip, OF = 151 / 96 * Tp - 417 / 128 * qT, PF = 1097 / 512 * Ip, nl = 6378137;
function xF(t, e, n) {
  const r = t - 5e5, o = (n.north ? e : e - 1e7) / tl / (nl * zT), a = o + kF * Math.sin(2 * o) + NF * Math.sin(4 * o) + OF * Math.sin(6 * o) + PF * Math.sin(8 * o), l = Math.sin(a), u = l * l, d = Math.cos(a), f = l / d, p = f * f, g = p * p, _ = 1 - jn * u, b = Math.sqrt(1 - jn * u), m = nl / b, v = (1 - jn) / _, C = Gi * d ** 2, x = C * C, P = r / (m * tl), k = P * P, U = k * P, I = U * P, E = I * P, T = E * P, A = a - f / v * (k / 2 - I / 24 * (5 + 3 * p + 10 * C - 4 * x - 9 * Gi)) + T / 720 * (61 + 90 * p + 298 * C + 45 * g - 252 * Gi - 3 * x);
  let R = (P - U / 6 * (1 + 2 * p + C) + E / 120 * (5 - 2 * C + 28 * p - 3 * x + 8 * Gi + 24 * g)) / d;
  return R = kf(
    R + Qi(WT(n.number)),
    -Math.PI,
    Math.PI
  ), [ub(R), ub(A)];
}
const yb = -80, _b = 84, MF = -180, DF = 180;
function LF(t, e, n) {
  t = kf(t, MF, DF), e < yb ? e = yb : e > _b && (e = _b);
  const r = Qi(e), i = Math.sin(r), s = Math.cos(r), o = i / s, a = o * o, l = a * a, u = Qi(t), d = WT(n.number), f = Qi(d), p = nl / Math.sqrt(1 - jn * i ** 2), g = Gi * s ** 2, _ = s * kf(u - f, -Math.PI, Math.PI), b = _ * _, m = b * _, v = m * _, C = v * _, x = C * _, P = nl * (zT * r - AF * Math.sin(2 * r) + RF * Math.sin(4 * r) - CF * Math.sin(6 * r)), k = tl * p * (_ + m / 6 * (1 - a + g) + C / 120 * (5 - 18 * a + l + 72 * g - 58 * Gi)) + 5e5;
  let U = tl * (P + p * o * (b / 2 + v / 24 * (5 - a + 9 * g + 4 * g ** 2) + x / 720 * (61 - 58 * a + l + 600 * g - 330 * Gi)));
  return n.north || (U += 1e7), [k, U];
}
function WT(t) {
  return (t - 1) * 6 - 180 + 3;
}
const UF = [
  /^EPSG:(\d+)$/,
  /^urn:ogc:def:crs:EPSG::(\d+)$/,
  /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
];
function GT(t) {
  let e = 0;
  for (const i of UF) {
    const s = t.match(i);
    if (s) {
      e = parseInt(s[1]);
      break;
    }
  }
  if (!e)
    return null;
  let n = 0, r = !1;
  return e > 32700 && e < 32761 ? n = e - 32700 : e > 32600 && e < 32661 && (r = !0, n = e - 32600), n ? { number: n, north: r } : null;
}
function bb(t, e) {
  return function(n, r, i, s) {
    const o = n.length;
    i = i > 1 ? i : 2, s = s ?? i, r || (i > 2 ? r = n.slice() : r = new Array(o));
    for (let a = 0; a < o; a += s) {
      const l = n[a], u = n[a + 1], d = t(l, u, e);
      r[a] = d[0], r[a + 1] = d[1];
    }
    return r;
  };
}
function FF(t) {
  return GT(t) ? new wp({ code: t, units: "m" }) : null;
}
function VF(t) {
  const e = GT(t.getCode());
  return e ? {
    forward: bb(LF, e),
    inverse: bb(xF, e)
  } : null;
}
const BF = [VF], $F = [FF];
let Pf = !0;
function jF(t) {
  Pf = !1;
}
function Sp(t, e) {
  if (e !== void 0) {
    for (let n = 0, r = t.length; n < r; ++n)
      e[n] = t[n];
    e = e;
  } else
    e = t.slice();
  return e;
}
function xf(t) {
  SF(t.getCode(), t), la(t, t, Sp);
}
function qF(t) {
  t.forEach(xf);
}
function ki(t) {
  if (typeof t != "string")
    return t;
  const e = IF(t);
  if (e)
    return e;
  for (const n of $F) {
    const r = n(t);
    if (r)
      return r;
  }
  return null;
}
function Jj(t, e, n, r) {
  t = ki(t);
  let i;
  const s = t.getPointResolutionFunc();
  if (s) {
    if (i = s(e, n), r && r !== t.getUnits()) {
      const o = t.getMetersPerUnit();
      o && (i = i * o / Nf[r]);
    }
  } else {
    const o = t.getUnits();
    if (o == "degrees" && !r || r == "degrees")
      i = e;
    else {
      const a = Ap(
        t,
        ki("EPSG:4326")
      );
      if (!a && o !== "degrees")
        i = e * t.getMetersPerUnit();
      else {
        let u = [
          n[0] - e / 2,
          n[1],
          n[0] + e / 2,
          n[1],
          n[0],
          n[1] - e / 2,
          n[0],
          n[1] + e / 2
        ];
        u = a(u, u, 2);
        const d = fb(u.slice(0, 2), u.slice(2, 4)), f = fb(u.slice(4, 6), u.slice(6, 8));
        i = (d + f) / 2;
      }
      const l = r ? Nf[r] : t.getMetersPerUnit();
      l !== void 0 && (i /= l);
    }
  }
  return i;
}
function vb(t) {
  qF(t), t.forEach(function(e) {
    t.forEach(function(n) {
      e !== n && la(e, n, Sp);
    });
  });
}
function zF(t, e, n, r) {
  t.forEach(function(i) {
    e.forEach(function(s) {
      la(i, s, n), la(s, i, r);
    });
  });
}
function Zj(t, e) {
  return t ? typeof t == "string" ? ki(t) : (
    /** @type {Projection} */
    t
  ) : ki(e);
}
function e9(t) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */
    function(e, n, r, i) {
      const s = e.length;
      r = r !== void 0 ? r : 2, i = i ?? r, n = n !== void 0 ? n : new Array(s);
      for (let o = 0; o < s; o += i) {
        const a = t(e.slice(o, o + r)), l = a.length;
        for (let u = 0, d = i; u < d; ++u)
          n[o + u] = u >= l ? e[o + u] : a[u];
      }
      return n;
    }
  );
}
function t9(t, e) {
  return jF(), GF(
    t,
    "EPSG:4326",
    e !== void 0 ? e : "EPSG:3857"
  );
}
function n9(t, e) {
  if (t === e)
    return !0;
  const n = t.getUnits() === e.getUnits();
  return (t.getCode() === e.getCode() || Ap(t, e) === Sp) && n;
}
function Ap(t, e) {
  const n = t.getCode(), r = e.getCode();
  let i = _d(n, r);
  if (i)
    return i;
  let s = null, o = null;
  for (const l of BF)
    s || (s = l(t)), o || (o = l(e));
  if (!s && !o)
    return null;
  const a = "EPSG:4326";
  if (o)
    if (s)
      i = bd(
        s.inverse,
        o.forward
      );
    else {
      const l = _d(n, a);
      l && (i = bd(
        l,
        o.forward
      ));
    }
  else {
    const l = _d(a, r);
    l && (i = bd(
      s.inverse,
      l
    ));
  }
  return i && (xf(t), xf(e), la(t, e, i)), i;
}
function bd(t, e) {
  return function(n, r, i, s) {
    return r = t(n, r, i, s), e(r, r, i, s);
  };
}
function WF(t, e) {
  const n = ki(t), r = ki(e);
  return Ap(n, r);
}
function GF(t, e, n) {
  const r = WF(e, n);
  if (!r) {
    const i = ki(e).getCode(), s = ki(n).getCode();
    throw new Error(
      `No transform available between ${i} and ${s}`
    );
  }
  return r(t, void 0, t.length);
}
let HF = null;
function r9() {
  return HF;
}
function i9(t, e) {
  return t;
}
function s9(t, e) {
  return Pf && !pF(t, [0, 0]) && t[0] >= -180 && t[0] <= 180 && t[1] >= -90 && t[1] <= 90 && (Pf = !1, yF(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), t;
}
function o9(t, e) {
  return t;
}
function a9(t, e) {
  return t;
}
function KF() {
  vb(hb), vb(mb), zF(
    mb,
    hb,
    vF,
    EF
  );
}
KF();
const c9 = "ol-hidden", l9 = "ol-unselectable", u9 = "ol-control", d9 = "ol-collapsed", YF = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z0-9]+?)\\s*$`
  ].join(""),
  "i"
), Eb = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], HT = function(t) {
  const e = t.match(YF);
  if (!e)
    return null;
  const n = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let r = 0, i = Eb.length; r < i; ++r) {
    const s = e[r + 1];
    s !== void 0 && (n[Eb[r]] = s);
  }
  return n.families = n.family.split(/,\s?/), n;
}, as = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", XF = as.includes("safari") && !as.includes("chrom");
XF && (as.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(as));
const f9 = as.includes("webkit") && !as.includes("edge"), h9 = as.includes("macintosh"), p9 = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, KT = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, m9 = typeof Image < "u" && Image.prototype.decode, g9 = typeof createImageBitmap == "function", y9 = function() {
  let t = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        t = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return t;
}();
function YT(t, e, n, r) {
  let i;
  return n && n.length ? i = /** @type {HTMLCanvasElement} */
  n.shift() : KT ? i = new OffscreenCanvas(t || 300, e || 300) : i = document.createElement("canvas"), t && (i.width = t), e && (i.height = e), /** @type {CanvasRenderingContext2D} */
  i.getContext("2d", r);
}
let vd;
function _9() {
  return vd || (vd = YT(1, 1)), vd;
}
function b9(t) {
  const e = t.canvas;
  e.width = 1, e.height = 1, t.clearRect(0, 0, 1, 1);
}
function v9(t, e) {
  const n = e.parentNode;
  n && n.replaceChild(t, e);
}
function E9(t) {
  for (; t.lastChild; )
    t.lastChild.remove();
}
function w9(t, e) {
  const n = t.childNodes;
  for (let r = 0; ; ++r) {
    const i = n[r], s = e[r];
    if (!i && !s)
      break;
    if (i !== s) {
      if (!i) {
        t.appendChild(s);
        continue;
      }
      if (!s) {
        t.removeChild(i), --r;
        continue;
      }
      t.insertBefore(s, i);
    }
  }
}
const Zn = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
}, T9 = "10px sans-serif", I9 = "#000", S9 = "round", A9 = [], R9 = 0, C9 = "round", k9 = 10, N9 = "#000", O9 = "center", P9 = "middle", x9 = [0, 0, 0, 0], M9 = 1, Lr = new nF();
let Ss = null, Mf;
const Df = {}, QF = function() {
  const e = "32px ", n = ["monospace", "serif"], r = n.length, i = "wmytzilWMYTZIL@#/&?$%10";
  let s, o;
  function a(u, d, f) {
    let p = !0;
    for (let g = 0; g < r; ++g) {
      const _ = n[g];
      if (o = rl(
        u + " " + d + " " + e + _,
        i
      ), f != _) {
        const b = rl(
          u + " " + d + " " + e + f + "," + _,
          i
        );
        p = p && b != o;
      }
    }
    return !!p;
  }
  function l() {
    let u = !0;
    const d = Lr.getKeys();
    for (let f = 0, p = d.length; f < p; ++f) {
      const g = d[f];
      if (Lr.get(g) < 100) {
        const [_, b, m] = g.split(`
`);
        a(_, b, m) ? (vp(Df), Ss = null, Mf = void 0, Lr.set(g, 100)) : (Lr.set(g, Lr.get(g) + 1, !0), u = !1);
      }
    }
    u && (clearInterval(s), s = void 0);
  }
  return function(u) {
    const d = HT(u);
    if (!d)
      return;
    const f = d.families;
    for (let p = 0, g = f.length; p < g; ++p) {
      const _ = f[p], b = d.style + `
` + d.weight + `
` + _;
      Lr.get(b) === void 0 && (Lr.set(b, 100, !0), a(d.style, d.weight, _) || (Lr.set(b, 0, !0), s === void 0 && (s = setInterval(l, 32))));
    }
  };
}(), JF = /* @__PURE__ */ function() {
  let t;
  return function(e) {
    let n = Df[e];
    if (n == null) {
      if (KT) {
        const r = HT(e), i = XT(e, "g");
        n = (isNaN(Number(r.lineHeight)) ? 1.2 : Number(r.lineHeight)) * (i.actualBoundingBoxAscent + i.actualBoundingBoxDescent);
      } else
        t || (t = document.createElement("div"), t.innerHTML = "M", t.style.minHeight = "0", t.style.maxHeight = "none", t.style.height = "auto", t.style.padding = "0", t.style.border = "none", t.style.position = "absolute", t.style.display = "block", t.style.left = "-99999px"), t.style.font = e, document.body.appendChild(t), n = t.offsetHeight, document.body.removeChild(t);
      Df[e] = n;
    }
    return n;
  };
}();
function XT(t, e) {
  return Ss || (Ss = YT(1, 1)), t != Mf && (Ss.font = t, Mf = Ss.font), Ss.measureText(e);
}
function rl(t, e) {
  return XT(t, e).width;
}
function D9(t, e, n) {
  if (e in n)
    return n[e];
  const r = e.split(`
`).reduce((i, s) => Math.max(i, rl(t, s)), 0);
  return n[e] = r, r;
}
function L9(t, e) {
  const n = [], r = [], i = [];
  let s = 0, o = 0, a = 0, l = 0;
  for (let u = 0, d = e.length; u <= d; u += 2) {
    const f = e[u];
    if (f === `
` || u === d) {
      s = Math.max(s, o), i.push(o), o = 0, a += l, l = 0;
      continue;
    }
    const p = e[u + 1] || t.font, g = rl(p, f);
    n.push(g), o += g;
    const _ = JF(p);
    r.push(_), l = Math.max(l, _);
  }
  return { width: s, height: a, widths: n, heights: r, lineWidths: i };
}
function U9(t, e, n, r, i, s, o, a, l, u, d) {
  t.save(), n !== 1 && (t.globalAlpha === void 0 ? t.globalAlpha = (f) => f.globalAlpha *= n : t.globalAlpha *= n), e && t.transform.apply(t, e), /** @type {*} */
  r.contextInstructions ? (t.translate(l, u), t.scale(d[0], d[1]), ZF(
    /** @type {Label} */
    r,
    t
  )) : d[0] < 0 || d[1] < 0 ? (t.translate(l, u), t.scale(d[0], d[1]), t.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    r,
    i,
    s,
    o,
    a,
    0,
    0,
    o,
    a
  )) : t.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    r,
    i,
    s,
    o,
    a,
    l,
    u,
    o * d[0],
    a * d[1]
  ), t.restore();
}
function ZF(t, e) {
  const n = t.contextInstructions;
  for (let r = 0, i = n.length; r < i; r += 2)
    Array.isArray(n[r + 1]) ? e[n[r]].apply(
      e,
      n[r + 1]
    ) : e[n[r]] = n[r + 1];
}
class eV extends PT {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, n, r) {
    super(), r = r || {}, this.tileCoord = e, this.state = n, this.key = "", this.transition_ = r.transition === void 0 ? 250 : r.transition, this.transitionStarts_ = {}, this.interpolate = !!r.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(kT.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.setState(Zn.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== Zn.EMPTY) {
      if (this.state !== Zn.ERROR && this.state > e)
        throw new Error("Tile load sequence violation");
      this.state = e, this.changed();
    }
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    eF();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, n) {
    if (!this.transition_)
      return 1;
    let r = this.transitionStarts_[e];
    if (!r)
      r = n, this.transitionStarts_[e] = r;
    else if (r === -1)
      return 1;
    const i = n - r + 1e3 / 60;
    return i >= this.transition_ ? 1 : $T(i / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
  /**
   * @override
   */
  disposeInternal() {
    this.release(), super.disposeInternal();
  }
}
let tV = class extends eV {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default<FeatureType>} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, n, r, i, s, o) {
    super(e, n, o), this.extent = null, this.format_ = i, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = s, this.url_ = r, this.key = r;
  }
  /**
   * @return {string} Tile url.
   */
  getTileUrl() {
    return this.url_;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default<FeatureType>} Feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    this.state == Zn.IDLE && (this.setState(Zn.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
  }
  /**
   * Handler for successful tile load.
   * @param {Array<FeatureType>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */
  onLoad(e, n) {
    this.setFeatures(e);
  }
  /**
   * Handler for tile load errors.
   */
  onError() {
    this.setState(Zn.ERROR);
  }
  /**
   * Function for use in a {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<FeatureType>} features Features.
   * @api
   */
  setFeatures(e) {
    this.features_ = e, this.setState(Zn.LOADED);
  }
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader<FeatureType>} loader Feature loader.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
};
var wb = {
  thin: 100,
  hairline: 100,
  "ultra-light": 200,
  "extra-light": 200,
  light: 300,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  "semi-bold": 600,
  "demi-bold": 600,
  bold: 700,
  "extra-bold": 800,
  "ultra-bold": 800,
  heavy: 900,
  black: 900,
  "heavy-black": 900,
  fat: 900,
  poster: 900,
  "ultra-black": 950,
  "extra-black": 950
}, Co = " ", Tb = /(italic|oblique)$/i, Ib = {};
function nV(t, e, n) {
  var r = Ib[t];
  if (!r) {
    Array.isArray(t) || (t = [t]);
    for (var i = 400, s = "normal", o = [], a, l, u = 0, d = t.length; u < d; ++u) {
      var f = t[u], p = f.split(" "), g = p[p.length - 1].toLowerCase();
      g == "normal" || g == "italic" || g == "oblique" ? (s = l ? s : g, l = !0, p.pop(), g = p[p.length - 1].toLowerCase()) : Tb.test(g) && (g = g.replace(Tb, ""), s = l ? s : p[p.length - 1].replace(g, ""), l = !0);
      for (var _ in wb) {
        var b = p.length > 1 ? p[p.length - 2].toLowerCase() : "";
        if (g == _ || g == _.replace("-", "") || b + "-" + g == _) {
          i = a ? i : wb[_], p.pop(), b && _.startsWith(b) && p.pop();
          break;
        }
      }
      !a && typeof g == "number" && (i = g, a = !0);
      var m = p.join(Co).replace("Klokantech Noto Sans", "Noto Sans");
      m.indexOf(Co) !== -1 && (m = '"' + m + '"'), o.push(m);
    }
    r = Ib[t] = [s, i, o];
  }
  return r[0] + Co + r[1] + Co + e + "px" + (n ? "/" + n : "") + Co + r[2];
}
const QT = "https://api.mapbox.com";
function Rp(t) {
  const e = "mapbox://";
  return t.indexOf(e) !== 0 ? "" : t.slice(e.length);
}
function V9(t, e, n) {
  if (typeof t == "string")
    return [
      {
        id: "default",
        url: Sb(t, e, n)
      }
    ];
  for (const r of t)
    r.url = Sb(r.url, e, n);
  return t;
}
function Sb(t, e, n) {
  const r = Rp(t);
  if (!r)
    return decodeURI(new URL(t, n).href);
  const i = "sprites/";
  if (r.indexOf(i) !== 0)
    throw new Error(`unexpected sprites url: ${t}`);
  const s = r.slice(i.length);
  return `${QT}/styles/v1/${s}/sprite?access_token=${e}`;
}
function rV(t, e) {
  const n = Rp(t);
  if (!n)
    return decodeURI(new URL(t, location.href).href);
  const r = "styles/";
  if (n.indexOf(r) !== 0)
    throw new Error(`unexpected style url: ${t}`);
  const i = n.slice(r.length);
  return `${QT}/styles/v1/${i}?&access_token=${e}`;
}
const iV = ["a", "b", "c", "d"];
function Ed(t, e, n, r) {
  const i = new URL(t, r || location.href), s = Rp(t);
  if (!s)
    return e ? (i.searchParams.has(n) || i.searchParams.set(n, e), [decodeURI(i.href)]) : [decodeURI(i.href)];
  if (s === "mapbox.satellite") {
    const o = window.devicePixelRatio >= 1.5 ? "@2x" : "";
    return [
      `https://api.mapbox.com/v4/${s}/{z}/{x}/{y}${o}.webp?access_token=${e}`
    ];
  }
  return iV.map(
    (o) => `https://${o}.tiles.mapbox.com/v4/${s}/{z}/{x}/{y}.vector.pbf?access_token=${e}`
  );
}
const Ab = {}, Rb = {};
let sV = 0;
function Cp(t) {
  return t.id || (t.id = sV++), t.id;
}
function B9(t, e) {
  return Cp(t) + "." + xT(e);
}
function $9(t) {
  let e = Ab[t.id];
  return e || (e = {}, Ab[Cp(t)] = e), e;
}
function j9(t) {
  let e = Rb[t.id];
  return e || (e = {}, Rb[Cp(t)] = e), e;
}
function q9(t) {
  return t * Math.PI / 180;
}
const z9 = function() {
  const t = [];
  for (let e = 78271.51696402048; t.length <= 24; e /= 2)
    t.push(e);
  return t;
}();
function kp(t, e) {
  if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof OffscreenCanvas < "u")
    return (
      /** @type {?} */
      new OffscreenCanvas(t, e)
    );
  const n = document.createElement("canvas");
  return n.width = t, n.height = e, n;
}
function W9(t, e) {
  let n = 0;
  const r = e.length;
  for (; n < r; ++n)
    if (e[n] < t && n + 1 < r) {
      const s = e[n] / e[n + 1];
      return n + Math.log(e[n] / t) / Math.log(s);
    }
  return r - 1;
}
function G9(t, e) {
  const n = Math.floor(t), r = Math.pow(2, t - n);
  return e[n] / r;
}
const Es = {};
function JT(t, e, n = {}, r) {
  if (e in Es)
    return r && (r.url = Es[e][0].url), Es[e][1];
  const i = n.transformRequest && n.transformRequest(e, t) || e, s = function(l) {
    return delete Es[e], Promise.reject(new Error("Error fetching source " + e));
  }, o = function(l) {
    return delete Es[e], l.ok ? l.json() : Promise.reject(new Error("Error fetching source " + e));
  }, a = Rf(() => i).then((l) => l instanceof Response ? (r && (r.url = l.url), o(l)) : (l instanceof Request || (l = new Request(l)), l.headers.get("Accept") || l.headers.set("Accept", "application/json"), r && (r.url = l.url), fetch(l).then(o).catch(s))).catch(s);
  return Es[e] = [i, a], a;
}
function H9(t, e) {
  if (typeof t == "string")
    if (t.trim().startsWith("{"))
      try {
        const n = JSON.parse(t);
        return Promise.resolve(n);
      } catch (n) {
        return Promise.reject(n);
      }
    else
      return t = rV(t, e.accessToken), JT("Style", t, e);
  else
    return Promise.resolve(t);
}
const Cb = {};
function K9(t, e, n = {}) {
  const r = [e, JSON.stringify(t)].toString();
  let i = Cb[r];
  if (!i || n.transformRequest) {
    let s;
    n.transformRequest && (s = (a, l) => {
      const u = n.transformRequest && n.transformRequest(l, "Tiles") || l;
      if (a instanceof tV)
        a.setLoader((d, f, p) => {
          const g = function(_) {
            _.arrayBuffer().then((b) => {
              const v = a.getFormat().readFeatures(b, {
                extent: d,
                featureProjection: p
              });
              a.setFeatures(v);
            });
          };
          Rf(() => u).then((_) => {
            if (_ instanceof Response)
              return g(_);
            fetch(_).then(g).catch((b) => a.setState(Zn.ERROR));
          }).catch((_) => a.setState(Zn.ERROR));
        });
      else {
        const d = a.getImage();
        Rf(() => u).then((f) => {
          if (typeof f == "string") {
            d.src = f;
            return;
          }
          const p = (g) => g.blob().then((_) => {
            const b = URL.createObjectURL(_);
            d.addEventListener("load", () => URL.revokeObjectURL(b)), d.addEventListener("error", () => URL.revokeObjectURL(b)), d.src = b;
          });
          if (f instanceof Response)
            return p(f);
          fetch(f).then(p).catch((g) => a.setState(Zn.ERROR));
        }).catch((f) => a.setState(Zn.ERROR));
      }
    });
    const o = t.url;
    if (o && !t.tiles) {
      const a = Ed(
        o,
        n.accessToken,
        n.accessTokenParam || "access_token",
        e || location.href
      );
      if (o.startsWith("mapbox://"))
        i = Promise.resolve({
          tileJson: Object.assign({}, t, {
            url: void 0,
            tiles: a
          }),
          tileLoadFunction: s
        });
      else {
        const l = {};
        i = JT(
          "Source",
          a[0],
          n,
          l
        ).then(function(u) {
          return u.tiles = u.tiles.map(function(d) {
            return u.scheme === "tms" && (d = d.replace("{y}", "{-y}")), Ed(
              d,
              n.accessToken,
              n.accessTokenParam || "access_token",
              l.url
            )[0];
          }), Promise.resolve({ tileJson: u, tileLoadFunction: s });
        });
      }
    } else t.tiles ? (t = Object.assign({}, t, {
      tiles: t.tiles.map(function(a) {
        return t.scheme === "tms" && (a = a.replace("{y}", "{-y}")), Ed(
          a,
          n.accessToken,
          n.accessTokenParam || "access_token",
          e || location.href
        )[0];
      })
    }), i = Promise.resolve({
      tileJson: Object.assign({}, t),
      tileLoadFunction: s
    })) : i = Promise.reject(new Error("source has no `tiles` nor `url`"));
    Cb[r] = i;
  }
  return i;
}
function Y9(t, e, n, r) {
  const i = [
    2 * n * e.pixelRatio + e.width,
    2 * n * e.pixelRatio + e.height
  ], s = kp(i[0], i[1]), o = s.getContext("2d");
  o.drawImage(
    t,
    e.x,
    e.y,
    e.width,
    e.height,
    n * e.pixelRatio,
    n * e.pixelRatio,
    e.width,
    e.height
  );
  const a = o.getImageData(0, 0, i[0], i[1]);
  o.globalCompositeOperation = "destination-over", o.fillStyle = `rgba(${r.r * 255},${r.g * 255},${r.b * 255},${r.a})`;
  const l = a.data;
  for (let u = 0, d = a.width; u < d; ++u)
    for (let f = 0, p = a.height; f < p; ++f) {
      const g = (f * d + u) * 4;
      l[g + 3] > 0 && o.arc(
        u,
        f,
        n * e.pixelRatio,
        0,
        2 * Math.PI
      );
    }
  return o.fill(), s;
}
function oV(t, e, n) {
  const r = Math.max(0, Math.min(1, (n - t) / (e - t)));
  return r * r * (3 - 2 * r);
}
function X9(t, e, n) {
  const r = kp(e.width, e.height), i = r.getContext("2d");
  i.drawImage(
    t,
    e.x,
    e.y,
    e.width,
    e.height,
    0,
    0,
    e.width,
    e.height
  );
  const s = i.getImageData(0, 0, e.width, e.height), o = s.data;
  for (let a = 0, l = s.width; a < l; ++a)
    for (let u = 0, d = s.height; u < d; ++u) {
      const f = (u * l + a) * 4, p = o[f + 3] / 255, g = 0.75, _ = 0.1, b = oV(g - _, g + _, p);
      b > 0 ? (o[f + 0] = Math.round(255 * n.r * b), o[f + 1] = Math.round(255 * n.g * b), o[f + 2] = Math.round(255 * n.b * b), o[f + 3] = Math.round(255 * b)) : o[f + 3] = 0;
    }
  return i.putImageData(s, 0, 0), r;
}
const aV = Array(256).join("");
function cV(t, e) {
  if (e >= 0.05) {
    let n = "";
    const r = t.split(`
`), i = aV.slice(
      0,
      Math.round(e / 0.1)
    );
    for (let s = 0, o = r.length; s < o; ++s)
      s > 0 && (n += `
`), n += r[s].split("").join(i);
    return n;
  }
  return t;
}
let wd;
function ZT() {
  return wd || (wd = kp(1, 1).getContext("2d")), wd;
}
function Vi(t, e) {
  return ZT().measureText(t).width + (t.length - 1) * e;
}
const kb = {};
function lV(t, e, n, r) {
  if (t.indexOf(`
`) !== -1) {
    const o = t.split(`
`), a = [];
    for (let l = 0, u = o.length; l < u; ++l)
      a.push(lV(o[l], e, n, r));
    return a.join(`
`);
  }
  const i = n + "," + e + "," + t + "," + r;
  let s = kb[i];
  if (!s) {
    const o = t.split(" ");
    if (o.length > 1) {
      const a = ZT();
      a.font = e;
      const u = a.measureText("M").width * n;
      let d = "";
      const f = [];
      for (let p = 0, g = o.length; p < g; ++p) {
        const _ = o[p], b = d + (d ? " " : "") + _;
        Vi(b, r) <= u ? d = b : (d && f.push(d), d = _);
      }
      d && f.push(d);
      for (let p = 0, g = f.length; p < g && g > 1; ++p) {
        const _ = f[p];
        if (Vi(_, r) < u * 0.35) {
          const b = p > 0 ? Vi(f[p - 1], r) : 1 / 0, m = p < g - 1 ? Vi(f[p + 1], r) : 1 / 0;
          f.splice(p, 1), g -= 1, b < m ? (f[p - 1] += " " + _, p -= 1) : f[p] = _ + " " + f[p];
        }
      }
      for (let p = 0, g = f.length - 1; p < g; ++p) {
        const _ = f[p], b = f[p + 1];
        if (Vi(_, r) > u * 0.7 && Vi(b, r) < u * 0.6) {
          const m = _.split(" "), v = m.pop();
          Vi(v, r) < u * 0.2 && (f[p] = m.join(" "), f[p + 1] = v + " " + b), g -= 1;
        }
      }
      s = f.join(`
`);
    } else
      s = t;
    s = cV(s, r), kb[i] = s;
  }
  return s;
}
const uV = /font-family: ?([^;]*);/, dV = /("|')/g;
let ac;
function fV(t) {
  if (!ac) {
    ac = {};
    const e = document.styleSheets;
    for (let n = 0, r = e.length; n < r; ++n) {
      const i = (
        /** @type {CSSStyleSheet} */
        e[n]
      );
      try {
        const s = i.rules || i.cssRules;
        if (s)
          for (let o = 0, a = s.length; o < a; ++o) {
            const l = s[o];
            if (l.type == 5) {
              const u = l.cssText.match(uV);
              ac[u[1].replace(dV, "")] = !0;
            }
          }
      } catch {
      }
    }
  }
  return t in ac;
}
const Td = {};
function Q9(t, e = "https://cdn.jsdelivr.net/npm/@fontsource/{font-family}/{fontweight}{-fontstyle}.css") {
  const n = t.toString();
  if (n in Td)
    return Td[n];
  const r = [];
  for (let i = 0, s = t.length; i < s; ++i) {
    t[i] = t[i].replace("Arial Unicode MS", "Arial");
    const o = t[i], a = nV(o, 1);
    QF(a);
    const l = a.split(" ");
    r.push([
      l.slice(3).join(" ").replace(/"/g, ""),
      l[1],
      l[0]
    ]);
  }
  for (let i = 0, s = r.length; i < s; ++i) {
    const o = r[i], a = o[0];
    if (!fV(a) && Lr.get(
      `${o[2]}
${o[1]} 
${a}`
    ) !== 100) {
      const l = e.replace("{font-family}", a.replace(/ /g, "-").toLowerCase()).replace("{Font+Family}", a.replace(/ /g, "+")).replace("{fontweight}", o[1]).replace(
        "{-fontstyle}",
        o[2].replace("normal", "").replace(/(.+)/, "-$1")
      ).replace("{fontstyle}", o[2]);
      if (!document.querySelector('link[href="' + l + '"]')) {
        const u = document.createElement("link");
        u.href = l, u.rel = "stylesheet", document.head.appendChild(u);
      }
    }
  }
  return Td[n] = t, t;
}
const J9 = Me.forwardRef(({ list: t, style: e, className: n, ...r }, i) => {
  const s = vn();
  return /* @__PURE__ */ he(
    "div",
    {
      ...r,
      ref: i,
      className: Yt("flex flex-col border border-transparent border-solid rounded-lg", n),
      style: {
        ...s("secondary.background", {
          borderColor: "borders"
        }),
        ...e
      },
      children: /* @__PURE__ */ he(
        AT,
        {
          list: t.filter(Boolean).map((o, a) => /* @__PURE__ */ he(Si, { children: o }, a)),
          joinComponent: /* @__PURE__ */ he(aU, {})
        }
      )
    }
  );
}), Z9 = ({ title: t, rightSide: e }) => /* @__PURE__ */ bn("div", { className: "flex justify-between items-center p-2", children: [
  /* @__PURE__ */ he("h1", { className: "text-3xl truncate capitalize", children: t }),
  /* @__PURE__ */ he("div", { className: "flex items-center gap-1", children: e })
] });
export {
  r2 as $,
  DR as A,
  UB as B,
  CT as C,
  qB as D,
  Si as E,
  c2 as F,
  LB as G,
  ui as H,
  ci as I,
  li as J,
  DB as K,
  NB as L,
  OB as M,
  MB as N,
  CB as O,
  Ds as P,
  PB as Q,
  kB as R,
  xB as S,
  di as T,
  ZB as U,
  e2 as V,
  $w as W,
  QB as X,
  JB as Y,
  t2 as Z,
  a2 as _,
  Vs as a,
  _D as a$,
  n2 as a0,
  o2 as a1,
  s2 as a2,
  i2 as a3,
  WB as a4,
  HB as a5,
  GB as a6,
  oo as a7,
  l2 as a8,
  u2 as a9,
  hi as aA,
  ej as aB,
  bp as aC,
  AT as aD,
  E_ as aE,
  po as aF,
  ij as aG,
  aU as aH,
  Er as aI,
  UV as aJ,
  uv as aK,
  r$ as aL,
  s$ as aM,
  uA as aN,
  D$ as aO,
  G2 as aP,
  ID as aQ,
  z$ as aR,
  X2 as aS,
  F2 as aT,
  m$ as aU,
  iU as aV,
  RT as aW,
  j2 as aX,
  SB as aY,
  sp as aZ,
  oj as a_,
  $t as aa,
  d2 as ab,
  f2 as ac,
  h2 as ad,
  m2 as ae,
  p2 as af,
  W2 as ag,
  Vo as ah,
  vV as ai,
  wV as aj,
  IV as ak,
  AV as al,
  C2 as am,
  fa as an,
  mi as ao,
  LV as ap,
  J$ as aq,
  PV as ar,
  J2 as as,
  Bs as at,
  vn as au,
  Z$ as av,
  Xc as aw,
  Xt as ax,
  fr as ay,
  Et as az,
  he as b,
  Nf as b$,
  V2 as b0,
  pD as b1,
  af as b2,
  dA as b3,
  CD as b4,
  jw as b5,
  sU as b6,
  mD as b7,
  y$ as b8,
  Fe as b9,
  kj as bA,
  Pj as bB,
  sF as bC,
  Lj as bD,
  NT as bE,
  aF as bF,
  fF as bG,
  jj as bH,
  BT as bI,
  pj as bJ,
  fj as bK,
  io as bL,
  Qi as bM,
  Zj as bN,
  s9 as bO,
  a9 as bP,
  Xj as bQ,
  wj as bR,
  Gj as bS,
  Wj as bT,
  i9 as bU,
  o9 as bV,
  Vj as bW,
  ob as bX,
  pF as bY,
  Yj as bZ,
  jF as b_,
  lj as ba,
  Yf as bb,
  EV as bc,
  TV as bd,
  SV as be,
  RV as bf,
  Dm as bg,
  bV as bh,
  iv as bi,
  ED as bj,
  cj as bk,
  bj as bl,
  nF as bm,
  DT as bn,
  _j as bo,
  eF as bp,
  Ep as bq,
  $j as br,
  ki as bs,
  dF as bt,
  WF as bu,
  xj as bv,
  lF as bw,
  rF as bx,
  Tj as by,
  vj as bz,
  at as c,
  L9 as c$,
  cb as c0,
  Cf as c1,
  kT as c2,
  l9 as c3,
  u9 as c4,
  d9 as c5,
  Rf as c6,
  QU as c7,
  E9 as c8,
  v9 as c9,
  k9 as cA,
  I9 as cB,
  JU as cC,
  Kj as cD,
  Lr as cE,
  w9 as cF,
  p9 as cG,
  Mj as cH,
  Cj as cI,
  yF as cJ,
  uj as cK,
  O9 as cL,
  A9 as cM,
  R9 as cN,
  P9 as cO,
  T9 as cP,
  Dj as cQ,
  ql as cR,
  zj as cS,
  Oj as cT,
  Nj as cU,
  db as cV,
  zt as cW,
  hj as cX,
  Rj as cY,
  x9 as cZ,
  QF as c_,
  OT as ca,
  PT as cb,
  y9 as cc,
  vp as cd,
  Zn as ce,
  c9 as cf,
  Qj as cg,
  gj as ch,
  f9 as ci,
  h9 as cj,
  yj as ck,
  Hj as cl,
  XU as cm,
  YU as cn,
  xT as co,
  Bj as cp,
  MT as cq,
  YT as cr,
  g9 as cs,
  ab as ct,
  m9 as cu,
  _9 as cv,
  N9 as cw,
  M9 as cx,
  C9 as cy,
  S9 as cz,
  Yc as d,
  Hf as d$,
  U9 as d0,
  D9 as d1,
  oF as d2,
  dj as d3,
  Ap as d4,
  r9 as d5,
  jl as d6,
  FT as d7,
  VT as d8,
  UT as d9,
  Sj as dA,
  mj as dB,
  Ij as dC,
  Fj as dD,
  qj as dE,
  tV as dF,
  rV as dG,
  H9 as dH,
  t9 as dI,
  G9 as dJ,
  V9 as dK,
  JT as dL,
  K9 as dM,
  Ed as dN,
  Q9 as dO,
  V$ as dP,
  oU as dQ,
  nj as dR,
  rj as dS,
  sj as dT,
  HU as dU,
  KU as dV,
  aj as dW,
  J9 as dX,
  Z9 as dY,
  tj as dZ,
  Lb as d_,
  LT as da,
  b9 as db,
  hF as dc,
  eV as dd,
  z9 as de,
  B9 as df,
  $9 as dg,
  j9 as dh,
  W9 as di,
  kp as dj,
  Y9 as dk,
  X9 as dl,
  q9 as dm,
  nV as dn,
  cV as dp,
  lV as dq,
  n9 as dr,
  wp as ds,
  Ej as dt,
  GF as du,
  Jj as dv,
  e9 as dw,
  Uj as dx,
  Aj as dy,
  uF as dz,
  y2 as e,
  Qc as e$,
  Be as e0,
  zr as e1,
  ov as e2,
  k$ as e3,
  Ll as e4,
  Dl as e5,
  hD as e6,
  ji as e7,
  ip as e8,
  TD as e9,
  A2 as eA,
  R2 as eB,
  S2 as eC,
  yn as eD,
  Uy as eE,
  bD as eF,
  H2 as eG,
  Y2 as eH,
  Q2 as eI,
  Z2 as eJ,
  e$ as eK,
  t$ as eL,
  n$ as eM,
  o$ as eN,
  l$ as eO,
  u$ as eP,
  SD as eQ,
  AD as eR,
  RD as eS,
  f$ as eT,
  h$ as eU,
  p$ as eV,
  kD as eW,
  g$ as eX,
  ND as eY,
  _$ as eZ,
  OD as e_,
  QS as ea,
  vD as eb,
  Xn as ec,
  An as ed,
  a$ as ee,
  wD as ef,
  gD as eg,
  Xm as eh,
  q2 as ei,
  hv as ej,
  yD as ek,
  nB as el,
  dB as em,
  Cc as en,
  R$ as eo,
  c$ as ep,
  i$ as eq,
  ul as er,
  d$ as es,
  _s as et,
  Gs as eu,
  hB as ev,
  K2 as ew,
  S$ as ex,
  TS as ey,
  dv as ez,
  _2 as f,
  Kf as f$,
  PD as f0,
  xD as f1,
  MD as f2,
  b$ as f3,
  E$ as f4,
  w$ as f5,
  T$ as f6,
  I$ as f7,
  C$ as f8,
  op as f9,
  ES as fA,
  Ws as fB,
  PS as fC,
  xS as fD,
  Zi as fE,
  BV as fF,
  $V as fG,
  jV as fH,
  qV as fI,
  zV as fJ,
  WV as fK,
  GV as fL,
  HV as fM,
  k2 as fN,
  N2 as fO,
  O2 as fP,
  P2 as fQ,
  x2 as fR,
  M2 as fS,
  D2 as fT,
  L2 as fU,
  U2 as fV,
  B2 as fW,
  $2 as fX,
  z2 as fY,
  Vm as fZ,
  kS as f_,
  N$ as fa,
  O$ as fb,
  P$ as fc,
  x$ as fd,
  DD as fe,
  LD as ff,
  UD as fg,
  M$ as fh,
  L$ as fi,
  U$ as fj,
  F$ as fk,
  B$ as fl,
  $$ as fm,
  j$ as fn,
  q$ as fo,
  W$ as fp,
  G$ as fq,
  H$ as fr,
  K$ as fs,
  Y$ as ft,
  X$ as fu,
  Q$ as fv,
  ZS as fw,
  eA as fx,
  Pd as fy,
  hn as fz,
  Ur as g,
  iB as g$,
  gB as g0,
  yB as g1,
  _B as g2,
  bB as g3,
  Qm as g4,
  vB as g5,
  EB as g6,
  wB as g7,
  TB as g8,
  IB as g9,
  Bm as gA,
  VV as gB,
  OS as gC,
  DS as gD,
  KV as gE,
  $m as gF,
  YV as gG,
  av as gH,
  cv as gI,
  XV as gJ,
  QV as gK,
  JV as gL,
  jm as gM,
  US as gN,
  ZV as gO,
  FS as gP,
  VS as gQ,
  BS as gR,
  Hs as gS,
  eB as gT,
  qm as gU,
  XS as gV,
  Wm as gW,
  Ya as gX,
  JS as gY,
  rB as gZ,
  Gm as g_,
  AB as ga,
  RB as gb,
  Un as gc,
  fA as gd,
  Rt as ge,
  Mm as gf,
  _S as gg,
  yV as gh,
  _V as gi,
  bS as gj,
  vS as gk,
  Lm as gl,
  IS as gm,
  CV as gn,
  Um as go,
  kV as gp,
  Fm as gq,
  SS as gr,
  AS as gs,
  NV as gt,
  OV as gu,
  xV as gv,
  MV as gw,
  DV as gx,
  NS as gy,
  FV as gz,
  KM as h,
  nA as h0,
  zS as h1,
  lv as h2,
  WS as h3,
  GS as h4,
  zm as h5,
  tB as h6,
  HS as h7,
  Hm as h8,
  oA as h9,
  sB as ha,
  oB as hb,
  aB as hc,
  lc as hd,
  lB as he,
  Ym as hf,
  uB as hg,
  lA as hh,
  fB as hi,
  pB as hj,
  mB as hk,
  ha as hl,
  g2 as i,
  bn as j,
  YM as k,
  E2 as l,
  T2 as m,
  I2 as n,
  w2 as o,
  $B as p,
  b2 as q,
  XB as r,
  A$ as s,
  rp as t,
  v$ as u,
  jB as v,
  v2 as w,
  YB as x,
  KB as y,
  zB as z
};
